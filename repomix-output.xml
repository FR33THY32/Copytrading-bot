This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
parsers/
  mod.rs
  pump_amm.rs
  pump_fun.rs
swap/
  common.rs
  constants.rs
  mod.rs
  pump_amm.rs
  pump.rs
config.rs
copytrade.rs
executor.rs
lazy_signature.rs
main.rs
nonce.rs
program_registry.rs
serialization.rs
transaction_processor.rs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="parsers/mod.rs">
use solana_sdk::{instruction::CompiledInstruction, pubkey::Pubkey};
use std::fmt::Debug;
use thiserror::Error;

pub mod pump_amm;
pub mod pump_fun;

/// Result type for parser operations
pub type ParserResult<T> = Result<T, ParserError>;

/// Error types for parsing operations
#[derive(Debug, Error)]
pub enum ParserError {
    #[error("Invalid instruction data: {0}")]
    InvalidInstruction(String),

    #[error("Invalid event data: {0}")]
    InvalidEvent(String),

    #[error("Account index out of bounds: {index}")]
    AccountIndexOutOfBounds { index: usize },

    #[error("Missing required account: {0}")]
    MissingAccount(String),

    #[error("Deserialization error: {0}")]
    DeserializationError(String),

    #[error("Unknown instruction discriminator: {0}")]
    UnknownDiscriminator(u8),

    #[error("Parser not implemented for program: {0}")]
    ParserNotImplemented(Pubkey),

    #[error("Other error: {0}")]
    Other(String),
}

/// Parsed instruction representation
#[derive(Debug, Clone)]
pub enum ParsedInstruction {
    /// PumpFun program instructions
    PumpFun(pump_fun::PumpFunInstruction),
    /// Pump AMM program instructions
    PumpAmm(pump_amm::PumpAmmInstruction),

    /// Add more program instruction types here as needed
    // Raydium(raydium::RaydiumInstruction),
    // Jupiter(jupiter::JupiterInstruction),

    /// Unknown instruction that couldn't be parsed
    Unknown { program_id: Pubkey, data: Vec<u8> },
}

/// Parsed event representation
#[derive(Debug, Clone)]
pub enum ParsedEvent {
    /// PumpFun program events
    PumpFun(pump_fun::PumpFunEvent),
    /// Pump AMM program events
    PumpAmm(pump_amm::PumpAmmEvent),

    /// Add more program event types here as needed
    // Raydium(raydium::RaydiumEvent),
    // Jupiter(jupiter::JupiterEvent),

    /// Generic log event
    Log { program_id: Pubkey, message: String },
}

/// Context for instruction parsing - includes the instruction and its metadata
#[derive(Debug, Clone)]
pub struct InstructionWithContext {
    pub instruction: CompiledInstruction,
    pub program_id: Pubkey,
    pub instruction_index: usize,
    pub stack_depth: usize,
}

/// Context provided to event parsers
#[derive(Debug)]
pub struct EventParsingContext<'a> {
    /// All log messages from the transaction
    pub logs: &'a [String],

    /// All instructions from the transaction (for context-aware parsing)
    pub instructions: &'a [InstructionWithContext],
}

/// Trait that all program parsers must implement
pub trait ProgramParser: Send + Sync + Debug {
    /// Parse an instruction for this program
    fn parse_instruction(
        &self,
        instruction: &CompiledInstruction,
        account_keys: &[Pubkey],
    ) -> ParserResult<ParsedInstruction>;

    /// Parse events from log messages (simple log-based parsing)
    fn parse_events(&self, logs: &[String]) -> ParserResult<Vec<ParsedEvent>> {
        // Default implementation returns empty vec
        Ok(Vec::new())
    }

    /// Parse events with full context (logs + instructions)
    fn parse_events_with_context(
        &self,
        context: &EventParsingContext,
        account_keys: &[Pubkey],
    ) -> ParserResult<Vec<ParsedEvent>> {
        // Default implementation delegates to simple parse_events
        self.parse_events(context.logs)
    }

    /// Get the program ID this parser handles
    fn program_id(&self) -> Pubkey;
}

/// Helper function to safely get an account from instruction
pub fn get_account_at_index(
    instruction: &CompiledInstruction,
    account_keys: &[Pubkey],
    index: usize,
) -> ParserResult<Pubkey> {
    instruction
        .accounts
        .get(index)
        .and_then(|&account_index| account_keys.get(account_index as usize))
        .copied()
        .ok_or_else(|| ParserError::AccountIndexOutOfBounds { index })
}

/// Helper function to get multiple accounts
pub fn get_accounts(
    instruction: &CompiledInstruction,
    account_keys: &[Pubkey],
    indices: &[usize],
) -> ParserResult<Vec<Pubkey>> {
    indices
        .iter()
        .map(|&index| get_account_at_index(instruction, account_keys, index))
        .collect()
}

/// Helper to extract instruction discriminator (first byte)
pub fn get_discriminator(data: &[u8]) -> ParserResult<u8> {
    data.first()
        .copied()
        .ok_or_else(|| ParserError::InvalidInstruction("Empty instruction data".to_string()))
}

/// Helper to extract 8-byte discriminator (Anchor-style)
pub fn get_anchor_discriminator(data: &[u8]) -> ParserResult<[u8; 8]> {
    if data.len() < 8 {
        return Err(ParserError::InvalidInstruction(
            "Instruction data too short for anchor discriminator".to_string(),
        ));
    }

    let mut discriminator = [0u8; 8];
    discriminator.copy_from_slice(&data[..8]);
    Ok(discriminator)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_discriminator() {
        let data = vec![1, 2, 3, 4];
        assert_eq!(get_discriminator(&data).unwrap(), 1);

        let empty_data = vec![];
        assert!(get_discriminator(&empty_data).is_err());
    }

    #[test]
    fn test_get_anchor_discriminator() {
        let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        let discriminator = get_anchor_discriminator(&data).unwrap();
        assert_eq!(discriminator, [1, 2, 3, 4, 5, 6, 7, 8]);

        let short_data = vec![1, 2, 3];
        assert!(get_anchor_discriminator(&short_data).is_err());
    }
}
</file>

<file path="parsers/pump_amm.rs">
use super::{
    get_account_at_index, get_anchor_discriminator, EventParsingContext, InstructionWithContext,
};
use super::{ParsedEvent, ParsedInstruction, ParserError, ParserResult, ProgramParser};
use borsh::{to_vec, BorshDeserialize, BorshSerialize};
use solana_sdk::{instruction::CompiledInstruction, pubkey, pubkey::Pubkey};
use std::convert::TryInto;

/// Pump AMM program ID
pub const PUMP_AMM_PROGRAM_ID: Pubkey = pubkey!("pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA");

/// Pump AMM instruction discriminators
pub mod discriminators {
    pub const BUY: [u8; 8] = [102, 6, 61, 18, 1, 218, 235, 234];
    pub const BUY_EXACT_QUOTE_IN: [u8; 8] = [198, 46, 21, 82, 180, 217, 232, 112];
    pub const SELL: [u8; 8] = [51, 230, 133, 164, 1, 127, 131, 173];
}

/// Pump AMM event discriminators (8 bytes)
pub mod event_discriminators {
    pub const BUY_EVENT: [u8; 8] = [103, 244, 82, 31, 44, 245, 119, 119];
    pub const SELL_EVENT: [u8; 8] = [62, 47, 55, 10, 165, 3, 220, 42];
}

/// Pump AMM instructions
#[derive(Debug, Clone, PartialEq)]
pub enum PumpAmmInstruction {
    Buy {
        // args
        base_amount_out: u64,
        max_quote_amount_in: u64,
        track_volume: bool,
        // accounts (IDL order)
        pool: Pubkey,
        user: Pubkey,
        global_config: Pubkey,
        base_mint: Pubkey,
        quote_mint: Pubkey,
        user_base_token_account: Pubkey,
        user_quote_token_account: Pubkey,
        pool_base_token_account: Pubkey,
        pool_quote_token_account: Pubkey,
        protocol_fee_recipient: Pubkey,
        protocol_fee_recipient_token_account: Pubkey,
        base_token_program: Pubkey,
        quote_token_program: Pubkey,
        system_program: Pubkey,
        associated_token_program: Pubkey,
        event_authority: Pubkey,
        program: Pubkey,
        coin_creator_vault_ata: Pubkey,
        coin_creator_vault_authority: Pubkey,
        global_volume_accumulator: Pubkey,
        user_volume_accumulator: Pubkey,
        fee_config: Pubkey,
        fee_program: Pubkey,
    },
    BuyExactQuoteIn {
        // args
        spendable_quote_in: u64,
        min_base_amount_out: u64,
        track_volume: bool,
        // accounts (IDL order)
        pool: Pubkey,
        user: Pubkey,
        global_config: Pubkey,
        base_mint: Pubkey,
        quote_mint: Pubkey,
        user_base_token_account: Pubkey,
        user_quote_token_account: Pubkey,
        pool_base_token_account: Pubkey,
        pool_quote_token_account: Pubkey,
        protocol_fee_recipient: Pubkey,
        protocol_fee_recipient_token_account: Pubkey,
        base_token_program: Pubkey,
        quote_token_program: Pubkey,
        system_program: Pubkey,
        associated_token_program: Pubkey,
        event_authority: Pubkey,
        program: Pubkey,
        coin_creator_vault_ata: Pubkey,
        coin_creator_vault_authority: Pubkey,
        global_volume_accumulator: Pubkey,
        user_volume_accumulator: Pubkey,
        fee_config: Pubkey,
        fee_program: Pubkey,
    },
    Sell {
        // args
        base_amount_in: u64,
        min_quote_amount_out: u64,
        // accounts (IDL order)
        pool: Pubkey,
        user: Pubkey,
        global_config: Pubkey,
        base_mint: Pubkey,
        quote_mint: Pubkey,
        user_base_token_account: Pubkey,
        user_quote_token_account: Pubkey,
        pool_base_token_account: Pubkey,
        pool_quote_token_account: Pubkey,
        protocol_fee_recipient: Pubkey,
        protocol_fee_recipient_token_account: Pubkey,
        base_token_program: Pubkey,
        quote_token_program: Pubkey,
        system_program: Pubkey,
        associated_token_program: Pubkey,
        event_authority: Pubkey,
        program: Pubkey,
        coin_creator_vault_ata: Pubkey,
        coin_creator_vault_authority: Pubkey,
        fee_config: Pubkey,
        fee_program: Pubkey,
    },
}

/// Pump AMM events
#[derive(Debug, Clone, PartialEq)]
pub enum PumpAmmEvent {
    BuyEvent {
        timestamp: i64,
        base_amount_out: u64,
        max_quote_amount_in: u64,
        user_base_token_reserves: u64,
        user_quote_token_reserves: u64,
        pool_base_token_reserves: u64,
        pool_quote_token_reserves: u64,
        quote_amount_in: u64,
        lp_fee_basis_points: u64,
        lp_fee: u64,
        protocol_fee_basis_points: u64,
        protocol_fee: u64,
        quote_amount_in_with_lp_fee: u64,
        user_quote_amount_in: u64,
        min_base_amount_out: u64,
        ix_name: String,
        pool: Pubkey,
        user: Pubkey,
        user_base_token_account: Pubkey,
        user_quote_token_account: Pubkey,
        protocol_fee_recipient: Pubkey,
        protocol_fee_recipient_token_account: Pubkey,
        coin_creator: Pubkey,
        coin_creator_fee_basis_points: u64,
        coin_creator_fee: u64,
        track_volume: bool,
        total_unclaimed_tokens: u64,
        total_claimed_tokens: u64,
        current_sol_volume: u64,
        last_update_timestamp: i64,
        // Context metadata
        context_instruction_index: usize,
        context_position: usize,
        context_parent_position: usize,
    },
    SellEvent {
        timestamp: i64,
        base_amount_in: u64,
        min_quote_amount_out: u64,
        user_base_token_reserves: u64,
        user_quote_token_reserves: u64,
        pool_base_token_reserves: u64,
        pool_quote_token_reserves: u64,
        quote_amount_out: u64,
        lp_fee_basis_points: u64,
        lp_fee: u64,
        protocol_fee_basis_points: u64,
        protocol_fee: u64,
        quote_amount_out_without_lp_fee: u64,
        user_quote_amount_out: u64,
        pool: Pubkey,
        user: Pubkey,
        user_base_token_account: Pubkey,
        user_quote_token_account: Pubkey,
        protocol_fee_recipient: Pubkey,
        protocol_fee_recipient_token_account: Pubkey,
        coin_creator: Pubkey,
        coin_creator_fee_basis_points: u64,
        coin_creator_fee: u64,
        // Context metadata
        context_instruction_index: usize,
        context_position: usize,
        context_parent_position: usize,
    },
}

/// Borsh-serializable structs for instruction data
#[derive(BorshSerialize, BorshDeserialize, Debug)]
struct BuyArgs {
    base_amount_out: u64,
    max_quote_amount_in: u64,
    track_volume: OptionBool,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
struct BuyExactQuoteInArgs {
    spendable_quote_in: u64,
    min_base_amount_out: u64,
    track_volume: OptionBool,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
struct SellArgs {
    base_amount_in: u64,
    min_quote_amount_out: u64,
}

#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, Copy)]
struct OptionBool(pub bool);

impl From<OptionBool> for bool {
    fn from(value: OptionBool) -> Self {
        value.0
    }
}

/// Borsh-serializable structs for event data
#[derive(BorshSerialize, BorshDeserialize, Debug)]
struct BuyEventData {
    timestamp: i64,
    base_amount_out: u64,
    max_quote_amount_in: u64,
    user_base_token_reserves: u64,
    user_quote_token_reserves: u64,
    pool_base_token_reserves: u64,
    pool_quote_token_reserves: u64,
    quote_amount_in: u64,
    lp_fee_basis_points: u64,
    lp_fee: u64,
    protocol_fee_basis_points: u64,
    protocol_fee: u64,
    quote_amount_in_with_lp_fee: u64,
    user_quote_amount_in: u64,
    pool: Pubkey,
    user: Pubkey,
    user_base_token_account: Pubkey,
    user_quote_token_account: Pubkey,
    protocol_fee_recipient: Pubkey,
    protocol_fee_recipient_token_account: Pubkey,
    coin_creator: Pubkey,
    coin_creator_fee_basis_points: u64,
    coin_creator_fee: u64,
    track_volume: bool,
    total_unclaimed_tokens: u64,
    total_claimed_tokens: u64,
    current_sol_volume: u64,
    last_update_timestamp: i64,
    min_base_amount_out: u64,
    ix_name: String,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
struct SellEventData {
    timestamp: i64,
    base_amount_in: u64,
    min_quote_amount_out: u64,
    user_base_token_reserves: u64,
    user_quote_token_reserves: u64,
    pool_base_token_reserves: u64,
    pool_quote_token_reserves: u64,
    quote_amount_out: u64,
    lp_fee_basis_points: u64,
    lp_fee: u64,
    protocol_fee_basis_points: u64,
    protocol_fee: u64,
    quote_amount_out_without_lp_fee: u64,
    user_quote_amount_out: u64,
    pool: Pubkey,
    user: Pubkey,
    user_base_token_account: Pubkey,
    user_quote_token_account: Pubkey,
    protocol_fee_recipient: Pubkey,
    protocol_fee_recipient_token_account: Pubkey,
    coin_creator: Pubkey,
    coin_creator_fee_basis_points: u64,
    coin_creator_fee: u64,
}

/// Main implementation
#[derive(Debug)]
pub struct PumpAmmParser;

impl PumpAmmParser {
    pub fn new() -> Self {
        Self
    }

    /// Parse buy instruction
    fn parse_buy(
        &self,
        instruction: &CompiledInstruction,
        account_keys: &[Pubkey],
    ) -> ParserResult<PumpAmmInstruction> {
        let (base_amount_out, max_quote_amount_in, track_volume) =
            Self::decode_buy_args(&instruction.data[8..])?;

        // Extract accounts according to IDL (complete list)
        let pool = get_account_at_index(instruction, account_keys, 0)?;
        let user = get_account_at_index(instruction, account_keys, 1)?;
        let global_config = get_account_at_index(instruction, account_keys, 2)?;
        let base_mint = get_account_at_index(instruction, account_keys, 3)?;
        let quote_mint = get_account_at_index(instruction, account_keys, 4)?;
        let user_base_token_account = get_account_at_index(instruction, account_keys, 5)?;
        let user_quote_token_account = get_account_at_index(instruction, account_keys, 6)?;
        let pool_base_token_account = get_account_at_index(instruction, account_keys, 7)?;
        let pool_quote_token_account = get_account_at_index(instruction, account_keys, 8)?;
        let protocol_fee_recipient = get_account_at_index(instruction, account_keys, 9)?;
        let protocol_fee_recipient_token_account =
            get_account_at_index(instruction, account_keys, 10)?;
        let base_token_program = get_account_at_index(instruction, account_keys, 11)?;
        let quote_token_program = get_account_at_index(instruction, account_keys, 12)?;
        let system_program = get_account_at_index(instruction, account_keys, 13)?;
        let associated_token_program = get_account_at_index(instruction, account_keys, 14)?;
        let event_authority = get_account_at_index(instruction, account_keys, 15)?;
        let program = get_account_at_index(instruction, account_keys, 16)?;
        let coin_creator_vault_ata = get_account_at_index(instruction, account_keys, 17)?;
        let coin_creator_vault_authority = get_account_at_index(instruction, account_keys, 18)?;
        let global_volume_accumulator = get_account_at_index(instruction, account_keys, 19)?;
        let user_volume_accumulator = get_account_at_index(instruction, account_keys, 20)?;
        let fee_config = get_account_at_index(instruction, account_keys, 21)?;
        let fee_program = get_account_at_index(instruction, account_keys, 22)?;

        Ok(PumpAmmInstruction::Buy {
            // args
            base_amount_out,
            max_quote_amount_in,
            track_volume,
            // accounts
            pool,
            user,
            global_config,
            base_mint,
            quote_mint,
            user_base_token_account,
            user_quote_token_account,
            pool_base_token_account,
            pool_quote_token_account,
            protocol_fee_recipient,
            protocol_fee_recipient_token_account,
            base_token_program,
            quote_token_program,
            system_program,
            associated_token_program,
            event_authority,
            program,
            coin_creator_vault_ata,
            coin_creator_vault_authority,
            global_volume_accumulator,
            user_volume_accumulator,
            fee_config,
            fee_program,
        })
    }

    /// Parse buy_exact_quote_in instruction
    fn parse_buy_exact_quote_in(
        &self,
        instruction: &CompiledInstruction,
        account_keys: &[Pubkey],
    ) -> ParserResult<PumpAmmInstruction> {
        let (spendable_quote_in, min_base_amount_out, track_volume) =
            Self::decode_buy_exact_quote_in_args(&instruction.data[8..])?;

        let pool = get_account_at_index(instruction, account_keys, 0)?;
        let user = get_account_at_index(instruction, account_keys, 1)?;
        let global_config = get_account_at_index(instruction, account_keys, 2)?;
        let base_mint = get_account_at_index(instruction, account_keys, 3)?;
        let quote_mint = get_account_at_index(instruction, account_keys, 4)?;
        let user_base_token_account = get_account_at_index(instruction, account_keys, 5)?;
        let user_quote_token_account = get_account_at_index(instruction, account_keys, 6)?;
        let pool_base_token_account = get_account_at_index(instruction, account_keys, 7)?;
        let pool_quote_token_account = get_account_at_index(instruction, account_keys, 8)?;
        let protocol_fee_recipient = get_account_at_index(instruction, account_keys, 9)?;
        let protocol_fee_recipient_token_account =
            get_account_at_index(instruction, account_keys, 10)?;
        let base_token_program = get_account_at_index(instruction, account_keys, 11)?;
        let quote_token_program = get_account_at_index(instruction, account_keys, 12)?;
        let system_program = get_account_at_index(instruction, account_keys, 13)?;
        let associated_token_program = get_account_at_index(instruction, account_keys, 14)?;
        let event_authority = get_account_at_index(instruction, account_keys, 15)?;
        let program = get_account_at_index(instruction, account_keys, 16)?;
        let coin_creator_vault_ata = get_account_at_index(instruction, account_keys, 17)?;
        let coin_creator_vault_authority = get_account_at_index(instruction, account_keys, 18)?;
        let global_volume_accumulator = get_account_at_index(instruction, account_keys, 19)?;
        let user_volume_accumulator = get_account_at_index(instruction, account_keys, 20)?;
        let fee_config = get_account_at_index(instruction, account_keys, 21)?;
        let fee_program = get_account_at_index(instruction, account_keys, 22)?;

        Ok(PumpAmmInstruction::BuyExactQuoteIn {
            spendable_quote_in,
            min_base_amount_out,
            track_volume,
            pool,
            user,
            global_config,
            base_mint,
            quote_mint,
            user_base_token_account,
            user_quote_token_account,
            pool_base_token_account,
            pool_quote_token_account,
            protocol_fee_recipient,
            protocol_fee_recipient_token_account,
            base_token_program,
            quote_token_program,
            system_program,
            associated_token_program,
            event_authority,
            program,
            coin_creator_vault_ata,
            coin_creator_vault_authority,
            global_volume_accumulator,
            user_volume_accumulator,
            fee_config,
            fee_program,
        })
    }

    fn decode_buy_args(data: &[u8]) -> ParserResult<(u64, u64, bool)> {
        if data.len() < 16 {
            return Err(ParserError::InvalidInstruction(
                "Pump AMM buy args too short".to_string(),
            ));
        }
        let base_amount_out = u64::from_le_bytes(
            data[0..8]
                .try_into()
                .map_err(|_| ParserError::InvalidInstruction("Invalid buy args".to_string()))?,
        );
        let max_quote_amount_in = u64::from_le_bytes(
            data[8..16]
                .try_into()
                .map_err(|_| ParserError::InvalidInstruction("Invalid buy args".to_string()))?,
        );
        if data.len() == 16 {
            return Ok((base_amount_out, max_quote_amount_in, false));
        }
        let args = BuyArgs::try_from_slice(data)
            .map_err(|e| ParserError::DeserializationError(e.to_string()))?;
        Ok((
            args.base_amount_out,
            args.max_quote_amount_in,
            args.track_volume.into(),
        ))
    }

    fn decode_buy_exact_quote_in_args(data: &[u8]) -> ParserResult<(u64, u64, bool)> {
        if data.len() < 16 {
            return Err(ParserError::InvalidInstruction(
                "Pump AMM buy_exact_quote_in args too short".to_string(),
            ));
        }
        let spendable_quote_in =
            u64::from_le_bytes(data[0..8].try_into().map_err(|_| {
                ParserError::InvalidInstruction("Invalid buy_exact args".to_string())
            })?);
        let min_base_amount_out =
            u64::from_le_bytes(data[8..16].try_into().map_err(|_| {
                ParserError::InvalidInstruction("Invalid buy_exact args".to_string())
            })?);
        if data.len() == 16 {
            return Ok((spendable_quote_in, min_base_amount_out, false));
        }
        let args = BuyExactQuoteInArgs::try_from_slice(data)
            .map_err(|e| ParserError::DeserializationError(e.to_string()))?;
        Ok((
            args.spendable_quote_in,
            args.min_base_amount_out,
            args.track_volume.into(),
        ))
    }

    /// Parse sell instruction
    fn parse_sell(
        &self,
        instruction: &CompiledInstruction,
        account_keys: &[Pubkey],
    ) -> ParserResult<PumpAmmInstruction> {
        let args = SellArgs::try_from_slice(&instruction.data[8..])
            .map_err(|e| ParserError::DeserializationError(e.to_string()))?;

        // Extract accounts according to IDL (complete list)
        let pool = get_account_at_index(instruction, account_keys, 0)?;
        let user = get_account_at_index(instruction, account_keys, 1)?;
        let global_config = get_account_at_index(instruction, account_keys, 2)?;
        let base_mint = get_account_at_index(instruction, account_keys, 3)?;
        let quote_mint = get_account_at_index(instruction, account_keys, 4)?;
        let user_base_token_account = get_account_at_index(instruction, account_keys, 5)?;
        let user_quote_token_account = get_account_at_index(instruction, account_keys, 6)?;
        let pool_base_token_account = get_account_at_index(instruction, account_keys, 7)?;
        let pool_quote_token_account = get_account_at_index(instruction, account_keys, 8)?;
        let protocol_fee_recipient = get_account_at_index(instruction, account_keys, 9)?;
        let protocol_fee_recipient_token_account =
            get_account_at_index(instruction, account_keys, 10)?;
        let base_token_program = get_account_at_index(instruction, account_keys, 11)?;
        let quote_token_program = get_account_at_index(instruction, account_keys, 12)?;
        let system_program = get_account_at_index(instruction, account_keys, 13)?;
        let associated_token_program = get_account_at_index(instruction, account_keys, 14)?;
        let event_authority = get_account_at_index(instruction, account_keys, 15)?;
        let program = get_account_at_index(instruction, account_keys, 16)?;
        let coin_creator_vault_ata = get_account_at_index(instruction, account_keys, 17)?;
        let coin_creator_vault_authority = get_account_at_index(instruction, account_keys, 18)?;
        let fee_config = get_account_at_index(instruction, account_keys, 19)?;
        let fee_program = get_account_at_index(instruction, account_keys, 20)?;

        Ok(PumpAmmInstruction::Sell {
            // args
            base_amount_in: args.base_amount_in,
            min_quote_amount_out: args.min_quote_amount_out,
            // accounts
            pool,
            user,
            global_config,
            base_mint,
            quote_mint,
            user_base_token_account,
            user_quote_token_account,
            pool_base_token_account,
            pool_quote_token_account,
            protocol_fee_recipient,
            protocol_fee_recipient_token_account,
            base_token_program,
            quote_token_program,
            system_program,
            associated_token_program,
            event_authority,
            program,
            coin_creator_vault_ata,
            coin_creator_vault_authority,
            fee_config,
            fee_program,
        })
    }

    /// Parse event from instruction data (supports BuyEvent and SellEvent)
    fn parse_event_from_instruction(
        &self,
        ctx_ix: &InstructionWithContext,
    ) -> Option<PumpAmmEvent> {
        let instruction = &ctx_ix.instruction;
        if instruction.data.len() < 16 {
            return None;
        }
        // Skip the first 8 bytes (anchor discriminator), match the next 8 bytes (event discriminator)
        let discriminator: [u8; 8] = instruction.data[8..16].try_into().ok()?;
        match discriminator {
            event_discriminators::BUY_EVENT => {
                let data = BuyEventData::try_from_slice(&instruction.data[16..]).ok()?;
                Some(PumpAmmEvent::BuyEvent {
                    timestamp: data.timestamp,
                    base_amount_out: data.base_amount_out,
                    max_quote_amount_in: data.max_quote_amount_in,
                    min_base_amount_out: data.min_base_amount_out,
                    user_base_token_reserves: data.user_base_token_reserves,
                    user_quote_token_reserves: data.user_quote_token_reserves,
                    pool_base_token_reserves: data.pool_base_token_reserves,
                    pool_quote_token_reserves: data.pool_quote_token_reserves,
                    quote_amount_in: data.quote_amount_in,
                    lp_fee_basis_points: data.lp_fee_basis_points,
                    lp_fee: data.lp_fee,
                    protocol_fee_basis_points: data.protocol_fee_basis_points,
                    protocol_fee: data.protocol_fee,
                    quote_amount_in_with_lp_fee: data.quote_amount_in_with_lp_fee,
                    user_quote_amount_in: data.user_quote_amount_in,
                    pool: data.pool,
                    user: data.user,
                    user_base_token_account: data.user_base_token_account,
                    user_quote_token_account: data.user_quote_token_account,
                    protocol_fee_recipient: data.protocol_fee_recipient,
                    protocol_fee_recipient_token_account: data.protocol_fee_recipient_token_account,
                    coin_creator: data.coin_creator,
                    coin_creator_fee_basis_points: data.coin_creator_fee_basis_points,
                    coin_creator_fee: data.coin_creator_fee,
                    track_volume: data.track_volume,
                    total_unclaimed_tokens: data.total_unclaimed_tokens,
                    total_claimed_tokens: data.total_claimed_tokens,
                    current_sol_volume: data.current_sol_volume,
                    last_update_timestamp: data.last_update_timestamp,
                    ix_name: data.ix_name,
                    context_instruction_index: ctx_ix.instruction_index,
                    context_position: ctx_ix.stack_depth,
                    context_parent_position: ctx_ix.stack_depth.saturating_sub(1),
                })
            }
            event_discriminators::SELL_EVENT => {
                let data = SellEventData::try_from_slice(&instruction.data[16..]).ok()?;
                Some(PumpAmmEvent::SellEvent {
                    timestamp: data.timestamp,
                    base_amount_in: data.base_amount_in,
                    min_quote_amount_out: data.min_quote_amount_out,
                    user_base_token_reserves: data.user_base_token_reserves,
                    user_quote_token_reserves: data.user_quote_token_reserves,
                    pool_base_token_reserves: data.pool_base_token_reserves,
                    pool_quote_token_reserves: data.pool_quote_token_reserves,
                    quote_amount_out: data.quote_amount_out,
                    lp_fee_basis_points: data.lp_fee_basis_points,
                    lp_fee: data.lp_fee,
                    protocol_fee_basis_points: data.protocol_fee_basis_points,
                    protocol_fee: data.protocol_fee,
                    quote_amount_out_without_lp_fee: data.quote_amount_out_without_lp_fee,
                    user_quote_amount_out: data.user_quote_amount_out,
                    pool: data.pool,
                    user: data.user,
                    user_base_token_account: data.user_base_token_account,
                    user_quote_token_account: data.user_quote_token_account,
                    protocol_fee_recipient: data.protocol_fee_recipient,
                    protocol_fee_recipient_token_account: data.protocol_fee_recipient_token_account,
                    coin_creator: data.coin_creator,
                    coin_creator_fee_basis_points: data.coin_creator_fee_basis_points,
                    coin_creator_fee: data.coin_creator_fee,
                    context_instruction_index: ctx_ix.instruction_index,
                    context_position: ctx_ix.stack_depth,
                    context_parent_position: ctx_ix.stack_depth.saturating_sub(1),
                })
            }
            _ => None,
        }
    }

    /// Parse events from instructions (Pump AMM emits events as CPI instructions)
    fn parse_events_from_instructions(&self, context: &EventParsingContext) -> Vec<PumpAmmEvent> {
        let mut events = Vec::new();
        let mut latest_parent_per_depth: Vec<Option<(usize, usize)>> = Vec::new();

        for instruction_ctx in context.instructions.iter() {
            if instruction_ctx.program_id != PUMP_AMM_PROGRAM_ID {
                continue;
            }

            if Self::is_trade_instruction(&instruction_ctx.instruction.data) {
                Self::record_parent_instruction(&mut latest_parent_per_depth, instruction_ctx);
                continue;
            }

            if let Some(mut event) = self.parse_event_from_instruction(instruction_ctx) {
                match &mut event {
                    PumpAmmEvent::BuyEvent {
                        context_instruction_index,
                        context_position,
                        context_parent_position,
                        ..
                    }
                    | PumpAmmEvent::SellEvent {
                        context_instruction_index,
                        context_position,
                        context_parent_position,
                        ..
                    } => {
                        if let Some((parent_idx, parent_depth)) = Self::find_latest_parent(
                            &latest_parent_per_depth,
                            instruction_ctx.stack_depth,
                        ) {
                            *context_instruction_index = parent_idx;
                            *context_position = parent_depth;
                            *context_parent_position = parent_depth;
                        }
                    }
                }
                events.push(event);
            }
        }

        events
    }

    fn is_trade_instruction(data: &[u8]) -> bool {
        if let Ok(discriminator) = get_anchor_discriminator(data) {
            discriminator == discriminators::BUY
                || discriminator == discriminators::BUY_EXACT_QUOTE_IN
                || discriminator == discriminators::SELL
        } else {
            false
        }
    }

    fn record_parent_instruction(
        latest: &mut Vec<Option<(usize, usize)>>,
        ctx: &InstructionWithContext,
    ) {
        if latest.len() <= ctx.stack_depth {
            latest.resize(ctx.stack_depth + 1, None);
        }
        latest[ctx.stack_depth] = Some((ctx.instruction_index, ctx.stack_depth));
    }

    fn find_latest_parent(
        latest: &[Option<(usize, usize)>],
        event_depth: usize,
    ) -> Option<(usize, usize)> {
        if latest.is_empty() {
            return None;
        }

        let mut depth = event_depth.min(latest.len() - 1);
        loop {
            if let Some(entry) = latest.get(depth).and_then(|opt| *opt) {
                return Some(entry);
            }
            if depth == 0 {
                break;
            }
            depth -= 1;
        }

        None
    }
}

impl ProgramParser for PumpAmmParser {
    fn parse_instruction(
        &self,
        instruction: &CompiledInstruction,
        account_keys: &[Pubkey],
    ) -> ParserResult<ParsedInstruction> {
        let discriminator = get_anchor_discriminator(&instruction.data)?;
        let parsed = match discriminator {
            discriminators::BUY => self.parse_buy(instruction, account_keys)?,
            discriminators::BUY_EXACT_QUOTE_IN => {
                self.parse_buy_exact_quote_in(instruction, account_keys)?
            }
            discriminators::SELL => self.parse_sell(instruction, account_keys)?,
            _ => {
                return Ok(ParsedInstruction::Unknown {
                    program_id: PUMP_AMM_PROGRAM_ID,
                    data: instruction.data.clone(),
                });
            }
        };
        Ok(ParsedInstruction::PumpAmm(parsed))
    }

    fn parse_events(&self, _logs: &[String]) -> ParserResult<Vec<ParsedEvent>> {
        Ok(Vec::new())
    }

    fn parse_events_with_context(
        &self,
        context: &EventParsingContext,
        _account_keys: &[Pubkey],
    ) -> ParserResult<Vec<ParsedEvent>> {
        let events = self.parse_events_from_instructions(context);
        Ok(events.into_iter().map(ParsedEvent::PumpAmm).collect())
    }

    fn program_id(&self) -> Pubkey {
        PUMP_AMM_PROGRAM_ID
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pump_amm_parser_creation() {
        let parser = PumpAmmParser::new();
        assert_eq!(parser.program_id(), PUMP_AMM_PROGRAM_ID);
    }

    #[test]
    fn test_decode_buy_args_with_and_without_track_volume() {
        let legacy = [
            102, 6, 61, 18, 1, 218, 235, 234, // discriminator
            208, 241, 19, 8, 246, 14, 0, 0, // base amount
            48, 168, 11, 126, 0, 0, 0, 0, // max quote
        ];
        let modern_payload = to_vec(&BuyArgs {
            base_amount_out: 42,
            max_quote_amount_in: 24,
            track_volume: OptionBool(true),
        })
        .unwrap();
        let json_discriminator = discriminators::BUY;
        let mut modern = json_discriminator.to_vec();
        modern.extend_from_slice(&modern_payload);

        let (legacy_base, legacy_quote, legacy_track) =
            PumpAmmParser::decode_buy_args(&legacy[8..]).expect("legacy decode succeeds");
        assert_eq!(legacy_base, 0x0000_0ef6_0813_f1d0);
        assert_eq!(legacy_quote, 0x0000_0000_7e0b_a830);
        assert!(!legacy_track);

        let (modern_base, modern_quote, modern_track) =
            PumpAmmParser::decode_buy_args(&modern[8..]).expect("modern decode succeeds");
        assert_eq!(modern_base, 42);
        assert_eq!(modern_quote, 24);
        assert!(modern_track);
    }

    #[test]
    fn test_decode_buy_exact_quote_in_args() {
        let legacy = [
            198, 46, 21, 82, 180, 217, 232, 112, // discriminator
            10, 0, 0, 0, 0, 0, 0, 0, // spendable
            20, 0, 0, 0, 0, 0, 0, 0, // min base
        ];
        let modern_payload = to_vec(&BuyExactQuoteInArgs {
            spendable_quote_in: 100,
            min_base_amount_out: 5,
            track_volume: OptionBool(true),
        })
        .unwrap();
        let mut modern = discriminators::BUY_EXACT_QUOTE_IN.to_vec();
        modern.extend_from_slice(&modern_payload);

        let (legacy_spend, legacy_min, legacy_track) =
            PumpAmmParser::decode_buy_exact_quote_in_args(&legacy[8..]).expect("legacy decode");
        assert_eq!(legacy_spend, 10);
        assert_eq!(legacy_min, 20);
        assert!(!legacy_track);

        let (modern_spend, modern_min, modern_track) =
            PumpAmmParser::decode_buy_exact_quote_in_args(&modern[8..]).expect("modern decode");
        assert_eq!(modern_spend, 100);
        assert_eq!(modern_min, 5);
        assert!(modern_track);
    }
}
</file>

<file path="parsers/pump_fun.rs">
use super::{
    get_account_at_index, get_anchor_discriminator, EventParsingContext, InstructionWithContext,
};
use super::{ParsedEvent, ParsedInstruction, ParserError, ParserResult, ProgramParser};
use borsh::{BorshDeserialize, BorshSerialize};
use solana_sdk::{instruction::CompiledInstruction, pubkey, pubkey::Pubkey};
use std::convert::TryInto;

/// PumpFun program ID
pub const PUMP_FUN_PROGRAM_ID: Pubkey = pubkey!("6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P");

// Pre-computed strings for performance (kept for compatibility)
lazy_static::lazy_static! {
    static ref PUMP_FUN_INVOKE_PREFIX: String = format!("Program {} invoke", PUMP_FUN_PROGRAM_ID);
}

/// PumpFun instruction discriminators
pub mod discriminators {
    pub const BUY: [u8; 8] = [102, 6, 61, 18, 1, 218, 235, 234];
    pub const BUY_EXACT_SOL_IN: [u8; 8] = [56, 252, 116, 8, 158, 223, 205, 95];
    pub const SELL: [u8; 8] = [51, 230, 133, 164, 1, 127, 131, 173];
}

/// PumpFun event discriminators (8 bytes, skipping Anchor's 8-byte event prefix)
pub mod event_discriminators {
    pub const TRADE_EVENT: [u8; 8] = [189, 219, 127, 211, 78, 230, 97, 238];
}

const ANCHOR_EVENT_PREFIX_LEN: usize = 8;
const EVENT_DISCRIMINATOR_LEN: usize = 8;

/// PumpFun instructions (updated)
#[derive(Debug, Clone, PartialEq)]
pub enum PumpFunInstruction {
    Buy {
        // args
        amount: u64,
        max_sol_cost: u64,
        track_volume: bool,
        // accounts (IDL order)
        global: Pubkey,
        fee_recipient: Pubkey,
        mint: Pubkey,
        bonding_curve: Pubkey,
        associated_bonding_curve: Pubkey,
        associated_user: Pubkey,
        user: Pubkey,
        system_program: Pubkey,
        token_program: Pubkey,
        creator_vault: Pubkey,
        event_authority: Pubkey,
        program: Pubkey,
        global_volume_accumulator: Pubkey,
        user_volume_accumulator: Pubkey,
        fee_config: Pubkey,
        fee_program: Pubkey,
    },
    BuyExactSolIn {
        // args
        spendable_sol_in: u64,
        min_tokens_out: u64,
        track_volume: bool,
        // accounts (IDL order)
        global: Pubkey,
        fee_recipient: Pubkey,
        mint: Pubkey,
        bonding_curve: Pubkey,
        associated_bonding_curve: Pubkey,
        associated_user: Pubkey,
        user: Pubkey,
        system_program: Pubkey,
        token_program: Pubkey,
        creator_vault: Pubkey,
        event_authority: Pubkey,
        program: Pubkey,
        global_volume_accumulator: Pubkey,
        user_volume_accumulator: Pubkey,
        fee_config: Pubkey,
        fee_program: Pubkey,
    },
    Sell {
        // args
        amount: u64,
        min_sol_output: u64,
        // accounts (IDL order)
        global: Pubkey,
        fee_recipient: Pubkey,
        mint: Pubkey,
        bonding_curve: Pubkey,
        associated_bonding_curve: Pubkey,
        associated_user: Pubkey,
        user: Pubkey,
        system_program: Pubkey,
        creator_vault: Pubkey,
        token_program: Pubkey,
        event_authority: Pubkey,
        program: Pubkey,
        fee_config: Pubkey,
        fee_program: Pubkey,
    },
}

/// PumpFun events (updated)
#[derive(Debug, Clone, PartialEq)]
pub enum PumpFunEvent {
    TradeEvent {
        mint: Pubkey,
        sol_amount: u64,
        token_amount: u64,
        is_buy: bool,
        user: Pubkey,
        timestamp: i64,
        virtual_sol_reserves: u64,
        virtual_token_reserves: u64,
        real_sol_reserves: u64,
        real_token_reserves: u64,
        fee_recipient: Pubkey,
        fee_basis_points: u64,
        fee: u64,
        creator: Pubkey,
        creator_fee_basis_points: u64,
        creator_fee: u64,
        // New fields
        track_volume: bool,
        total_unclaimed_tokens: u64,
        total_claimed_tokens: u64,
        current_sol_volume: u64,
        last_update_timestamp: i64,
        ix_name: String,
        // Context metadata to match back to the originating instruction
        context_instruction_index: usize,
        context_position: usize,
        context_parent_position: usize,
    },
}

/// Borsh-serializable structs for instruction data
#[derive(BorshSerialize, BorshDeserialize, Debug)]
struct BuyArgs {
    amount: u64,
    max_sol_cost: u64,
    track_volume: OptionBool,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
struct BuyExactSolInArgs {
    spendable_sol_in: u64,
    min_tokens_out: u64,
    track_volume: OptionBool,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
struct SellArgs {
    amount: u64,
    min_sol_output: u64,
}

#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, Copy)]
struct OptionBool(pub bool);

impl From<OptionBool> for bool {
    fn from(value: OptionBool) -> Self {
        value.0
    }
}

/// Borsh-serializable structs for event data
#[derive(BorshSerialize, BorshDeserialize, Debug)]
struct TradeEventData {
    mint: Pubkey,
    sol_amount: u64,
    token_amount: u64,
    is_buy: bool,
    user: Pubkey,
    timestamp: i64,
    virtual_sol_reserves: u64,
    virtual_token_reserves: u64,
    real_sol_reserves: u64,
    real_token_reserves: u64,
    fee_recipient: Pubkey,
    fee_basis_points: u64,
    fee: u64,
    creator: Pubkey,
    creator_fee_basis_points: u64,
    creator_fee: u64,
    // New fields
    track_volume: bool,
    total_unclaimed_tokens: u64,
    total_claimed_tokens: u64,
    current_sol_volume: u64,
    last_update_timestamp: i64,
    ix_name: String,
}

/// Main Implementation
#[derive(Debug)]
pub struct PumpFunParser;

impl PumpFunParser {
    pub fn new() -> Self {
        Self
    }

    /// Parse buy instruction
    fn parse_buy(
        &self,
        instruction: &CompiledInstruction,
        account_keys: &[Pubkey],
    ) -> ParserResult<PumpFunInstruction> {
        // Deserialize instruction data
        let (amount, max_sol_cost, track_volume) = Self::decode_buy_args(&instruction.data[8..])?;

        // Extract accounts according to IDL (complete list)
        let global = get_account_at_index(instruction, account_keys, 0)?;
        let fee_recipient = get_account_at_index(instruction, account_keys, 1)?;
        let mint = get_account_at_index(instruction, account_keys, 2)?;
        let bonding_curve = get_account_at_index(instruction, account_keys, 3)?;
        let associated_bonding_curve = get_account_at_index(instruction, account_keys, 4)?;
        let associated_user = get_account_at_index(instruction, account_keys, 5)?;
        let user = get_account_at_index(instruction, account_keys, 6)?;
        let system_program = get_account_at_index(instruction, account_keys, 7)?;
        let token_program = get_account_at_index(instruction, account_keys, 8)?;
        let creator_vault = get_account_at_index(instruction, account_keys, 9)?;
        let event_authority = get_account_at_index(instruction, account_keys, 10)?;
        let program = get_account_at_index(instruction, account_keys, 11)?;
        let global_volume_accumulator = get_account_at_index(instruction, account_keys, 12)?;
        let user_volume_accumulator = get_account_at_index(instruction, account_keys, 13)?;
        let fee_config = get_account_at_index(instruction, account_keys, 14)?;
        let fee_program = get_account_at_index(instruction, account_keys, 15)?;

        Ok(PumpFunInstruction::Buy {
            // args
            amount,
            max_sol_cost,
            track_volume,
            // accounts
            global,
            fee_recipient,
            mint,
            bonding_curve,
            associated_bonding_curve,
            associated_user,
            user,
            system_program,
            token_program,
            creator_vault,
            event_authority,
            program,
            global_volume_accumulator,
            user_volume_accumulator,
            fee_config,
            fee_program,
        })
    }

    /// Parse buy_exact_sol_in instruction
    fn parse_buy_exact_sol_in(
        &self,
        instruction: &CompiledInstruction,
        account_keys: &[Pubkey],
    ) -> ParserResult<PumpFunInstruction> {
        let (spendable_sol_in, min_tokens_out, track_volume) =
            Self::decode_buy_exact_sol_in_args(&instruction.data[8..])?;

        let global = get_account_at_index(instruction, account_keys, 0)?;
        let fee_recipient = get_account_at_index(instruction, account_keys, 1)?;
        let mint = get_account_at_index(instruction, account_keys, 2)?;
        let bonding_curve = get_account_at_index(instruction, account_keys, 3)?;
        let associated_bonding_curve = get_account_at_index(instruction, account_keys, 4)?;
        let associated_user = get_account_at_index(instruction, account_keys, 5)?;
        let user = get_account_at_index(instruction, account_keys, 6)?;
        let system_program = get_account_at_index(instruction, account_keys, 7)?;
        let token_program = get_account_at_index(instruction, account_keys, 8)?;
        let creator_vault = get_account_at_index(instruction, account_keys, 9)?;
        let event_authority = get_account_at_index(instruction, account_keys, 10)?;
        let program = get_account_at_index(instruction, account_keys, 11)?;
        let global_volume_accumulator = get_account_at_index(instruction, account_keys, 12)?;
        let user_volume_accumulator = get_account_at_index(instruction, account_keys, 13)?;
        let fee_config = get_account_at_index(instruction, account_keys, 14)?;
        let fee_program = get_account_at_index(instruction, account_keys, 15)?;

        Ok(PumpFunInstruction::BuyExactSolIn {
            spendable_sol_in,
            min_tokens_out,
            track_volume,
            global,
            fee_recipient,
            mint,
            bonding_curve,
            associated_bonding_curve,
            associated_user,
            user,
            system_program,
            token_program,
            creator_vault,
            event_authority,
            program,
            global_volume_accumulator,
            user_volume_accumulator,
            fee_config,
            fee_program,
        })
    }

    /// Parse sell instruction
    fn parse_sell(
        &self,
        instruction: &CompiledInstruction,
        account_keys: &[Pubkey],
    ) -> ParserResult<PumpFunInstruction> {
        // Deserialize instruction data
        let (amount, min_sol_output) = Self::decode_sell_args(&instruction.data[8..])?;

        // Extract accounts according to IDL (complete list)
        let global = get_account_at_index(instruction, account_keys, 0)?;
        let fee_recipient = get_account_at_index(instruction, account_keys, 1)?;
        let mint = get_account_at_index(instruction, account_keys, 2)?;
        let bonding_curve = get_account_at_index(instruction, account_keys, 3)?;
        let associated_bonding_curve = get_account_at_index(instruction, account_keys, 4)?;
        let associated_user = get_account_at_index(instruction, account_keys, 5)?;
        let user = get_account_at_index(instruction, account_keys, 6)?;
        let system_program = get_account_at_index(instruction, account_keys, 7)?;
        let creator_vault = get_account_at_index(instruction, account_keys, 8)?;
        let token_program = get_account_at_index(instruction, account_keys, 9)?;
        let event_authority = get_account_at_index(instruction, account_keys, 10)?;
        let program = get_account_at_index(instruction, account_keys, 11)?;
        let fee_config = get_account_at_index(instruction, account_keys, 12)?;
        let fee_program = get_account_at_index(instruction, account_keys, 13)?;

        Ok(PumpFunInstruction::Sell {
            // args
            amount,
            min_sol_output,
            // accounts
            global,
            fee_recipient,
            mint,
            bonding_curve,
            associated_bonding_curve,
            associated_user,
            user,
            system_program,
            creator_vault,
            token_program,
            event_authority,
            program,
            fee_config,
            fee_program,
        })
    }

    fn decode_buy_args(data: &[u8]) -> ParserResult<(u64, u64, bool)> {
        if data.len() < 16 {
            return Err(ParserError::InvalidInstruction(
                "PumpFun buy args too short".to_string(),
            ));
        }
        let amount = u64::from_le_bytes(
            data[0..8]
                .try_into()
                .map_err(|_| ParserError::InvalidInstruction("Invalid buy args".to_string()))?,
        );
        let max_sol_cost = u64::from_le_bytes(
            data[8..16]
                .try_into()
                .map_err(|_| ParserError::InvalidInstruction("Invalid buy args".to_string()))?,
        );
        if data.len() == 16 {
            return Ok((amount, max_sol_cost, false));
        }
        let args = BuyArgs::try_from_slice(data)
            .map_err(|e| ParserError::DeserializationError(e.to_string()))?;
        Ok((args.amount, args.max_sol_cost, args.track_volume.into()))
    }

    fn decode_buy_exact_sol_in_args(data: &[u8]) -> ParserResult<(u64, u64, bool)> {
        if data.len() < 16 {
            return Err(ParserError::InvalidInstruction(
                "PumpFun buy_exact_sol_in args too short".to_string(),
            ));
        }
        let spendable_sol_in = u64::from_le_bytes(data[0..8].try_into().map_err(|_| {
            ParserError::InvalidInstruction("Invalid buy_exact_sol_in args".to_string())
        })?);
        let min_tokens_out = u64::from_le_bytes(data[8..16].try_into().map_err(|_| {
            ParserError::InvalidInstruction("Invalid buy_exact_sol_in args".to_string())
        })?);
        if data.len() == 16 {
            return Ok((spendable_sol_in, min_tokens_out, false));
        }
        let args = BuyExactSolInArgs::try_from_slice(data)
            .map_err(|e| ParserError::DeserializationError(e.to_string()))?;
        Ok((
            args.spendable_sol_in,
            args.min_tokens_out,
            args.track_volume.into(),
        ))
    }

    fn decode_sell_args(data: &[u8]) -> ParserResult<(u64, u64)> {
        if data.len() < 16 {
            return Err(ParserError::InvalidInstruction(
                "PumpFun sell args too short".to_string(),
            ));
        }
        let amount = u64::from_le_bytes(
            data[0..8]
                .try_into()
                .map_err(|_| ParserError::InvalidInstruction("Invalid sell args".to_string()))?,
        );
        let min_sol_output = u64::from_le_bytes(
            data[8..16]
                .try_into()
                .map_err(|_| ParserError::InvalidInstruction("Invalid sell args".to_string()))?,
        );
        if data.len() == 16 {
            return Ok((amount, min_sol_output));
        }
        let args = SellArgs::try_from_slice(data)
            .map_err(|e| ParserError::DeserializationError(e.to_string()))?;
        Ok((args.amount, args.min_sol_output))
    }

    /// Parse event from instruction data (only TradeEvent supported)
    fn parse_event_from_instruction(
        &self,
        ctx_ix: &InstructionWithContext,
    ) -> Option<PumpFunEvent> {
        let instruction = &ctx_ix.instruction;
        if instruction.data.len() < ANCHOR_EVENT_PREFIX_LEN + EVENT_DISCRIMINATOR_LEN {
            return None;
        }
        let discriminator_start = ANCHOR_EVENT_PREFIX_LEN;
        let discriminator_end = discriminator_start + EVENT_DISCRIMINATOR_LEN;
        let discriminator: [u8; EVENT_DISCRIMINATOR_LEN] = instruction.data
            [discriminator_start..discriminator_end]
            .try_into()
            .ok()?;
        match discriminator {
            event_discriminators::TRADE_EVENT => {
                let event_data =
                    TradeEventData::try_from_slice(&instruction.data[discriminator_end..]).ok()?;
                Some(PumpFunEvent::TradeEvent {
                    mint: event_data.mint,
                    sol_amount: event_data.sol_amount,
                    token_amount: event_data.token_amount,
                    is_buy: event_data.is_buy,
                    user: event_data.user,
                    timestamp: event_data.timestamp,
                    virtual_sol_reserves: event_data.virtual_sol_reserves,
                    virtual_token_reserves: event_data.virtual_token_reserves,
                    real_sol_reserves: event_data.real_sol_reserves,
                    real_token_reserves: event_data.real_token_reserves,
                    fee_recipient: event_data.fee_recipient,
                    fee_basis_points: event_data.fee_basis_points,
                    fee: event_data.fee,
                    creator: event_data.creator,
                    creator_fee_basis_points: event_data.creator_fee_basis_points,
                    creator_fee: event_data.creator_fee,
                    track_volume: event_data.track_volume,
                    total_unclaimed_tokens: event_data.total_unclaimed_tokens,
                    total_claimed_tokens: event_data.total_claimed_tokens,
                    current_sol_volume: event_data.current_sol_volume,
                    last_update_timestamp: event_data.last_update_timestamp,
                    ix_name: event_data.ix_name,
                    context_instruction_index: ctx_ix.instruction_index,
                    context_position: ctx_ix.stack_depth,
                    context_parent_position: ctx_ix.stack_depth.saturating_sub(1),
                })
            }
            _ => None,
        }
    }

    /// Parse events from instructions (PumpFun emits events as CPI instructions)
    fn parse_events_from_instructions(&self, context: &EventParsingContext) -> Vec<PumpFunEvent> {
        let mut events = Vec::new();
        let mut latest_parent_per_depth: Vec<Option<(usize, usize)>> = Vec::new();

        for instruction_ctx in context.instructions.iter() {
            if instruction_ctx.program_id != PUMP_FUN_PROGRAM_ID {
                continue;
            }

            if Self::is_trade_instruction(&instruction_ctx.instruction.data) {
                Self::record_parent_instruction(&mut latest_parent_per_depth, instruction_ctx);
                continue;
            }

            if let Some(mut event) = self.parse_event_from_instruction(instruction_ctx) {
                match &mut event {
                    PumpFunEvent::TradeEvent {
                        context_instruction_index,
                        context_position,
                        context_parent_position,
                        ..
                    } => {
                        if let Some((parent_idx, parent_depth)) = Self::find_latest_parent(
                            &latest_parent_per_depth,
                            instruction_ctx.stack_depth,
                        ) {
                            *context_instruction_index = parent_idx;
                            *context_position = parent_depth;
                            *context_parent_position = parent_depth;
                        }
                    }
                }
                events.push(event);
            }
        }

        events
    }

    fn is_trade_instruction(data: &[u8]) -> bool {
        if let Ok(discriminator) = get_anchor_discriminator(data) {
            discriminator == discriminators::BUY
                || discriminator == discriminators::BUY_EXACT_SOL_IN
                || discriminator == discriminators::SELL
        } else {
            false
        }
    }

    fn record_parent_instruction(
        latest: &mut Vec<Option<(usize, usize)>>,
        ctx: &InstructionWithContext,
    ) {
        if latest.len() <= ctx.stack_depth {
            latest.resize(ctx.stack_depth + 1, None);
        }
        latest[ctx.stack_depth] = Some((ctx.instruction_index, ctx.stack_depth));
    }

    fn find_latest_parent(
        latest: &[Option<(usize, usize)>],
        event_depth: usize,
    ) -> Option<(usize, usize)> {
        if latest.is_empty() {
            return None;
        }

        let mut depth = event_depth.min(latest.len() - 1);
        loop {
            if let Some(entry) = latest.get(depth).and_then(|opt| *opt) {
                return Some(entry);
            }
            if depth == 0 {
                break;
            }
            depth -= 1;
        }

        None
    }
}

impl ProgramParser for PumpFunParser {
    fn parse_instruction(
        &self,
        instruction: &CompiledInstruction,
        account_keys: &[Pubkey],
    ) -> ParserResult<ParsedInstruction> {
        let discriminator = get_anchor_discriminator(&instruction.data)?;
        let pump_fun_instruction = match discriminator {
            discriminators::BUY => self.parse_buy(instruction, account_keys)?,
            discriminators::BUY_EXACT_SOL_IN => {
                self.parse_buy_exact_sol_in(instruction, account_keys)?
            }
            discriminators::SELL => self.parse_sell(instruction, account_keys)?,
            _ => {
                return Ok(ParsedInstruction::Unknown {
                    program_id: PUMP_FUN_PROGRAM_ID,
                    data: instruction.data.clone(),
                });
            }
        };
        Ok(ParsedInstruction::PumpFun(pump_fun_instruction))
    }

    fn parse_events(&self, _logs: &[String]) -> ParserResult<Vec<ParsedEvent>> {
        Ok(Vec::new())
    }

    fn parse_events_with_context(
        &self,
        context: &EventParsingContext,
        _account_keys: &[Pubkey],
    ) -> ParserResult<Vec<ParsedEvent>> {
        let pump_fun_events = self.parse_events_from_instructions(context);
        let parsed_events: Vec<ParsedEvent> = pump_fun_events
            .into_iter()
            .map(ParsedEvent::PumpFun)
            .collect();
        Ok(parsed_events)
    }

    fn program_id(&self) -> Pubkey {
        PUMP_FUN_PROGRAM_ID
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use borsh::to_vec;
    use rand::{rngs::StdRng, RngCore, SeedableRng};

    #[test]
    fn test_pump_fun_parser_creation() {
        let parser = PumpFunParser::new();
        assert_eq!(parser.program_id(), PUMP_FUN_PROGRAM_ID);
    }

    #[test]
    fn test_decode_buy_args_legacy_and_modern() {
        let legacy = {
            let mut data = Vec::new();
            data.extend_from_slice(&[102, 6, 61, 18, 1, 218, 235, 234]);
            data.extend_from_slice(&123u64.to_le_bytes());
            data.extend_from_slice(&456u64.to_le_bytes());
            data
        };
        let modern_payload = to_vec(&BuyArgs {
            amount: 321,
            max_sol_cost: 654,
            track_volume: OptionBool(true),
        })
        .unwrap();
        let mut modern = discriminators::BUY.to_vec();
        modern.extend_from_slice(&modern_payload);

        let (legacy_amount, legacy_cost, legacy_track) =
            PumpFunParser::decode_buy_args(&legacy[8..]).expect("legacy");
        assert_eq!(legacy_amount, 123);
        assert_eq!(legacy_cost, 456);
        assert!(!legacy_track);

        let (modern_amount, modern_cost, modern_track) =
            PumpFunParser::decode_buy_args(&modern[8..]).expect("modern");
        assert_eq!(modern_amount, 321);
        assert_eq!(modern_cost, 654);
        assert!(modern_track);
    }

    #[test]
    fn test_decode_buy_exact_sol_in_args_legacy_and_modern() {
        let legacy = {
            let mut data = Vec::new();
            data.extend_from_slice(&[56, 252, 116, 8, 158, 223, 205, 95]);
            data.extend_from_slice(&777u64.to_le_bytes());
            data.extend_from_slice(&888u64.to_le_bytes());
            data
        };
        let modern_payload = to_vec(&BuyExactSolInArgs {
            spendable_sol_in: 1000,
            min_tokens_out: 2000,
            track_volume: OptionBool(true),
        })
        .unwrap();
        let mut modern = discriminators::BUY_EXACT_SOL_IN.to_vec();
        modern.extend_from_slice(&modern_payload);

        let (legacy_spend, legacy_min, legacy_track) =
            PumpFunParser::decode_buy_exact_sol_in_args(&legacy[8..]).expect("legacy");
        assert_eq!(legacy_spend, 777);
        assert_eq!(legacy_min, 888);
        assert!(!legacy_track);

        let (modern_spend, modern_min, modern_track) =
            PumpFunParser::decode_buy_exact_sol_in_args(&modern[8..]).expect("modern");
        assert_eq!(modern_spend, 1000);
        assert_eq!(modern_min, 2000);
        assert!(modern_track);
    }

    #[test]
    fn test_decode_sell_args_legacy_and_modern() {
        let legacy = {
            let mut data = Vec::new();
            data.extend_from_slice(&[51, 230, 133, 164, 1, 127, 131, 173]);
            data.extend_from_slice(&4444u64.to_le_bytes());
            data.extend_from_slice(&5555u64.to_le_bytes());
            data
        };
        let modern_payload = to_vec(&SellArgs {
            amount: 7777,
            min_sol_output: 8888,
        })
        .unwrap();
        let mut modern = discriminators::SELL.to_vec();
        modern.extend_from_slice(&modern_payload);

        let (legacy_amount, legacy_min) =
            PumpFunParser::decode_sell_args(&legacy[8..]).expect("legacy");
        assert_eq!(legacy_amount, 4444);
        assert_eq!(legacy_min, 5555);

        let (modern_amount, modern_min) =
            PumpFunParser::decode_sell_args(&modern[8..]).expect("modern");
        assert_eq!(modern_amount, 7777);
        assert_eq!(modern_min, 8888);
    }
}
</file>

<file path="swap/common.rs">
/// Calculate transaction fee based on amount and fee basis points
///
/// # Parameters
/// * `amount` - Transaction amount
/// * `fee_basis_points` - Fee basis points, 1 basis point = 0.01%
///
/// # Examples
/// * fee_basis_points = 1   -> 0.01% fee
/// * fee_basis_points = 10  -> 0.1% fee
/// * fee_basis_points = 25  -> 0.25% fee (common exchange rate)
/// * fee_basis_points = 100 -> 1% fee
pub fn compute_fee(amount: u128, fee_basis_points: u128) -> u128 {
    ceil_div(amount * fee_basis_points, 10_000)
}

/// Ceiling division implementation
/// Ceiling division that ensures results are not lost due to integer division precision
///
/// # Parameters
/// * `a` - Dividend
/// * `b` - Divisor
///
/// # Returns
/// Returns the ceiling result of a/b
pub fn ceil_div(a: u128, b: u128) -> u128 {
    (a + b - 1) / b
}

/// Calculate buy amount with slippage protection
/// Add slippage percentage to the amount to ensure successful purchase
///
/// # Parameters
/// * `amount` - Original transaction amount
/// * `basis_points` - Slippage basis points, 1 basis point = 0.01%
///
/// # Examples
/// * basis_points = 1   -> 0.01% slippage
/// * basis_points = 10  -> 0.1% slippage  
/// * basis_points = 100 -> 1% slippage
/// * basis_points = 500 -> 5% slippage
pub fn calculate_with_slippage_buy(amount: u64, basis_points: u64) -> u64 {
    amount + (amount * basis_points / 10000)
}

/// Calculate sell amount with slippage protection
/// Subtract slippage percentage from the amount to ensure successful sale
///
/// # Parameters
/// * `amount` - Original transaction amount
/// * `basis_points` - Slippage basis points, 1 basis point = 0.01%
///
/// # Examples
/// * basis_points = 1   -> 0.01% slippage
/// * basis_points = 10  -> 0.1% slippage  
/// * basis_points = 100 -> 1% slippage
/// * basis_points = 500 -> 5% slippage
pub fn calculate_with_slippage_sell(amount: u64, basis_points: u64) -> u64 {
    if amount <= basis_points / 10000 {
        1
    } else {
        amount - (amount * basis_points / 10000)
    }
}

/// Convert a decimal SOL string (e.g. "0.01") into lamports.
///
/// Returns None for invalid inputs, negative values, more than 9 fractional digits,
/// or on overflow.
///
/// Behavior mirrors the historical sol_str_to_lamports from solana_sdk:
/// - Up to 9 fractional digits are supported (1 SOL = 1_000_000_000 lamports).
/// - Fractional part is right-padded with zeros to 9 digits.
/// - Strings like ".5" are treated as 0.5; "1." is treated as 1.0.
pub fn sol_str_to_lamports(s: &str) -> Option<u64> {
    const LAMPORTS_PER_SOL: u64 = 1_000_000_000;

    let mut s = s.trim();
    if s.is_empty() {
        return None;
    }

    // Reject negatives; support optional leading "+"
    if s.starts_with('-') {
        return None;
    }
    if s.starts_with('+') {
        s = &s[1..];
        if s.is_empty() {
            return None;
        }
    }

    let parts: Vec<&str> = s.split('.').collect();
    if parts.len() > 2 {
        return None;
    }

    // Parse whole part (allow empty -> 0 to support strings like ".5")
    let whole_str = parts.get(0).copied().unwrap_or("");
    let whole: u64 = if whole_str.is_empty() {
        0
    } else {
        whole_str.parse().ok()?
    };

    // Parse fractional part, right-pad to 9 digits, reject >9 digits
    let frac_str = parts.get(1).copied().unwrap_or("");
    if frac_str.len() > 9 {
        return None;
    }
    let frac_padded = format!("{:0<9}", frac_str);
    let frac: u64 = if frac_str.is_empty() {
        0
    } else {
        frac_padded.parse().ok()?
    };

    let whole_lamports = whole.checked_mul(LAMPORTS_PER_SOL)?;
    whole_lamports.checked_add(frac)
}

pub fn priority_fees_per_cu_microlamports(priority_fees: f64, cu_limit: u32) -> u64 {
    if priority_fees <= 0.0 || cu_limit == 0 {
        return 0;
    }
    // 1 SOL = 1_000_000_000 lamports; 1 lamport = 1_000_000 microlamports => 1e15 microlamports per SOL
    let micro_total = priority_fees * 1_000_000_000_000_000.0; // 1e15
    let per_cu = micro_total / (cu_limit as f64);
    per_cu.max(0.0).min(u64::MAX as f64) as u64
}

/// Convert buy_amount from SOL to lamports
pub fn buy_amount_lamports(buy_amount: f64) -> u64 {
    let lamports = buy_amount * 1_000_000_000.0;
    lamports.max(0.0).min(u64::MAX as f64) as u64
}

const SOL_DECIMALS: u64 = 1_000_000_000;
const TOKEN_DECIMALS: u64 = 1_000_000;

pub fn compute_pump_fun_price(
    virtual_sol_reserves: u64,
    virtual_token_reserves: u64,
) -> Option<f64> {
    if virtual_token_reserves == 0 {
        return None;
    }

    // Convert to f64 BEFORE dividing by decimals
    let v_sol_reserve = virtual_sol_reserves as f64 / SOL_DECIMALS as f64;
    let v_token_reserve = virtual_token_reserves as f64 / TOKEN_DECIMALS as f64;

    Some(v_sol_reserve / v_token_reserve)
}

pub fn compute_pump_amm_price(pool_base_reserve: u128, pool_quote_reserve: u128) -> f64 {
    if pool_base_reserve == 0 {
        return 0.0;
    }
    let scale = 10f64.powi(6 as i32); // 10^d
    (pool_quote_reserve as f64 * scale) / (pool_base_reserve as f64 * 1_000_000_000f64)
}
</file>

<file path="swap/constants.rs">
use super::common::{
    calculate_with_slippage_buy, calculate_with_slippage_sell, ceil_div, compute_fee,
    sol_str_to_lamports,
};

use solana_sdk::pubkey;
use solana_sdk::pubkey::Pubkey;

pub const LOADED_ACCOUNTS_DATA_LIMIT: u32 = 256_000;

// Pump Fun has Constant Fees
pub const FEE_BASIS_POINTS: u64 = 125;

// Pump AMM Functions

/// Result for buying base tokens with quote amount input
#[derive(Clone, Debug)]
pub struct BuyQuoteInputResult {
    /// Amount of base tokens received
    pub base: u64,
    /// Effective quote amount after fee deduction
    pub internal_quote_without_fees: u64,
    /// Maximum quote amount with slippage protection
    pub max_quote: u64,
}

/// Result for selling base tokens with base amount input
#[derive(Clone, Debug)]
pub struct SellBaseInputResult {
    /// Final quote amount received after fees
    pub ui_quote: u64,
    /// Minimum quote amount with slippage protection
    pub min_quote: u64,
    /// Raw quote amount before fee deduction
    pub internal_quote_amount_out: u64,
}

#[derive(Clone, Copy, Debug)]
pub struct Fees {
    pub lp_fee_bps: u16,
    pub protocol_fee_bps: u16,
    pub coin_creator_fee_bps: u16,
}

/// Calculate base tokens received for a specific quote amount
///
/// # Arguments
/// * `quote` - Amount of quote tokens to spend
/// * `slippage_basis_points` - Slippage tolerance in basis points (100 = 1%)
/// * `base_reserve` - Base token reserves in the pool
/// * `quote_reserve` - Quote token reserves in the pool
/// * `coin_creator` - Token creator address
///
/// # Returns
/// * `BuyQuoteInputResult` containing base amount and slippage calculations
pub fn buy_quote_input_internal(
    quote: u64,
    slippage_basis_points: u64,
    base_reserve: u64,
    quote_reserve: u64,
    fees: Fees,
) -> Result<BuyQuoteInputResult, String> {
    if base_reserve == 0 || quote_reserve == 0 {
        return Err("Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero.".to_string());
    }

    // Calculate total fee basis points
    let total_fee_bps = fees.lp_fee_bps + fees.protocol_fee_bps + fees.coin_creator_fee_bps;

    let denominator = 10_000 + total_fee_bps;

    // Calculate effective quote amount after fees
    let effective_quote = (quote as u128 * 10_000) / denominator as u128;

    // Calculate base amount out using constant product formula
    let numerator = (base_reserve as u128) * effective_quote;
    let denominator_effective = (quote_reserve as u128) + effective_quote;

    if denominator_effective == 0 {
        return Err("Pool would be depleted; denominator is zero.".to_string());
    }

    let base_amount_out = (numerator / denominator_effective) as u64;

    // Calculate max quote with slippage
    let max_quote = calculate_with_slippage_buy(quote, slippage_basis_points);

    Ok(BuyQuoteInputResult {
        base: base_amount_out,
        internal_quote_without_fees: effective_quote as u64,
        max_quote,
    })
}

/// Calculate quote tokens received for selling a specific amount of base tokens
///
/// # Arguments
/// * `base` - Amount of base tokens to sell
/// * `slippage_basis_points` - Slippage tolerance in basis points (100 = 1%)
/// * `base_reserve` - Base token reserves in the pool
/// * `quote_reserve` - Quote token reserves in the pool
/// * `coin_creator` - Token creator address
///
/// # Returns
/// * `SellBaseInputResult` containing quote amounts and slippage calculations
pub fn sell_base_input_internal(
    base: u64,
    slippage_basis_points: u64,
    base_reserve: u64,
    quote_reserve: u64,
    fees: Fees,
) -> Result<SellBaseInputResult, String> {
    if base_reserve == 0 || quote_reserve == 0 {
        return Err("Invalid input: 'baseReserve' or 'quoteReserve' cannot be zero.".to_string());
    }

    // Calculate quote amount out using constant product formula
    let quote_amount_out = ((quote_reserve as u128) * (base as u128)
        / ((base_reserve as u128) + (base as u128))) as u64;

    // Calculate fees
    let lp_fee = compute_fee(quote_amount_out as u128, fees.lp_fee_bps as u128) as u64;
    let protocol_fee = compute_fee(quote_amount_out as u128, fees.protocol_fee_bps as u128) as u64;
    let coin_creator_fee =
        compute_fee(quote_amount_out as u128, fees.coin_creator_fee_bps as u128) as u64;

    // Calculate final quote after fees
    let total_fees = lp_fee + protocol_fee + coin_creator_fee;
    if total_fees > quote_amount_out {
        return Err("Fees exceed total output; final quote is negative.".to_string());
    }
    let final_quote = quote_amount_out - total_fees;

    // Calculate min quote with slippage
    let min_quote = calculate_with_slippage_sell(final_quote, slippage_basis_points);

    Ok(SellBaseInputResult {
        ui_quote: final_quote,
        min_quote,
        internal_quote_amount_out: quote_amount_out,
    })
}

// Pump Fun Functions

/// Calculates the amount of tokens that can be purchased with a given SOL amount
/// using the bonding curve formula.
///
/// # Arguments
/// * `virtual_token_reserves` - Virtual token reserves in the bonding curve
/// * `virtual_sol_reserves` - Virtual SOL reserves in the bonding curve
/// * `real_token_reserves` - Actual token reserves available for purchase
/// * `amount` - SOL amount to spend (in lamports)
///
/// # Returns
/// The amount of tokens that will be received (in token's smallest unit)
pub fn get_buy_token_amount_from_sol_amount(
    virtual_token_reserves: u128,
    virtual_sol_reserves: u128,
    real_token_reserves: u128,
    amount: u64,
) -> u64 {
    if amount == 0 {
        return 0;
    }

    if virtual_token_reserves == 0 {
        return 0;
    }

    // Convert to u128 to prevent overflow
    let amount_128 = amount as u128;
    let total_fee_basis_points_128 = FEE_BASIS_POINTS as u128;

    let input_amount = amount_128
        .checked_mul(10_000)
        .unwrap()
        .checked_div(total_fee_basis_points_128 + 10_000)
        .unwrap();

    let denominator = virtual_sol_reserves + input_amount;

    let mut tokens_received = input_amount
        .checked_mul(virtual_token_reserves)
        .unwrap()
        .checked_div(denominator)
        .unwrap();

    tokens_received = tokens_received.min(real_token_reserves);

    if tokens_received <= 100 * 1_000_000_u128 {
        tokens_received = if amount > sol_str_to_lamports("0.01").unwrap_or(0) {
            25547619 * 1_000_000_u128
        } else {
            255476 * 1_000_000_u128
        };
    }

    tokens_received as u64
}

/// Calculates the amount of SOL that will be received when selling a given token amount
/// using the bonding curve formula with transaction fees deducted.
///
/// # Arguments
/// * `virtual_token_reserves` - Virtual token reserves in the bonding curve
/// * `virtual_sol_reserves` - Virtual SOL reserves in the bonding curve
/// * `creator` - Creator's public key (affects fee calculation)
/// * `amount` - Token amount to sell (in token's smallest unit)
///
/// # Returns
/// The amount of SOL that will be received after fees (in lamports)
pub fn get_sell_sol_amount_from_token_amount(
    virtual_token_reserves: u128,
    virtual_sol_reserves: u128,
    amount: u64,
) -> u64 {
    if amount == 0 {
        return 0;
    }

    // migrated bonding curve
    if virtual_token_reserves == 0 {
        return 0;
    }

    let amount_128 = amount as u128;

    // Calculate SOL amount received from selling tokens using constant product formula
    let numerator = amount_128.checked_mul(virtual_sol_reserves).unwrap_or(0);
    let denominator = virtual_token_reserves.checked_add(amount_128).unwrap_or(1);

    let sol_cost = numerator.checked_div(denominator).unwrap_or(0);

    let total_fee_basis_points_128 = FEE_BASIS_POINTS as u128;

    // Calculate transaction fee
    let fee = compute_fee(sol_cost, total_fee_basis_points_128);

    sol_cost.saturating_sub(fee) as u64
}

#[allow(dead_code)]
pub const HELIUS_TIP_ACCOUNTS: [Pubkey; 10] = [
    pubkey!("4ACfpUFoaSD9bfPdeu6DBt89gB6ENTeHBXCAi87NhDEE"),
    pubkey!("D2L6yPZ2FmmmTKPgzaMKdhu6EWZcTpLy1Vhx8uvZe7NZ"),
    pubkey!("9bnz4RShgq1hAnLnZbP8kbgBg1kEmcJBYQq3gQbmnSta"),
    pubkey!("5VY91ws6B2hMmBFRsXkoAAdsPHBJwRfBht4DXox3xkwn"),
    pubkey!("2nyhqdwKcJZR2vcqCyrYsaPVdAnFoJjiksCXJ7hfEYgD"),
    pubkey!("2q5pghRs6arqVjRvT5gfgWfWcHWmw1ZuCzphgd5KfWGJ"),
    pubkey!("wyvPkWjVZz1M8fHQnMMCDTQDbkManefNNhweYk5WkcF"),
    pubkey!("3KCKozbAaF75qEU33jtzozcJ29yJuaLJTy2jFdzUY8bT"),
    pubkey!("4vieeGHPYPG2MmyPRcYjdiDmmhN3ww7hsFNap8pVN3Ey"),
    pubkey!("4TQLFNWK8AovT1gFvda5jfw2oJeRMKEmw7aH6MGBJ3or"),
];

#[allow(dead_code)]
pub const ASTRALANE_TIP_ACCOUNTS: [Pubkey; 8] = [
    pubkey!("astrazznxsGUhWShqgNtAdfrzP2G83DzcWVJDxwV9bF"),
    pubkey!("astra4uejePWneqNaJKuFFA8oonqCE1sqF6b45kDMZm"),
    pubkey!("astra9xWY93QyfG6yM8zwsKsRodscjQ2uU2HKNL5prk"),
    pubkey!("astraRVUuTHjpwEVvNBeQEgwYx9w9CFyfxjYoobCZhL"),
    pubkey!("astraEJ2fEj8Xmy6KLG7B3VfbKfsHXhHrNdCQx7iGJK"),
    pubkey!("astraubkDw81n4LuutzSQ8uzHCv4BhPVhfvTcYv8SKC"),
    pubkey!("astraZW5GLFefxNPAatceHhYjfA1ciq9gvfEg2S47xk"),
    pubkey!("astrawVNP4xDBKT7rAdxrLYiTSTdqtUr63fSMduivXK"),
];

#[allow(dead_code)]
pub const BLOCKRAZOR_TIP_ACCOUNTS: [Pubkey; 14] = [
    pubkey!("FjmZZrFvhnqqb9ThCuMVnENaM3JGVuGWNyCAxRJcFpg9"),
    pubkey!("6No2i3aawzHsjtThw81iq1EXPJN6rh8eSJCLaYZfKDTG"),
    pubkey!("A9cWowVAiHe9pJfKAj3TJiN9VpbzMUq6E4kEvf5mUT22"),
    pubkey!("Gywj98ophM7GmkDdaWs4isqZnDdFCW7B46TXmKfvyqSm"),
    pubkey!("68Pwb4jS7eZATjDfhmTXgRJjCiZmw1L7Huy4HNpnxJ3o"),
    pubkey!("4ABhJh5rZPjv63RBJBuyWzBK3g9gWMUQdTZP2kiW31V9"),
    pubkey!("B2M4NG5eyZp5SBQrSdtemzk5TqVuaWGQnowGaCBt8GyM"),
    pubkey!("5jA59cXMKQqZAVdtopv8q3yyw9SYfiE3vUCbt7p8MfVf"),
    pubkey!("5YktoWygr1Bp9wiS1xtMtUki1PeYuuzuCF98tqwYxf61"),
    pubkey!("295Avbam4qGShBYK7E9H5Ldew4B3WyJGmgmXfiWdeeyV"),
    pubkey!("EDi4rSy2LZgKJX74mbLTFk4mxoTgT6F7HxxzG2HBAFyK"),
    pubkey!("BnGKHAC386n4Qmv9xtpBVbRaUTKixjBe3oagkPFKtoy6"),
    pubkey!("Dd7K2Fp7AtoN8xCghKDRmyqr5U169t48Tw5fEd3wT9mq"),
    pubkey!("AP6qExwrbRgBAVaehg4b5xHENX815sMabtBzUzVB4v8S"),
];

pub const STELLIUM_TIP_ACCOUNTS: [Pubkey; 5] = [
    pubkey!("ste11JV3MLMM7x7EJUM2sXcJC1H7F4jBLnP9a9PG8PH"),
    pubkey!("ste11MWPjXCRfQryCshzi86SGhuXjF4Lv6xMXD2AoSt"),
    pubkey!("ste11p5x8tJ53H1NbNQsRBg1YNRd4GcVpxtDw8PBpmb"),
    pubkey!("ste11p7e2KLYou5bwtt35H7BM6uMdo4pvioGjJXKFcN"),
    pubkey!("ste11TMV68LMi1BguM4RQujtbNCZvf1sjsASpqgAvSX"),
];

pub const FLASH_BLOCK_TIP_ACCOUNTS: [Pubkey; 10] = [
    pubkey!("FLaShB3iXXTWE1vu9wQsChUKq3HFtpMAhb8kAh1pf1wi"),
    pubkey!("FLashhsorBmM9dLpuq6qATawcpqk1Y2aqaZfkd48iT3W"),
    pubkey!("FLaSHJNm5dWYzEgnHJWWJP5ccu128Mu61NJLxUf7mUXU"),
    pubkey!("FLaSHR4Vv7sttd6TyDF4yR1bJyAxRwWKbohDytEMu3wL"),
    pubkey!("FLASHRzANfcAKDuQ3RXv9hbkBy4WVEKDzoAgxJ56DiE4"),
    pubkey!("FLasHstqx11M8W56zrSEqkCyhMCCpr6ze6Mjdvqope5s"),
    pubkey!("FLAShWTjcweNT4NSotpjpxAkwxUr2we3eXQGhpTVzRwy"),
    pubkey!("FLasHXTqrbNvpWFB6grN47HGZfK6pze9HLNTgbukfPSk"),
    pubkey!("FLAshyAyBcKb39KPxSzXcepiS8iDYUhDGwJcJDPX4g2B"),
    pubkey!("FLAsHZTRcf3Dy1APaz6j74ebdMC6Xx4g6i9YxjyrDybR"),
];

pub const ZERO_SLOT_TIP_ACCOUNTS: [Pubkey; 5] = [
    pubkey!("Eb2KpSC8uMt9GmzyAEm5Eb1AAAgTjRaXWFjKyFXHZxF3"),
    pubkey!("FCjUJZ1qozm1e8romw216qyfQMaaWKxWsuySnumVCCNe"),
    pubkey!("ENxTEjSQ1YabmUpXAdCgevnHQ9MHdLv8tzFiuiYJqa13"),
    pubkey!("6rYLG55Q9RpsPGvqdPNJs4z5WTxJVatMB8zV3WJhs5EK"),
    pubkey!("Cix2bHfqPcKcM233mzxbLk14kSggUUiz2A87fJtGivXr"),
];
</file>

<file path="swap/mod.rs">
pub mod common;
pub mod constants;
pub mod pump;
pub mod pump_amm;
</file>

<file path="swap/pump_amm.rs">
#![allow(dead_code)]

use borsh::{self, BorshDeserialize, BorshSerialize};
use solana_sdk::{
    compute_budget::ComputeBudgetInstruction,
    instruction::{AccountMeta, Instruction},
    pubkey,
    pubkey::Pubkey,
    system_instruction,
};
use spl_associated_token_account::{
    get_associated_token_address_with_program_id,
    instruction::create_associated_token_account_idempotent,
};
use spl_token::instruction::{close_account, sync_native};
use spl_token_2022::ID as TOKEN_2022_PROGRAM_ID;
use thiserror::Error;

use crate::swap::constants::{
    buy_quote_input_internal, sell_base_input_internal, Fees, LOADED_ACCOUNTS_DATA_LIMIT,
};

const PUMP_AMM_PROGRAM_ID: Pubkey = pubkey!("pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA");
const DEFAULT_CU_LIMIT: u32 = 200_000;
const BUY_QUOTE_BUFFER_LAMPORTS: u64 = 300_000;
const MEV_GUARD_ACCOUNT: Pubkey = pubkey!("jitodontfrontB1111111NahLeaveitDontMevMeBro");
const LEGACY_TOKEN_PROGRAM: Pubkey = spl_token::id();

/// Thin, allocation-aware builder for Pump AMM buy/sell instructions.
pub struct PumpAmmTransactionBuilder;

impl PumpAmmTransactionBuilder {
    pub fn buy_exact_quote_in(
        params: BuyExactQuoteInRequest<'_>,
    ) -> Result<Instruction, PumpAmmBuilderError> {
        ensure_program_id(params.accounts.program)?;

        let quote = params.spendable_quote_in;
        if quote == 0 {
            return Err(PumpAmmBuilderError::ZeroQuote);
        }

        let buy_result = buy_quote_input_internal(
            quote,
            0, // quote-side slippage handled via min_base_out
            params.base_reserve,
            params.quote_reserve,
            params.fees,
        )
        .map_err(PumpAmmBuilderError::Math)?;

        let expected_base = buy_result.base;
        if expected_base == 0 {
            return Err(PumpAmmBuilderError::ZeroBaseAfterMath);
        }

        let min_base_amount_out = apply_base_slippage(expected_base, params.slippage_bps).ok_or(
            PumpAmmBuilderError::SlippageTooLarge {
                slippage_bps: params.slippage_bps,
            },
        )?;

        let args = BuyExactQuoteInArgs {
            spendable_quote_in: quote,
            min_base_amount_out,
            track_volume: OptionBool(params.track_volume),
        };

        let mut data = Vec::with_capacity(8 + core::mem::size_of::<BuyExactQuoteInArgs>());
        data.extend_from_slice(&pump_amm_discriminators::BUY_EXACT_QUOTE_IN);
        data.extend(borsh::to_vec(&args)?);

        Ok(Instruction {
            program_id: PUMP_AMM_PROGRAM_ID,
            accounts: buy_exact_quote_in_metas(params.accounts),
            data,
        })
    }

    pub fn sell(params: SellRequest<'_>) -> Result<Instruction, PumpAmmBuilderError> {
        ensure_program_id(params.accounts.program)?;

        if params.base_amount_in == 0 {
            return Err(PumpAmmBuilderError::ZeroBaseInput);
        }

        let sell_result = sell_base_input_internal(
            params.base_amount_in,
            params.slippage_bps as u64,
            params.base_reserve,
            params.quote_reserve,
            params.fees,
        )
        .map_err(PumpAmmBuilderError::Math)?;

        if sell_result.ui_quote == 0 {
            return Err(PumpAmmBuilderError::ZeroQuoteAfterMath);
        }

        let args = SellArgs {
            base_amount_in: params.base_amount_in,
            min_quote_amount_out: sell_result.min_quote,
        };

        let mut data = Vec::with_capacity(8 + core::mem::size_of::<SellArgs>());
        data.extend_from_slice(&pump_amm_discriminators::SELL);
        data.extend(borsh::to_vec(&args)?);

        Ok(Instruction {
            program_id: PUMP_AMM_PROGRAM_ID,
            accounts: sell_metas(params.accounts),
            data,
        })
    }
}

/// Accounts required for `buy_exact_quote_in`.
#[derive(Clone, Debug)]
pub struct BuyExactQuoteInAccounts {
    pub pool: Pubkey,
    pub user: Pubkey,
    pub global_config: Pubkey,
    pub base_mint: Pubkey,
    pub quote_mint: Pubkey,
    pub user_base_token_account: Pubkey,
    pub user_quote_token_account: Pubkey,
    pub pool_base_token_account: Pubkey,
    pub pool_quote_token_account: Pubkey,
    pub protocol_fee_recipient: Pubkey,
    pub protocol_fee_recipient_token_account: Pubkey,
    pub base_token_program: Pubkey,
    pub quote_token_program: Pubkey,
    pub system_program: Pubkey,
    pub associated_token_program: Pubkey,
    pub event_authority: Pubkey,
    pub program: Pubkey,
    pub coin_creator_vault_ata: Pubkey,
    pub coin_creator_vault_authority: Pubkey,
    pub global_volume_accumulator: Pubkey,
    pub user_volume_accumulator: Pubkey,
    pub fee_config: Pubkey,
    pub fee_program: Pubkey,
}

/// Accounts required for `sell`.
#[derive(Clone, Debug)]
pub struct SellAccounts {
    pub pool: Pubkey,
    pub user: Pubkey,
    pub global_config: Pubkey,
    pub base_mint: Pubkey,
    pub quote_mint: Pubkey,
    pub user_base_token_account: Pubkey,
    pub user_quote_token_account: Pubkey,
    pub pool_base_token_account: Pubkey,
    pub pool_quote_token_account: Pubkey,
    pub protocol_fee_recipient: Pubkey,
    pub protocol_fee_recipient_token_account: Pubkey,
    pub base_token_program: Pubkey,
    pub quote_token_program: Pubkey,
    pub system_program: Pubkey,
    pub associated_token_program: Pubkey,
    pub event_authority: Pubkey,
    pub program: Pubkey,
    pub coin_creator_vault_ata: Pubkey,
    pub coin_creator_vault_authority: Pubkey,
    pub fee_config: Pubkey,
    pub fee_program: Pubkey,
}

#[derive(Clone, Debug)]
pub struct BuyExactQuoteInRequest<'a> {
    pub accounts: &'a BuyExactQuoteInAccounts,
    pub spendable_quote_in: u64,
    pub base_reserve: u64,
    pub quote_reserve: u64,
    pub fees: Fees,
    pub slippage_bps: u16,
    pub track_volume: bool,
}

#[derive(Clone, Debug)]
pub struct SellRequest<'a> {
    pub accounts: &'a SellAccounts,
    pub base_amount_in: u64,
    pub base_reserve: u64,
    pub quote_reserve: u64,
    pub fees: Fees,
    pub slippage_bps: u16,
}

#[derive(Debug, Error)]
pub enum PumpAmmBuilderError {
    #[error("slippage {slippage_bps} bps reduced base to zero")]
    SlippageTooLarge { slippage_bps: u16 },
    #[error("quote spend cannot be zero")]
    ZeroQuote,
    #[error("base amount after math is zero")]
    ZeroBaseAfterMath,
    #[error("base input cannot be zero")]
    ZeroBaseInput,
    #[error("quote output after math is zero")]
    ZeroQuoteAfterMath,
    #[error("math error: {0}")]
    Math(String),
    #[error("invalid Pump AMM program id {provided}")]
    InvalidProgramId { provided: Pubkey },
    #[error("token program mismatch, expected {expected}, provided {provided}")]
    TokenProgramMismatch { expected: Pubkey, provided: Pubkey },
    #[error("transaction user {provided} does not match expected payer {expected}")]
    UserMismatch { expected: Pubkey, provided: Pubkey },
    #[error("unsupported token program {provided}")]
    UnsupportedTokenProgram { provided: Pubkey },
    #[error("derived ATA {derived} does not match expected base account {expected}")]
    AssociatedBaseAccountMismatch { expected: Pubkey, derived: Pubkey },
    #[error("derived ATA {derived} does not match expected quote account {expected}")]
    AssociatedQuoteAccountMismatch { expected: Pubkey, derived: Pubkey },
    #[error("token instruction error: {0}")]
    TokenInstruction(String),
    #[error(transparent)]
    Serialization(#[from] std::io::Error),
}

mod pump_amm_discriminators {
    pub const BUY_EXACT_QUOTE_IN: [u8; 8] = [198, 46, 21, 82, 180, 217, 232, 112];
    pub const SELL: [u8; 8] = [51, 230, 133, 164, 1, 127, 131, 173];
}

#[derive(BorshSerialize, BorshDeserialize)]
struct BuyExactQuoteInArgs {
    spendable_quote_in: u64,
    min_base_amount_out: u64,
    track_volume: OptionBool,
}

#[derive(BorshSerialize, BorshDeserialize)]
struct SellArgs {
    base_amount_in: u64,
    min_quote_amount_out: u64,
}

#[derive(BorshSerialize, BorshDeserialize)]
struct OptionBool(pub bool);

fn advance_nonce_instruction(nonce_account: Pubkey, nonce_authority: Pubkey) -> Instruction {
    system_instruction::advance_nonce_account(&nonce_account, &nonce_authority)
}

fn compute_unit_limit_instruction(cu_limit: u32) -> Instruction {
    let mut ix = ComputeBudgetInstruction::set_compute_unit_limit(cu_limit);
    ix.accounts
        .push(AccountMeta::new_readonly(MEV_GUARD_ACCOUNT, false));
    ix
}

fn compute_unit_price_instruction(micro_lamports: u64) -> Instruction {
    ComputeBudgetInstruction::set_compute_unit_price(micro_lamports)
}

fn tip_transfer_instruction(payer: Pubkey, destination: Pubkey, lamports: u64) -> Instruction {
    system_instruction::transfer(&payer, &destination, lamports)
}

fn create_base_ata_instruction(
    payer: Pubkey,
    owner: Pubkey,
    mint: Pubkey,
    token_program: Pubkey,
) -> Instruction {
    create_associated_token_account_idempotent(&payer, &owner, &mint, &token_program)
}

fn create_wsol_ata_instruction(payer: Pubkey, owner: Pubkey, mint: Pubkey) -> Instruction {
    create_associated_token_account_idempotent(&payer, &owner, &mint, &LEGACY_TOKEN_PROGRAM)
}

fn transfer_sol_to_ata_instruction(payer: Pubkey, ata: Pubkey, lamports: u64) -> Instruction {
    system_instruction::transfer(&payer, &ata, lamports)
}

fn sync_native_instruction(account: Pubkey) -> Result<Instruction, PumpAmmBuilderError> {
    sync_native(&LEGACY_TOKEN_PROGRAM, &account)
        .map_err(|e| PumpAmmBuilderError::TokenInstruction(e.to_string()))
}

fn close_wsol_instruction(
    account: Pubkey,
    destination: Pubkey,
    authority: Pubkey,
) -> Result<Instruction, PumpAmmBuilderError> {
    close_account(
        &LEGACY_TOKEN_PROGRAM,
        &account,
        &destination,
        &authority,
        &[],
    )
    .map_err(|e| PumpAmmBuilderError::TokenInstruction(e.to_string()))
}

fn derive_ata(owner: &Pubkey, mint: &Pubkey, token_program: &Pubkey) -> Pubkey {
    get_associated_token_address_with_program_id(owner, mint, token_program)
}

fn ensure_token_program_matches(
    expected: Pubkey,
    provided: Pubkey,
) -> Result<(), PumpAmmBuilderError> {
    if expected != provided {
        return Err(PumpAmmBuilderError::TokenProgramMismatch { expected, provided });
    }
    Ok(())
}

fn ensure_supported_token_program(program: Pubkey) -> Result<(), PumpAmmBuilderError> {
    if program == LEGACY_TOKEN_PROGRAM || program == TOKEN_2022_PROGRAM_ID {
        Ok(())
    } else {
        Err(PumpAmmBuilderError::UnsupportedTokenProgram { provided: program })
    }
}

fn ensure_quote_program_is_legacy(program: Pubkey) -> Result<(), PumpAmmBuilderError> {
    if program == LEGACY_TOKEN_PROGRAM {
        Ok(())
    } else {
        Err(PumpAmmBuilderError::TokenProgramMismatch {
            expected: LEGACY_TOKEN_PROGRAM,
            provided: program,
        })
    }
}

fn ensure_user_matches(expected: Pubkey, provided: Pubkey) -> Result<(), PumpAmmBuilderError> {
    if expected != provided {
        return Err(PumpAmmBuilderError::UserMismatch { expected, provided });
    }
    Ok(())
}

pub struct PumpAmmTxBuilder;

#[derive(Clone, Debug)]
pub struct PumpAmmCommonTxParams {
    pub payer: Pubkey,
    pub nonce_account: Pubkey,
    pub nonce_authority: Pubkey,
    pub compute_unit_price_micro_lamports: u64,
    pub tip_destination: Pubkey,
    pub tip_lamports: u64,
    pub cu_limit: u32,
    pub base_token_program: Pubkey,
}

impl PumpAmmCommonTxParams {
    fn cu_limit(&self) -> u32 {
        if self.cu_limit == 0 {
            DEFAULT_CU_LIMIT
        } else {
            self.cu_limit
        }
    }

    fn validate(&self) -> Result<(), PumpAmmBuilderError> {
        ensure_supported_token_program(self.base_token_program)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct PumpAmmBuyTxRequest<'a> {
    pub common: PumpAmmCommonTxParams,
    pub base_ata_owner: Pubkey,
    pub base_ata_payer: Pubkey,
    pub buy: BuyExactQuoteInRequest<'a>,
}

#[derive(Clone, Debug)]
pub struct PumpAmmSellTxRequest<'a> {
    pub common: PumpAmmCommonTxParams,
    pub quote_wrap_amount: u64,
    pub sell: SellRequest<'a>,
}

impl PumpAmmTxBuilder {
    pub fn build_buy_transaction<'a>(
        request: PumpAmmBuyTxRequest<'a>,
    ) -> Result<Vec<Instruction>, PumpAmmBuilderError> {
        request.common.validate()?;
        ensure_user_matches(request.common.payer, request.buy.accounts.user)?;

        let mut accounts = request.buy.accounts.clone();
        accounts.user_volume_accumulator = user_volume_accumulator_pda(&request.common.payer);

        ensure_token_program_matches(
            request.common.base_token_program,
            accounts.base_token_program,
        )?;
        ensure_quote_program_is_legacy(accounts.quote_token_program)?;

        let base_ata = derive_ata(
            &request.base_ata_owner,
            &accounts.base_mint,
            &request.common.base_token_program,
        );
        if base_ata != accounts.user_base_token_account {
            return Err(PumpAmmBuilderError::AssociatedBaseAccountMismatch {
                expected: accounts.user_base_token_account,
                derived: base_ata,
            });
        }

        let quote_ata = derive_ata(&accounts.user, &accounts.quote_mint, &LEGACY_TOKEN_PROGRAM);
        if quote_ata != accounts.user_quote_token_account {
            return Err(PumpAmmBuilderError::AssociatedQuoteAccountMismatch {
                expected: accounts.user_quote_token_account,
                derived: quote_ata,
            });
        }

        let cu_limit = request.common.cu_limit();
        let buy_user = accounts.user;
        let mut instructions = Vec::with_capacity(10);

        instructions.push(advance_nonce_instruction(
            request.common.nonce_account,
            request.common.nonce_authority,
        ));
        instructions.push(compute_unit_limit_instruction(cu_limit));
        instructions.push(compute_unit_price_instruction(
            request.common.compute_unit_price_micro_lamports,
        ));
        instructions.push(
            ComputeBudgetInstruction::set_loaded_accounts_data_size_limit(
                LOADED_ACCOUNTS_DATA_LIMIT,
            ),
        );
        if request.common.tip_lamports > 0 {
            instructions.push(tip_transfer_instruction(
                request.common.payer,
                request.common.tip_destination,
                request.common.tip_lamports,
            ));
        }
        instructions.push(create_base_ata_instruction(
            request.base_ata_payer,
            request.base_ata_owner,
            accounts.base_mint,
            request.common.base_token_program,
        ));
        instructions.push(create_wsol_ata_instruction(
            request.common.payer,
            accounts.user,
            accounts.quote_mint,
        ));
        let buffered_quote_in = request
            .buy
            .spendable_quote_in
            .saturating_add(BUY_QUOTE_BUFFER_LAMPORTS);
        instructions.push(transfer_sol_to_ata_instruction(
            request.common.payer,
            quote_ata,
            buffered_quote_in,
        ));
        instructions.push(sync_native_instruction(quote_ata)?);

        let buy_request = BuyExactQuoteInRequest {
            accounts: &accounts,
            spendable_quote_in: buffered_quote_in,
            base_reserve: request.buy.base_reserve,
            quote_reserve: request.buy.quote_reserve,
            fees: request.buy.fees,
            slippage_bps: request.buy.slippage_bps,
            track_volume: request.buy.track_volume,
        };

        let buy_ix = PumpAmmTransactionBuilder::buy_exact_quote_in(buy_request)?;
        instructions.push(buy_ix);

        instructions.push(close_wsol_instruction(
            quote_ata,
            request.common.payer,
            buy_user,
        )?);

        Ok(instructions)
    }

    pub fn build_sell_transaction<'a>(
        request: PumpAmmSellTxRequest<'a>,
    ) -> Result<Vec<Instruction>, PumpAmmBuilderError> {
        request.common.validate()?;
        ensure_user_matches(request.common.payer, request.sell.accounts.user)?;

        let accounts = request.sell.accounts.clone();

        ensure_token_program_matches(
            request.common.base_token_program,
            accounts.base_token_program,
        )?;
        ensure_quote_program_is_legacy(accounts.quote_token_program)?;

        let base_ata = derive_ata(
            &accounts.user,
            &accounts.base_mint,
            &request.common.base_token_program,
        );
        if base_ata != accounts.user_base_token_account {
            return Err(PumpAmmBuilderError::AssociatedBaseAccountMismatch {
                expected: accounts.user_base_token_account,
                derived: base_ata,
            });
        }

        let quote_ata = derive_ata(&accounts.user, &accounts.quote_mint, &LEGACY_TOKEN_PROGRAM);
        if quote_ata != accounts.user_quote_token_account {
            return Err(PumpAmmBuilderError::AssociatedQuoteAccountMismatch {
                expected: accounts.user_quote_token_account,
                derived: quote_ata,
            });
        }

        let cu_limit = request.common.cu_limit();
        let sell_user = accounts.user;
        let mut instructions = Vec::with_capacity(9);

        instructions.push(advance_nonce_instruction(
            request.common.nonce_account,
            request.common.nonce_authority,
        ));
        instructions.push(compute_unit_limit_instruction(cu_limit));
        instructions.push(compute_unit_price_instruction(
            request.common.compute_unit_price_micro_lamports,
        ));
        instructions.push(
            ComputeBudgetInstruction::set_loaded_accounts_data_size_limit(
                LOADED_ACCOUNTS_DATA_LIMIT,
            ),
        );
        if request.common.tip_lamports > 0 {
            instructions.push(tip_transfer_instruction(
                request.common.payer,
                request.common.tip_destination,
                request.common.tip_lamports,
            ));
        }
        instructions.push(create_wsol_ata_instruction(
            request.common.payer,
            accounts.user,
            accounts.quote_mint,
        ));

        let sell_request = SellRequest {
            accounts: &accounts,
            base_amount_in: request.sell.base_amount_in,
            base_reserve: request.sell.base_reserve,
            quote_reserve: request.sell.quote_reserve,
            fees: request.sell.fees,
            slippage_bps: request.sell.slippage_bps,
        };

        let sell_ix = PumpAmmTransactionBuilder::sell(sell_request)?;
        instructions.push(sell_ix);

        instructions.push(close_wsol_instruction(
            quote_ata,
            request.common.payer,
            sell_user,
        )?);

        Ok(instructions)
    }
}

fn buy_exact_quote_in_metas(accounts: &BuyExactQuoteInAccounts) -> Vec<AccountMeta> {
    let mut metas = Vec::with_capacity(23);
    metas.push(AccountMeta::new(accounts.pool, false));
    metas.push(AccountMeta::new(accounts.user, true));
    metas.push(AccountMeta::new_readonly(accounts.global_config, false));
    metas.push(AccountMeta::new_readonly(accounts.base_mint, false));
    metas.push(AccountMeta::new_readonly(accounts.quote_mint, false));
    metas.push(AccountMeta::new(accounts.user_base_token_account, false));
    metas.push(AccountMeta::new(accounts.user_quote_token_account, false));
    metas.push(AccountMeta::new(accounts.pool_base_token_account, false));
    metas.push(AccountMeta::new(accounts.pool_quote_token_account, false));
    metas.push(AccountMeta::new_readonly(
        accounts.protocol_fee_recipient,
        false,
    ));
    metas.push(AccountMeta::new(
        accounts.protocol_fee_recipient_token_account,
        false,
    ));
    metas.push(AccountMeta::new_readonly(
        accounts.base_token_program,
        false,
    ));
    metas.push(AccountMeta::new_readonly(
        accounts.quote_token_program,
        false,
    ));
    metas.push(AccountMeta::new_readonly(accounts.system_program, false));
    metas.push(AccountMeta::new_readonly(
        accounts.associated_token_program,
        false,
    ));
    metas.push(AccountMeta::new_readonly(accounts.event_authority, false));
    metas.push(AccountMeta::new_readonly(accounts.program, false));
    metas.push(AccountMeta::new(accounts.coin_creator_vault_ata, false));
    metas.push(AccountMeta::new_readonly(
        accounts.coin_creator_vault_authority,
        false,
    ));
    metas.push(AccountMeta::new_readonly(
        accounts.global_volume_accumulator,
        false,
    ));
    metas.push(AccountMeta::new(accounts.user_volume_accumulator, false));
    metas.push(AccountMeta::new_readonly(accounts.fee_config, false));
    metas.push(AccountMeta::new_readonly(accounts.fee_program, false));
    metas
}

fn sell_metas(accounts: &SellAccounts) -> Vec<AccountMeta> {
    let mut metas = Vec::with_capacity(20);
    metas.push(AccountMeta::new(accounts.pool, false));
    metas.push(AccountMeta::new(accounts.user, true));
    metas.push(AccountMeta::new_readonly(accounts.global_config, false));
    metas.push(AccountMeta::new_readonly(accounts.base_mint, false));
    metas.push(AccountMeta::new_readonly(accounts.quote_mint, false));
    metas.push(AccountMeta::new(accounts.user_base_token_account, false));
    metas.push(AccountMeta::new(accounts.user_quote_token_account, false));
    metas.push(AccountMeta::new(accounts.pool_base_token_account, false));
    metas.push(AccountMeta::new(accounts.pool_quote_token_account, false));
    metas.push(AccountMeta::new_readonly(
        accounts.protocol_fee_recipient,
        false,
    ));
    metas.push(AccountMeta::new(
        accounts.protocol_fee_recipient_token_account,
        false,
    ));
    metas.push(AccountMeta::new_readonly(
        accounts.base_token_program,
        false,
    ));
    metas.push(AccountMeta::new_readonly(
        accounts.quote_token_program,
        false,
    ));
    metas.push(AccountMeta::new_readonly(accounts.system_program, false));
    metas.push(AccountMeta::new_readonly(
        accounts.associated_token_program,
        false,
    ));
    metas.push(AccountMeta::new_readonly(accounts.event_authority, false));
    metas.push(AccountMeta::new_readonly(accounts.program, false));
    metas.push(AccountMeta::new(accounts.coin_creator_vault_ata, false));
    metas.push(AccountMeta::new_readonly(
        accounts.coin_creator_vault_authority,
        false,
    ));
    metas.push(AccountMeta::new_readonly(accounts.fee_config, false));
    metas.push(AccountMeta::new_readonly(accounts.fee_program, false));
    metas
}

fn ensure_program_id(program: Pubkey) -> Result<(), PumpAmmBuilderError> {
    if program != PUMP_AMM_PROGRAM_ID {
        return Err(PumpAmmBuilderError::InvalidProgramId { provided: program });
    }
    Ok(())
}

fn apply_base_slippage(amount: u64, slippage_bps: u16) -> Option<u64> {
    if amount == 0 {
        return None;
    }
    let capped = slippage_bps.min(10_000);
    if capped == 10_000 {
        return None;
    }
    let numerator = (amount as u128) * (10_000u128 - capped as u128);
    let adjusted = (numerator / 10_000u128) as u64;
    if adjusted == 0 {
        None
    } else {
        Some(adjusted)
    }
}

pub fn user_volume_accumulator_pda(user: &Pubkey) -> Pubkey {
    Pubkey::find_program_address(
        &[b"user_volume_accumulator", user.as_ref()],
        &PUMP_AMM_PROGRAM_ID,
    )
    .0
}

#[cfg(test)]
mod tests {
    use super::*;
    use borsh::BorshDeserialize;
    use solana_sdk::{compute_budget, system_program};

    fn random_pubkey() -> Pubkey {
        Pubkey::new_unique()
    }

    fn sample_buy_accounts(
        user: Pubkey,
        base_mint: Pubkey,
        quote_mint: Pubkey,
        base_program: Pubkey,
    ) -> BuyExactQuoteInAccounts {
        let user_base_ata = derive_ata(&user, &base_mint, &base_program);
        let user_quote_ata = derive_ata(&user, &quote_mint, &LEGACY_TOKEN_PROGRAM);
        BuyExactQuoteInAccounts {
            pool: random_pubkey(),
            user,
            global_config: random_pubkey(),
            base_mint,
            quote_mint,
            user_base_token_account: user_base_ata,
            user_quote_token_account: user_quote_ata,
            pool_base_token_account: random_pubkey(),
            pool_quote_token_account: random_pubkey(),
            protocol_fee_recipient: random_pubkey(),
            protocol_fee_recipient_token_account: random_pubkey(),
            base_token_program: base_program,
            quote_token_program: LEGACY_TOKEN_PROGRAM,
            system_program: system_program::id(),
            associated_token_program: spl_associated_token_account::id(),
            event_authority: random_pubkey(),
            program: PUMP_AMM_PROGRAM_ID,
            coin_creator_vault_ata: random_pubkey(),
            coin_creator_vault_authority: random_pubkey(),
            global_volume_accumulator: random_pubkey(),
            user_volume_accumulator: random_pubkey(),
            fee_config: random_pubkey(),
            fee_program: random_pubkey(),
        }
    }

    fn sample_sell_accounts(
        user: Pubkey,
        base_mint: Pubkey,
        quote_mint: Pubkey,
        base_program: Pubkey,
    ) -> SellAccounts {
        let user_base_ata = derive_ata(&user, &base_mint, &base_program);
        let user_quote_ata = derive_ata(&user, &quote_mint, &LEGACY_TOKEN_PROGRAM);
        SellAccounts {
            pool: random_pubkey(),
            user,
            global_config: random_pubkey(),
            base_mint,
            quote_mint,
            user_base_token_account: user_base_ata,
            user_quote_token_account: user_quote_ata,
            pool_base_token_account: random_pubkey(),
            pool_quote_token_account: random_pubkey(),
            protocol_fee_recipient: random_pubkey(),
            protocol_fee_recipient_token_account: random_pubkey(),
            base_token_program: base_program,
            quote_token_program: LEGACY_TOKEN_PROGRAM,
            system_program: system_program::id(),
            associated_token_program: spl_associated_token_account::id(),
            event_authority: random_pubkey(),
            program: PUMP_AMM_PROGRAM_ID,
            coin_creator_vault_ata: random_pubkey(),
            coin_creator_vault_authority: random_pubkey(),
            fee_config: random_pubkey(),
            fee_program: random_pubkey(),
        }
    }

    #[test]
    fn buy_transaction_includes_expected_instructions() {
        let user = random_pubkey();
        let base_mint = random_pubkey();
        let quote_mint = spl_token::native_mint::id();
        let base_program = LEGACY_TOKEN_PROGRAM;

        let accounts = sample_buy_accounts(user, base_mint, quote_mint, base_program);
        let buy_request = BuyExactQuoteInRequest {
            accounts: &accounts,
            spendable_quote_in: 1_000_000_000,
            base_reserve: 2_000_000_000,
            quote_reserve: 2_000_000_000,
            fees: Fees {
                lp_fee_bps: 50,
                protocol_fee_bps: 25,
                coin_creator_fee_bps: 0,
            },
            slippage_bps: 100,
            track_volume: false,
        };

        let common = PumpAmmCommonTxParams {
            payer: user,
            nonce_account: random_pubkey(),
            nonce_authority: user,
            compute_unit_price_micro_lamports: 1_000,
            tip_destination: random_pubkey(),
            tip_lamports: 10_000,
            cu_limit: DEFAULT_CU_LIMIT,
            base_token_program: base_program,
        };

        let request = PumpAmmBuyTxRequest {
            common,
            base_ata_owner: user,
            base_ata_payer: user,
            buy: buy_request,
        };

        let instructions = PumpAmmTxBuilder::build_buy_transaction(request).unwrap();
        assert_eq!(instructions.len(), 11);
        assert_eq!(instructions[0].program_id, system_program::id());
        assert_eq!(instructions[1].program_id, compute_budget::id());
        assert_eq!(
            instructions[1].accounts.last().unwrap().pubkey,
            MEV_GUARD_ACCOUNT
        );
        assert_eq!(instructions[2].program_id, compute_budget::id());
        assert_eq!(instructions[3].program_id, compute_budget::id());
        assert_eq!(instructions[4].program_id, system_program::id());
        assert_eq!(
            instructions[5].program_id,
            spl_associated_token_account::id()
        );
        assert_eq!(
            instructions[6].program_id,
            spl_associated_token_account::id()
        );
        assert_eq!(instructions[7].program_id, system_program::id());
        assert_eq!(instructions[8].program_id, LEGACY_TOKEN_PROGRAM);
        assert_eq!(instructions[10].program_id, LEGACY_TOKEN_PROGRAM);

        let derived_uva = user_volume_accumulator_pda(&user);
        let pump_ix = &instructions[9];
        assert_eq!(
            pump_ix.accounts[pump_ix.accounts.len() - 3].pubkey,
            derived_uva
        );
        let args = BuyExactQuoteInArgs::try_from_slice(&pump_ix.data[8..]).expect("borsh decode");
        assert_eq!(
            args.spendable_quote_in,
            1_000_000_000 + BUY_QUOTE_BUFFER_LAMPORTS
        );
    }

    #[test]
    fn sell_transaction_includes_expected_instructions() {
        let user = random_pubkey();
        let base_mint = random_pubkey();
        let quote_mint = spl_token::native_mint::id();
        let base_program = TOKEN_2022_PROGRAM_ID;

        let accounts = sample_sell_accounts(user, base_mint, quote_mint, base_program);
        let sell_request = SellRequest {
            accounts: &accounts,
            base_amount_in: 1_000_000,
            base_reserve: 2_000_000_000,
            quote_reserve: 2_500_000_000,
            fees: Fees {
                lp_fee_bps: 50,
                protocol_fee_bps: 25,
                coin_creator_fee_bps: 10,
            },
            slippage_bps: 0,
        };

        let common = PumpAmmCommonTxParams {
            payer: user,
            nonce_account: random_pubkey(),
            nonce_authority: user,
            compute_unit_price_micro_lamports: 1_000,
            tip_destination: random_pubkey(),
            tip_lamports: 5_000,
            cu_limit: DEFAULT_CU_LIMIT,
            base_token_program: base_program,
        };

        let request = PumpAmmSellTxRequest {
            common,
            quote_wrap_amount: 500_000_000,
            sell: sell_request,
        };

        let instructions = PumpAmmTxBuilder::build_sell_transaction(request).unwrap();
        assert_eq!(instructions.len(), 8);
        assert_eq!(instructions[0].program_id, system_program::id());
        assert_eq!(instructions[1].program_id, compute_budget::id());
        assert_eq!(
            instructions[1].accounts.last().unwrap().pubkey,
            MEV_GUARD_ACCOUNT
        );
        assert_eq!(instructions[2].program_id, compute_budget::id());
        assert_eq!(instructions[3].program_id, compute_budget::id());
        assert_eq!(instructions[4].program_id, system_program::id());
        assert_eq!(
            instructions[5].program_id,
            spl_associated_token_account::id()
        );
        assert_eq!(instructions[6].program_id, PUMP_AMM_PROGRAM_ID);
        assert_eq!(instructions[7].program_id, LEGACY_TOKEN_PROGRAM);
    }
}
</file>

<file path="swap/pump.rs">
#![allow(dead_code)]

use borsh::{self, BorshDeserialize, BorshSerialize};
use solana_sdk::{
    compute_budget::ComputeBudgetInstruction,
    instruction::{AccountMeta, Instruction},
    pubkey,
    pubkey::Pubkey,
    system_instruction,
};
use spl_associated_token_account::{
    get_associated_token_address_with_program_id,
    instruction::create_associated_token_account_idempotent,
};
use spl_token_2022::ID as TOKEN_2022_PROGRAM_ID;
use std::io;
use thiserror::Error;

use crate::{
    parsers::pump_fun::{discriminators, PUMP_FUN_PROGRAM_ID},
    swap::constants::{
        get_buy_token_amount_from_sol_amount, get_sell_sol_amount_from_token_amount,
        LOADED_ACCOUNTS_DATA_LIMIT,
    },
};

const DEFAULT_CU_LIMIT: u32 = 120_000;
const BUY_SOL_BUFFER_LAMPORTS: u64 = 300_000;
const MEV_GUARD_ACCOUNT: Pubkey = pubkey!("jitodontfrontB1111111NahLeaveitDontMevMeBro");

/// Builds Pump.fun buy/sell instructions while reusing account metas scraped from a
/// source transaction.
///
/// The builder is intentionally allocation-light (single Vec per IX) so it can
/// run in the hot copy-trading path.
pub struct PumpFunTransactionBuilder;

impl PumpFunTransactionBuilder {
    /// Build a `buy_exact_sol_in` instruction that applies slippage protection on
    /// the base-token amount (min_tokens_out).
    pub fn buy_exact_sol_in(
        params: BuyExactSolInRequest<'_>,
    ) -> Result<Instruction, PumpTransactionBuilderError> {
        ensure_program_id(params.accounts.program)?;

        let expected_tokens = get_buy_token_amount_from_sol_amount(
            params.virtual_token_reserves,
            params.virtual_sol_reserves,
            params.real_token_reserves,
            params.spendable_sol_in,
        );

        if expected_tokens == 0 {
            return Err(PumpTransactionBuilderError::ZeroExpectedTokens {
                spendable_sol_in: params.spendable_sol_in,
            });
        }

        let min_tokens_out = apply_base_slippage(expected_tokens, params.slippage_bps).ok_or(
            PumpTransactionBuilderError::SlippageTooLarge {
                slippage_bps: params.slippage_bps,
            },
        )?;

        let args = BuyExactSolInArgs {
            spendable_sol_in: params.spendable_sol_in,
            min_tokens_out,
            track_volume: OptionBool(params.track_volume),
        };

        let mut data = Vec::with_capacity(8 + core::mem::size_of::<BuyExactSolInArgs>());
        data.extend_from_slice(&discriminators::BUY_EXACT_SOL_IN);
        data.extend(borsh::to_vec(&args)?);

        Ok(Instruction {
            program_id: PUMP_FUN_PROGRAM_ID,
            accounts: buy_exact_sol_in_metas(params.accounts),
            data,
        })
    }

    /// Build a `sell` instruction using the standard Pump.fun curve math.
    pub fn sell(params: SellRequest<'_>) -> Result<Instruction, PumpTransactionBuilderError> {
        ensure_program_id(params.accounts.program)?;

        if params.amount == 0 {
            return Err(PumpTransactionBuilderError::ZeroSellOutput { amount: 0 });
        }

        let min_sol_output = get_sell_sol_amount_from_token_amount(
            params.virtual_token_reserves,
            params.virtual_sol_reserves,
            params.amount,
        );

        if min_sol_output == 0 {
            return Err(PumpTransactionBuilderError::ZeroSellOutput {
                amount: params.amount,
            });
        }
        let min_sol_output = apply_base_slippage(min_sol_output, params.slippage_bps).ok_or(
            PumpTransactionBuilderError::SlippageTooLarge {
                slippage_bps: params.slippage_bps,
            },
        )?;

        let args = SellArgs {
            amount: params.amount,
            min_sol_output,
        };

        let mut data = Vec::with_capacity(8 + core::mem::size_of::<SellArgs>());
        data.extend_from_slice(&discriminators::SELL);
        data.extend(borsh::to_vec(&args)?);

        Ok(Instruction {
            program_id: PUMP_FUN_PROGRAM_ID,
            accounts: sell_metas(params.accounts),
            data,
        })
    }
}

pub struct PumpFunTxBuilder;

#[derive(Clone, Debug)]
pub struct PumpFunCommonTxParams {
    pub payer: Pubkey,
    pub nonce_account: Pubkey,
    pub nonce_authority: Pubkey,
    pub compute_unit_price_micro_lamports: u64,
    pub tip_destination: Pubkey,
    pub tip_lamports: u64,
    pub cu_limit: u32,
    pub token_program: Pubkey,
}

impl PumpFunCommonTxParams {
    fn cu_limit(&self) -> u32 {
        if self.cu_limit == 0 {
            DEFAULT_CU_LIMIT
        } else {
            self.cu_limit
        }
    }

    fn validate(&self) -> Result<(), PumpTransactionBuilderError> {
        ensure_supported_token_program(self.token_program)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct PumpFunBuyTxRequest<'a> {
    pub common: PumpFunCommonTxParams,
    pub ata_owner: Pubkey,
    pub ata_payer: Pubkey,
    pub buy: BuyExactSolInRequest<'a>,
}

#[derive(Clone, Debug)]
pub struct PumpFunSellTxRequest<'a> {
    pub common: PumpFunCommonTxParams,
    pub sell: SellRequest<'a>,
}

impl PumpFunTxBuilder {
    pub fn build_buy_transaction<'a>(
        request: PumpFunBuyTxRequest<'a>,
    ) -> Result<Vec<Instruction>, PumpTransactionBuilderError> {
        request.common.validate()?;
        ensure_user_matches(request.common.payer, request.buy.accounts.user)?;
        ensure_token_program_matches(
            request.common.token_program,
            request.buy.accounts.token_program,
        )?;

        let cu_limit = request.common.cu_limit();
        let mut instructions = Vec::with_capacity(6);

        instructions.push(advance_nonce_instruction(
            request.common.nonce_account,
            request.common.nonce_authority,
        ));
        instructions.push(compute_unit_limit_instruction(cu_limit));
        instructions.push(compute_unit_price_instruction(
            request.common.compute_unit_price_micro_lamports,
        ));
        instructions.push(
            ComputeBudgetInstruction::set_loaded_accounts_data_size_limit(
                LOADED_ACCOUNTS_DATA_LIMIT,
            ),
        );

        if request.common.tip_lamports > 0 {
            instructions.push(tip_transfer_instruction(
                request.common.payer,
                request.common.tip_destination,
                request.common.tip_lamports,
            ));
        }

        let ata_ix = build_create_ata_instruction(&request, request.common.token_program)?;
        instructions.push(ata_ix);

        let mut buy_accounts = request.buy.accounts.clone();
        buy_accounts.user_volume_accumulator = user_volume_accumulator_pda(&request.common.payer);
        let buffered_sol_in = request
            .buy
            .spendable_sol_in
            .saturating_add(BUY_SOL_BUFFER_LAMPORTS);
        let buy_request = BuyExactSolInRequest {
            accounts: &buy_accounts,
            spendable_sol_in: buffered_sol_in,
            virtual_token_reserves: request.buy.virtual_token_reserves,
            virtual_sol_reserves: request.buy.virtual_sol_reserves,
            real_token_reserves: request.buy.real_token_reserves,
            slippage_bps: request.buy.slippage_bps,
            track_volume: request.buy.track_volume,
        };

        let buy_ix = PumpFunTransactionBuilder::buy_exact_sol_in(buy_request)?;
        instructions.push(buy_ix);

        Ok(instructions)
    }

    pub fn build_sell_transaction<'a>(
        request: PumpFunSellTxRequest<'a>,
    ) -> Result<Vec<Instruction>, PumpTransactionBuilderError> {
        request.common.validate()?;
        ensure_user_matches(request.common.payer, request.sell.accounts.user)?;
        ensure_token_program_matches(
            request.common.token_program,
            request.sell.accounts.token_program,
        )?;

        let cu_limit = request.common.cu_limit();
        let mut instructions = Vec::with_capacity(5);

        instructions.push(advance_nonce_instruction(
            request.common.nonce_account,
            request.common.nonce_authority,
        ));
        instructions.push(compute_unit_limit_instruction(cu_limit));
        instructions.push(compute_unit_price_instruction(
            request.common.compute_unit_price_micro_lamports,
        ));
        instructions.push(
            ComputeBudgetInstruction::set_loaded_accounts_data_size_limit(
                LOADED_ACCOUNTS_DATA_LIMIT,
            ),
        );

        if request.common.tip_lamports > 0 {
            instructions.push(tip_transfer_instruction(
                request.common.payer,
                request.common.tip_destination,
                request.common.tip_lamports,
            ));
        }

        let sell_ix = PumpFunTransactionBuilder::sell(request.sell)?;
        instructions.push(sell_ix);

        Ok(instructions)
    }
}

fn advance_nonce_instruction(nonce_account: Pubkey, nonce_authority: Pubkey) -> Instruction {
    system_instruction::advance_nonce_account(&nonce_account, &nonce_authority)
}

fn compute_unit_limit_instruction(cu_limit: u32) -> Instruction {
    let mut ix = ComputeBudgetInstruction::set_compute_unit_limit(cu_limit);
    ix.accounts
        .push(AccountMeta::new_readonly(MEV_GUARD_ACCOUNT, false));
    ix
}

fn compute_unit_price_instruction(micro_lamports: u64) -> Instruction {
    ComputeBudgetInstruction::set_compute_unit_price(micro_lamports)
}

fn tip_transfer_instruction(payer: Pubkey, destination: Pubkey, lamports: u64) -> Instruction {
    system_instruction::transfer(&payer, &destination, lamports)
}

fn build_create_ata_instruction(
    request: &PumpFunBuyTxRequest<'_>,
    token_program: Pubkey,
) -> Result<Instruction, PumpTransactionBuilderError> {
    let derived = get_associated_token_address_with_program_id(
        &request.ata_owner,
        &request.buy.accounts.mint,
        &token_program,
    );
    if derived != request.buy.accounts.associated_user {
        return Err(PumpTransactionBuilderError::AssociatedUserMismatch {
            expected: request.buy.accounts.associated_user,
            derived,
        });
    }

    Ok(create_associated_token_account_idempotent(
        &request.ata_payer,
        &request.ata_owner,
        &request.buy.accounts.mint,
        &token_program,
    ))
}

fn ensure_token_program_matches(
    expected: Pubkey,
    provided: Pubkey,
) -> Result<(), PumpTransactionBuilderError> {
    if expected != provided {
        return Err(PumpTransactionBuilderError::TokenProgramMismatch { expected, provided });
    }
    Ok(())
}

fn ensure_user_matches(
    expected: Pubkey,
    provided: Pubkey,
) -> Result<(), PumpTransactionBuilderError> {
    if expected != provided {
        return Err(PumpTransactionBuilderError::UserMismatch { expected, provided });
    }
    Ok(())
}

fn ensure_supported_token_program(program: Pubkey) -> Result<(), PumpTransactionBuilderError> {
    if program == spl_token::id() || program == TOKEN_2022_PROGRAM_ID {
        Ok(())
    } else {
        Err(PumpTransactionBuilderError::UnsupportedTokenProgram { provided: program })
    }
}

/// Accounts required for `buy_exact_sol_in`.
#[derive(Clone, Debug)]
pub struct BuyExactSolInAccounts {
    pub global: Pubkey,
    pub fee_recipient: Pubkey,
    pub mint: Pubkey,
    pub bonding_curve: Pubkey,
    pub associated_bonding_curve: Pubkey,
    pub associated_user: Pubkey,
    pub user: Pubkey,
    pub system_program: Pubkey,
    pub token_program: Pubkey,
    pub creator_vault: Pubkey,
    pub event_authority: Pubkey,
    pub program: Pubkey,
    pub global_volume_accumulator: Pubkey,
    pub user_volume_accumulator: Pubkey,
    pub fee_config: Pubkey,
    pub fee_program: Pubkey,
}

/// Accounts required for `sell`.
#[derive(Clone, Debug)]
pub struct SellAccounts {
    pub global: Pubkey,
    pub fee_recipient: Pubkey,
    pub mint: Pubkey,
    pub bonding_curve: Pubkey,
    pub associated_bonding_curve: Pubkey,
    pub associated_user: Pubkey,
    pub user: Pubkey,
    pub system_program: Pubkey,
    pub creator_vault: Pubkey,
    pub token_program: Pubkey,
    pub event_authority: Pubkey,
    pub program: Pubkey,
    pub fee_config: Pubkey,
    pub fee_program: Pubkey,
}

/// Parameters for `buy_exact_sol_in`.
#[derive(Clone, Debug)]
pub struct BuyExactSolInRequest<'a> {
    pub accounts: &'a BuyExactSolInAccounts,
    pub spendable_sol_in: u64,
    pub virtual_token_reserves: u128,
    pub virtual_sol_reserves: u128,
    pub real_token_reserves: u128,
    pub slippage_bps: u16,
    pub track_volume: bool,
}

/// Parameters for `sell`.
#[derive(Clone, Debug)]
pub struct SellRequest<'a> {
    pub accounts: &'a SellAccounts,
    pub amount: u64,
    pub virtual_token_reserves: u128,
    pub virtual_sol_reserves: u128,
    pub slippage_bps: u16,
}

#[derive(Debug, Error)]
pub enum PumpTransactionBuilderError {
    #[error("expected token output is zero for spendable SOL {spendable_sol_in}")]
    ZeroExpectedTokens { spendable_sol_in: u64 },
    #[error("min tokens out became zero after applying {slippage_bps} bps slippage")]
    SlippageTooLarge { slippage_bps: u16 },
    #[error("sell output is zero for base amount {amount}")]
    ZeroSellOutput { amount: u64 },
    #[error("invalid Pump.fun program id {provided}")]
    InvalidProgramId { provided: Pubkey },
    #[error("priority fees must be non-negative, got {priority_fees}")]
    NegativePriorityFees { priority_fees: f64 },
    #[error("token program mismatch, expected {expected}, provided {provided}")]
    TokenProgramMismatch { expected: Pubkey, provided: Pubkey },
    #[error("transaction user {provided} does not match expected payer {expected}")]
    UserMismatch { expected: Pubkey, provided: Pubkey },
    #[error("unsupported token program {provided}")]
    UnsupportedTokenProgram { provided: Pubkey },
    #[error("associated user {expected} does not match derived ATA {derived}")]
    AssociatedUserMismatch { expected: Pubkey, derived: Pubkey },
    #[error(transparent)]
    Serialization(#[from] io::Error),
}

#[derive(BorshSerialize, BorshDeserialize)]
struct BuyExactSolInArgs {
    spendable_sol_in: u64,
    min_tokens_out: u64,
    track_volume: OptionBool,
}

#[derive(BorshSerialize, BorshDeserialize)]
struct SellArgs {
    amount: u64,
    min_sol_output: u64,
}

#[derive(BorshSerialize, BorshDeserialize)]
struct OptionBool(pub bool);

fn buy_exact_sol_in_metas(accounts: &BuyExactSolInAccounts) -> Vec<AccountMeta> {
    let mut metas = Vec::with_capacity(16);
    metas.push(AccountMeta::new_readonly(accounts.global, false));
    metas.push(AccountMeta::new(accounts.fee_recipient, false));
    metas.push(AccountMeta::new_readonly(accounts.mint, false));
    metas.push(AccountMeta::new(accounts.bonding_curve, false));
    metas.push(AccountMeta::new(accounts.associated_bonding_curve, false));
    metas.push(AccountMeta::new(accounts.associated_user, false));
    metas.push(AccountMeta::new(accounts.user, true));
    metas.push(AccountMeta::new_readonly(accounts.system_program, false));
    metas.push(AccountMeta::new_readonly(accounts.token_program, false));
    metas.push(AccountMeta::new(accounts.creator_vault, false));
    metas.push(AccountMeta::new_readonly(accounts.event_authority, false));
    metas.push(AccountMeta::new_readonly(accounts.program, false));
    metas.push(AccountMeta::new_readonly(
        accounts.global_volume_accumulator,
        false,
    ));
    metas.push(AccountMeta::new(accounts.user_volume_accumulator, false));
    metas.push(AccountMeta::new_readonly(accounts.fee_config, false));
    metas.push(AccountMeta::new_readonly(accounts.fee_program, false));
    metas
}

fn sell_metas(accounts: &SellAccounts) -> Vec<AccountMeta> {
    let mut metas = Vec::with_capacity(14);
    metas.push(AccountMeta::new_readonly(accounts.global, false));
    metas.push(AccountMeta::new(accounts.fee_recipient, false));
    metas.push(AccountMeta::new_readonly(accounts.mint, false));
    metas.push(AccountMeta::new(accounts.bonding_curve, false));
    metas.push(AccountMeta::new(accounts.associated_bonding_curve, false));
    metas.push(AccountMeta::new(accounts.associated_user, false));
    metas.push(AccountMeta::new(accounts.user, true));
    metas.push(AccountMeta::new_readonly(accounts.system_program, false));
    metas.push(AccountMeta::new(accounts.creator_vault, false));
    metas.push(AccountMeta::new_readonly(accounts.token_program, false));
    metas.push(AccountMeta::new_readonly(accounts.event_authority, false));
    metas.push(AccountMeta::new_readonly(accounts.program, false));
    metas.push(AccountMeta::new_readonly(accounts.fee_config, false));
    metas.push(AccountMeta::new_readonly(accounts.fee_program, false));
    metas
}

fn ensure_program_id(program: Pubkey) -> Result<(), PumpTransactionBuilderError> {
    if program != PUMP_FUN_PROGRAM_ID {
        return Err(PumpTransactionBuilderError::InvalidProgramId { provided: program });
    }
    Ok(())
}

fn apply_base_slippage(amount: u64, slippage_bps: u16) -> Option<u64> {
    if amount == 0 {
        return None;
    }
    let capped_bps = slippage_bps.min(10_000);
    if capped_bps == 10_000 {
        return None;
    }
    let numerator = (amount as u128).saturating_mul((10_000u32 - capped_bps as u32) as u128);
    let adjusted = (numerator / 10_000u128) as u64;
    if adjusted == 0 {
        None
    } else {
        Some(adjusted)
    }
}

pub fn user_volume_accumulator_pda(user: &Pubkey) -> Pubkey {
    let (user_volume_accumulator, _bump) = Pubkey::find_program_address(
        &[b"user_volume_accumulator", user.as_ref()],
        &PUMP_FUN_PROGRAM_ID,
    );
    user_volume_accumulator
}

#[cfg(test)]
mod tests {
    use super::*;
    use borsh::BorshDeserialize;
    use solana_sdk::{compute_budget, system_program};

    fn random_pubkey() -> Pubkey {
        Pubkey::new_unique()
    }

    fn sample_buy_accounts(
        user: Pubkey,
        mint: Pubkey,
        token_program: Pubkey,
    ) -> BuyExactSolInAccounts {
        let associated_user =
            get_associated_token_address_with_program_id(&user, &mint, &token_program);
        BuyExactSolInAccounts {
            global: random_pubkey(),
            fee_recipient: random_pubkey(),
            mint,
            bonding_curve: random_pubkey(),
            associated_bonding_curve: random_pubkey(),
            associated_user,
            user,
            system_program: system_program::id(),
            token_program,
            creator_vault: random_pubkey(),
            event_authority: random_pubkey(),
            program: PUMP_FUN_PROGRAM_ID,
            global_volume_accumulator: random_pubkey(),
            user_volume_accumulator: random_pubkey(),
            fee_config: random_pubkey(),
            fee_program: random_pubkey(),
        }
    }

    fn sample_sell_accounts(user: Pubkey, mint: Pubkey, token_program: Pubkey) -> SellAccounts {
        SellAccounts {
            global: random_pubkey(),
            fee_recipient: random_pubkey(),
            mint,
            bonding_curve: random_pubkey(),
            associated_bonding_curve: random_pubkey(),
            associated_user: get_associated_token_address_with_program_id(
                &user,
                &mint,
                &token_program,
            ),
            user,
            system_program: system_program::id(),
            creator_vault: random_pubkey(),
            token_program,
            event_authority: random_pubkey(),
            program: PUMP_FUN_PROGRAM_ID,
            fee_config: random_pubkey(),
            fee_program: random_pubkey(),
        }
    }

    #[test]
    fn build_buy_transaction_orders_instructions_for_legacy_token() {
        let payer = random_pubkey();
        let mint = random_pubkey();
        let token_program = spl_token::id();
        let buy_accounts = sample_buy_accounts(payer, mint, token_program);
        let buy_request = BuyExactSolInRequest {
            accounts: &buy_accounts,
            spendable_sol_in: 1_000_000_000,
            virtual_token_reserves: 1_000_000_000,
            virtual_sol_reserves: 1_000_000_000,
            real_token_reserves: 1_000_000_000,
            slippage_bps: 100,
            track_volume: true,
        };

        let common = PumpFunCommonTxParams {
            payer,
            nonce_account: random_pubkey(),
            nonce_authority: payer,
            compute_unit_price_micro_lamports: 1_000,
            tip_destination: random_pubkey(),
            tip_lamports: 5_000,
            cu_limit: DEFAULT_CU_LIMIT,
            token_program,
        };

        let request = PumpFunBuyTxRequest {
            common,
            ata_owner: payer,
            ata_payer: payer,
            buy: buy_request,
        };

        let instructions = PumpFunTxBuilder::build_buy_transaction(request).unwrap();
        assert_eq!(instructions.len(), 7);
        assert_eq!(instructions[0].program_id, system_program::id());
        assert_eq!(instructions[1].program_id, compute_budget::id());
        assert_eq!(
            instructions[1].accounts.last().unwrap().pubkey,
            MEV_GUARD_ACCOUNT
        );
        assert_eq!(instructions[2].program_id, compute_budget::id());
        assert_eq!(instructions[3].program_id, compute_budget::id());
        assert_eq!(instructions[4].program_id, system_program::id());
        assert_eq!(
            instructions[5].program_id,
            spl_associated_token_account::id()
        );
        assert_eq!(instructions[6].program_id, PUMP_FUN_PROGRAM_ID);

        let derived_uva = user_volume_accumulator_pda(&payer);
        let pump_ix = instructions.last().unwrap();
        assert_eq!(pump_ix.accounts[13].pubkey, derived_uva);
        let args = BuyExactSolInArgs::try_from_slice(&pump_ix.data[8..]).expect("borsh decode");
        assert_eq!(
            args.spendable_sol_in,
            1_000_000_000 + BUY_SOL_BUFFER_LAMPORTS
        );
    }

    #[test]
    fn build_buy_transaction_supports_token_2022() {
        let payer = random_pubkey();
        let mint = random_pubkey();
        let token_program = TOKEN_2022_PROGRAM_ID;
        let buy_accounts = sample_buy_accounts(payer, mint, token_program);
        let buy_request = BuyExactSolInRequest {
            accounts: &buy_accounts,
            spendable_sol_in: 500_000_000,
            virtual_token_reserves: 2_000_000_000,
            virtual_sol_reserves: 1_500_000_000,
            real_token_reserves: 2_000_000_000,
            slippage_bps: 50,
            track_volume: false,
        };

        let common = PumpFunCommonTxParams {
            payer,
            nonce_account: random_pubkey(),
            nonce_authority: payer,
            compute_unit_price_micro_lamports: 1_000,
            tip_destination: random_pubkey(),
            tip_lamports: 10_000,
            cu_limit: DEFAULT_CU_LIMIT,
            token_program,
        };

        let request = PumpFunBuyTxRequest {
            common,
            ata_owner: payer,
            ata_payer: payer,
            buy: buy_request,
        };

        let instructions = PumpFunTxBuilder::build_buy_transaction(request).unwrap();
        assert_eq!(instructions.len(), 7);
        assert_eq!(
            instructions[5].program_id,
            spl_associated_token_account::id()
        );
    }

    #[test]
    fn build_sell_transaction_omits_ata_instruction() {
        let payer = random_pubkey();
        let mint = random_pubkey();
        let token_program = spl_token::id();
        let sell_accounts = sample_sell_accounts(payer, mint, token_program);
        let sell_request = SellRequest {
            accounts: &sell_accounts,
            amount: 1_000_000,
            virtual_token_reserves: 2_000_000_000,
            virtual_sol_reserves: 2_500_000_000,
            slippage_bps: 0,
        };

        let common = PumpFunCommonTxParams {
            payer,
            nonce_account: random_pubkey(),
            nonce_authority: payer,
            compute_unit_price_micro_lamports: 1_000,
            tip_destination: random_pubkey(),
            tip_lamports: 12_345,
            cu_limit: DEFAULT_CU_LIMIT,
            token_program,
        };

        let request = PumpFunSellTxRequest {
            common,
            sell: sell_request,
        };
        let instructions = PumpFunTxBuilder::build_sell_transaction(request).unwrap();
        assert_eq!(instructions.len(), 6);
        assert_eq!(instructions[0].program_id, system_program::id());
        assert_eq!(instructions[1].program_id, compute_budget::id());
        assert_eq!(
            instructions[1].accounts.last().unwrap().pubkey,
            MEV_GUARD_ACCOUNT
        );
        assert_eq!(instructions[2].program_id, compute_budget::id());
        assert_eq!(instructions[3].program_id, compute_budget::id());
        assert_eq!(instructions[4].program_id, system_program::id());
        assert_eq!(instructions[5].program_id, PUMP_FUN_PROGRAM_ID);
    }
}
</file>

<file path="config.rs">
use std::{
    env,
    path::{Path, PathBuf},
    str::FromStr,
    sync::Arc,
};

use base64::{engine::general_purpose, Engine as _};
use dotenvy::Error as DotenvError;
use serde::Deserialize;
use solana_sdk::{
    native_token::sol_to_lamports,
    pubkey::Pubkey,
    signature::{Keypair, Signer},
};
use thiserror::Error;

#[derive(Clone)]
pub struct Config {
    pub env_path: PathBuf,
    pub operator: Arc<Keypair>,
    pub buy_amount_sol: f64,
    pub priority_fees: f64,
    pub tx_tip_sol: f64,
    pub buy_priority_fees: f64,
    pub sell_priority_fees: f64,
    pub buy_tx_tip_sol: f64,
    pub sell_tx_tip_sol: f64,
    pub astralane_api_key: String,
    pub blockrazor_api_key: String,
    pub stellium_api_key: String,
    pub flashblock_api_key: String,
    pub zero_slot_api_key: String,
    pub nonce_accounts: Vec<Option<Pubkey>>,
    pub grpc_endpoint: String,
    pub grpc_x_token: Option<String>,
    pub rpc_url: String,
    pub target_wallets: Vec<TargetWalletConfig>,
}

impl Config {
    pub fn load() -> Result<Self, ConfigError> {
        let env_path = env::current_dir()
            .map_err(|e| ConfigError::Io("current_dir".into(), e))?
            .join(".env");

        match dotenvy::from_path(&env_path) {
            Ok(_) => {}
            Err(DotenvError::LineParse(_, _)) | Err(DotenvError::Io(_)) if env_path.exists() => {
                return Err(ConfigError::Dotenv)
            }
            Err(_) => {
                return Err(ConfigError::MissingEnv(env_path));
            }
        }

        let raw = RawConfig::gather()?;

        let operator = Arc::new(parse_keypair(&raw.private_key)?);

        let mut nonce_accounts = Vec::new();
        let mut i = 1;
        loop {
            let key = format!("NONCE_ACCOUNT_{}", i);
            match env::var(&key) {
                Ok(val) => {
                    nonce_accounts.push(parse_optional_pubkey(Some(&val))?);
                    i += 1;
                }
                Err(_) => break,
            }
        }

        let target_wallets = load_target_wallets()?;

        let buy_priority_fees = raw.buy_priority_fees.unwrap_or(raw.priority_fees);
        let sell_priority_fees = raw.sell_priority_fees.unwrap_or(raw.priority_fees);
        let buy_tx_tip_sol = raw.buy_tx_tip.unwrap_or(raw.tx_tip);
        let sell_tx_tip_sol = raw.sell_tx_tip.unwrap_or(raw.tx_tip);

        Ok(Self {
            env_path,
            operator,
            buy_amount_sol: raw.buy_amount_sol,
            priority_fees: raw.priority_fees,
            tx_tip_sol: raw.tx_tip,
            buy_priority_fees,
            sell_priority_fees,
            buy_tx_tip_sol,
            sell_tx_tip_sol,
            astralane_api_key: raw.astralane_api_key,
            blockrazor_api_key: raw.blockrazor_api_key,
            stellium_api_key: raw.stellium_api_key,
            flashblock_api_key: raw.flashblock_api_key,
            zero_slot_api_key: raw.zero_slot_api_key,
            nonce_accounts,
            grpc_endpoint: raw.grpc_endpoint,
            grpc_x_token: raw.grpc_x_token,
            rpc_url: raw.rpc_url,
            target_wallets,
        })
    }

    pub fn buy_amount_lamports(&self) -> u64 {
        sol_to_lamports(self.buy_amount_sol.max(0.0))
    }

    pub fn operator_pubkey(&self) -> Pubkey {
        self.operator.pubkey()
    }

    pub fn operator_keypair(&self) -> Arc<Keypair> {
        Arc::clone(&self.operator)
    }

    pub fn tx_tip_lamports(&self) -> u64 {
        sol_to_lamports(self.tx_tip_sol.max(0.0))
    }

    pub fn compute_unit_price_microlamports(&self, cu_limit: u32) -> u64 {
        compute_unit_price_for_fee(self.priority_fees, cu_limit)
    }

    pub fn buy_tx_tip_lamports(&self) -> u64 {
        sol_to_lamports(self.buy_tx_tip_sol.max(0.0))
    }

    pub fn sell_tx_tip_lamports(&self) -> u64 {
        sol_to_lamports(self.sell_tx_tip_sol.max(0.0))
    }

    pub fn buy_compute_unit_price_microlamports(&self, cu_limit: u32) -> u64 {
        compute_unit_price_for_fee(self.buy_priority_fees, cu_limit)
    }

    pub fn sell_compute_unit_price_microlamports(&self, cu_limit: u32) -> u64 {
        compute_unit_price_for_fee(self.sell_priority_fees, cu_limit)
    }
}

fn compute_unit_price_for_fee(fee: f64, cu_limit: u32) -> u64 {
    if cu_limit == 0 {
        return 0;
    }
    let micro_total = fee.max(0.0) * 1_000_000_000_000_000.0; // 1e15 microlamports
    (micro_total / cu_limit as f64)
        .max(0.0)
        .min(u64::MAX as f64) as u64
}

#[derive(Clone, Debug)]
pub struct TargetWalletConfig {
    pub wallet: Pubkey,
    pub slippage_pct: f64,
    pub mirror_sells: bool,
    pub take_profit_pct: Option<f64>,
    pub stop_loss_pct: Option<f64>,
}

#[derive(Deserialize)]
struct RawConfig {
    #[serde(rename = "PRIVATE_KEY")]
    private_key: String,
    #[serde(rename = "BUY_AMOUNT_SOL", deserialize_with = "de_f64")]
    buy_amount_sol: f64,
    #[serde(rename = "PRIORITY_FEES", deserialize_with = "de_f64")]
    priority_fees: f64,
    #[serde(rename = "TX_TIP", deserialize_with = "de_f64")]
    tx_tip: f64,
    #[serde(
        rename = "BUY_PRIORITY_FEES",
        default,
        deserialize_with = "de_optional_f64"
    )]
    buy_priority_fees: Option<f64>,
    #[serde(
        rename = "SELL_PRIORITY_FEES",
        default,
        deserialize_with = "de_optional_f64"
    )]
    sell_priority_fees: Option<f64>,
    #[serde(rename = "BUY_TX_TIP", default, deserialize_with = "de_optional_f64")]
    buy_tx_tip: Option<f64>,
    #[serde(rename = "SELL_TX_TIP", default, deserialize_with = "de_optional_f64")]
    sell_tx_tip: Option<f64>,
    #[serde(rename = "ASTRALANE_API_KEY")]
    astralane_api_key: String,
    #[serde(rename = "BLOCKRAZOR_API_KEY")]
    blockrazor_api_key: String,
    #[serde(rename = "STELLIUM_API_KEY")]
    stellium_api_key: String,
    #[serde(rename = "FLASHBLOCK_API_KEY")]
    flashblock_api_key: String,
    #[serde(rename = "ZERO_SLOT_API_KEY")]
    zero_slot_api_key: String,
    #[serde(rename = "GRPC_ENDPOINT")]
    grpc_endpoint: String,
    #[serde(
        rename = "GRPC_X_TOKEN",
        default,
        deserialize_with = "de_optional_string"
    )]
    grpc_x_token: Option<String>,
    #[serde(rename = "RPC_URL")]
    rpc_url: String,
}

impl RawConfig {
    fn gather() -> Result<Self, ConfigError> {
        let mut data = std::collections::BTreeMap::new();
        for (key, value) in env::vars() {
            data.insert(key, value);
        }
        let json = serde_json::to_value(&data).map_err(|e| ConfigError::Serde(e.to_string()))?;
        serde_json::from_value(json).map_err(|e| ConfigError::Serde(e.to_string()))
    }
}

fn parse_optional_pubkey(value: Option<&str>) -> Result<Option<Pubkey>, ConfigError> {
    match value {
        Some(v) if !v.trim().is_empty() => Pubkey::from_str(v.trim())
            .map(Some)
            .map_err(|e| ConfigError::Pubkey(v.into(), e)),
        _ => Ok(None),
    }
}

fn parse_keypair(encoded: &str) -> Result<Keypair, ConfigError> {
    let trimmed = encoded.trim();

    if let Ok(bytes) = bs58::decode(trimmed).into_vec() {
        if let Ok(kp) = Keypair::from_bytes(&bytes) {
            return Ok(kp);
        }
    }

    if let Ok(bytes) = general_purpose::STANDARD.decode(trimmed.as_bytes()) {
        if let Ok(kp) = Keypair::from_bytes(&bytes) {
            return Ok(kp);
        }
    }

    if trimmed.starts_with('[') {
        if let Ok(vec) = serde_json::from_str::<Vec<u8>>(trimmed) {
            if let Ok(kp) = Keypair::from_bytes(&vec) {
                return Ok(kp);
            }
        }
    }

    Err(ConfigError::InvalidPrivateKey)
}

fn parse_bool(key: &str, raw: &str) -> Result<bool, ConfigError> {
    let normalized = raw.trim().to_ascii_lowercase();
    match normalized.as_str() {
        "true" | "1" | "yes" | "y" => Ok(true),
        "false" | "0" | "no" | "n" => Ok(false),
        _ => Err(ConfigError::InvalidBoolean {
            key: key.to_string(),
            value: raw.to_string(),
        }),
    }
}

fn parse_optional_percentage(key: &str, raw: &str) -> Result<Option<f64>, ConfigError> {
    let trimmed = raw.trim();
    if trimmed.is_empty() {
        return Ok(None);
    }
    let value = trimmed
        .parse::<f64>()
        .map_err(|_| ConfigError::InvalidPercentage {
            key: key.to_string(),
            value: raw.to_string(),
        })?;
    if value <= 0.0 {
        if value < 0.0 {
            return Err(ConfigError::InvalidPercentage {
                key: key.to_string(),
                value: raw.to_string(),
            });
        }
        return Ok(None);
    }
    Ok(Some(value))
}

fn de_f64<'de, D>(deserializer: D) -> Result<f64, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let raw = String::deserialize(deserializer)?;
    raw.trim()
        .parse::<f64>()
        .map_err(|_| serde::de::Error::custom("expected number"))
}

fn de_optional_string<'de, D>(deserializer: D) -> Result<Option<String>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let opt = Option::<String>::deserialize(deserializer)?;
    Ok(opt.and_then(|s| {
        let trimmed = s.trim();
        if trimmed.is_empty() {
            None
        } else {
            Some(trimmed.to_owned())
        }
    }))
}

fn de_optional_f64<'de, D>(deserializer: D) -> Result<Option<f64>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let opt = Option::<String>::deserialize(deserializer)?;
    opt.map(|raw| {
        let trimmed = raw.trim();
        if trimmed.is_empty() {
            return Err(serde::de::Error::custom("expected number"));
        }
        trimmed
            .parse::<f64>()
            .map_err(|_| serde::de::Error::custom("expected number"))
    })
    .transpose()
}

fn load_target_wallets() -> Result<Vec<TargetWalletConfig>, ConfigError> {
    let mut wallets = Vec::new();
    let mut index = 1;

    loop {
        let wallet_key = format!("TARGET_WALLET{index}");
        let wallet_value = match env::var(&wallet_key) {
            Ok(value) => value,
            Err(env::VarError::NotPresent) => break,
            Err(err) => return Err(ConfigError::EnvVar(wallet_key, err)),
        };

        let slippage_key = format!("{}_SLIPPAGE_PCT", wallet_key);
        let slippage_value = match env::var(&slippage_key) {
            Ok(value) => value,
            Err(env::VarError::NotPresent) => {
                return Err(ConfigError::MissingTargetField(slippage_key));
            }
            Err(err) => return Err(ConfigError::EnvVar(slippage_key, err)),
        };

        let wallet_pubkey = Pubkey::from_str(wallet_value.trim())
            .map_err(|e| ConfigError::Pubkey(wallet_value.clone(), e))?;
        let slippage_pct = slippage_value
            .trim()
            .parse::<f64>()
            .map_err(|_| ConfigError::InvalidSlippage(slippage_value.clone()))?;

        let mirror_key = format!("{}_MIRROR_SELLS", wallet_key);
        let mirror_sells = match env::var(&mirror_key) {
            Ok(value) => parse_bool(&mirror_key, &value)?,
            Err(env::VarError::NotPresent) => true,
            Err(err) => return Err(ConfigError::EnvVar(mirror_key, err)),
        };

        let take_profit_key = format!("{}_TAKE_PROFIT", wallet_key);
        let take_profit_pct = match env::var(&take_profit_key) {
            Ok(value) => parse_optional_percentage(&take_profit_key, &value)?,
            Err(env::VarError::NotPresent) => None,
            Err(err) => return Err(ConfigError::EnvVar(take_profit_key, err)),
        };

        let stop_loss_key = format!("{}_STOP_LOSS", wallet_key);
        let stop_loss_pct = match env::var(&stop_loss_key) {
            Ok(value) => parse_optional_percentage(&stop_loss_key, &value)?,
            Err(env::VarError::NotPresent) => None,
            Err(err) => return Err(ConfigError::EnvVar(stop_loss_key, err)),
        };

        wallets.push(TargetWalletConfig {
            wallet: wallet_pubkey,
            slippage_pct,
            mirror_sells,
            take_profit_pct,
            stop_loss_pct,
        });

        index += 1;
    }

    Ok(wallets)
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_config() -> Config {
        Config {
            env_path: PathBuf::new(),
            operator: Arc::new(Keypair::new()),
            buy_amount_sol: 1.0,
            priority_fees: 0.001,
            tx_tip_sol: 0.002,
            buy_priority_fees: 0.003,
            sell_priority_fees: 0.004,
            buy_tx_tip_sol: 0.005,
            sell_tx_tip_sol: 0.006,
            astralane_api_key: String::new(),
            blockrazor_api_key: String::new(),
            stellium_api_key: String::new(),
            flashblock_api_key: String::new(),
            nonce_accounts: vec![],
            grpc_endpoint: String::new(),
            grpc_x_token: None,
            rpc_url: String::new(),
            target_wallets: vec![],
            zero_slot_api_key: String::new(),
        }
    }

    #[test]
    fn per_side_fee_helpers_use_overrides() {
        let config = sample_config();
        assert_eq!(
            config.buy_compute_unit_price_microlamports(100_000),
            super::compute_unit_price_for_fee(0.003, 100_000)
        );
        assert_eq!(
            config.sell_compute_unit_price_microlamports(200_000),
            super::compute_unit_price_for_fee(0.004, 200_000)
        );
        assert_eq!(config.buy_tx_tip_lamports(), sol_to_lamports(0.005));
        assert_eq!(config.sell_tx_tip_lamports(), sol_to_lamports(0.006));
    }

    #[test]
    fn default_fee_helpers_remain_available() {
        let config = sample_config();
        assert_eq!(
            config.compute_unit_price_microlamports(150_000),
            super::compute_unit_price_for_fee(0.001, 150_000)
        );
        assert_eq!(config.tx_tip_lamports(), sol_to_lamports(0.002));
    }
}

#[derive(Error, Debug)]
pub enum ConfigError {
    #[error("could not determine working directory for {0}")]
    Io(String, #[source] std::io::Error),
    #[error("missing .env at {0}")]
    MissingEnv(PathBuf),
    #[error("failed to parse .env file")]
    Dotenv,
    #[error("invalid private key")]
    InvalidPrivateKey,
    #[error("pubkey parse error for {0}")]
    Pubkey(String, #[source] solana_sdk::pubkey::ParsePubkeyError),
    #[error("serialization error: {0}")]
    Serde(String),
    #[error("env var {0} error")]
    EnvVar(String, env::VarError),
    #[error("missing target wallet field {0}")]
    MissingTargetField(String),
    #[error("invalid slippage percentage: {0}")]
    InvalidSlippage(String),
    #[error("invalid boolean value {value} for {key}")]
    InvalidBoolean { key: String, value: String },
    #[error("invalid percentage value {value} for {key}")]
    InvalidPercentage { key: String, value: String },
}

impl ConfigError {
    pub fn missing_env_path(&self) -> Option<&Path> {
        match self {
            ConfigError::MissingEnv(path) => Some(path.as_path()),
            _ => None,
        }
    }
}
</file>

<file path="copytrade.rs">
#![allow(dead_code)]

use std::{
    collections::{hash_map::Entry, HashMap, HashSet},
    fs,
    path::{Path, PathBuf},
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc, Mutex, Weak,
    },
    thread,
    time::{Duration, Instant},
};
use tokio::{sync::mpsc, time::sleep};

use base64::{engine::general_purpose::STANDARD as BASE64_ENGINE, Engine as _};
use bs58;
use futures::future;
use log::{debug, info, warn};
use serde_json::{json, Value};
use solana_sdk::{
    instruction::Instruction,
    message::{Message, VersionedMessage},
    pubkey::Pubkey,
    signature::{Signer, SignerError},
    transaction::VersionedTransaction,
};
use spl_associated_token_account::get_associated_token_address_with_program_id;
use spl_token::native_mint;
use thiserror::Error;
use yellowstone_grpc_proto::{
    prelude::{SubscribeUpdateTransaction, SubscribeUpdateTransactionInfo},
    solana::storage::confirmed_block,
};

use crate::{
    config::{Config, TargetWalletConfig},
    executor::{ExecutionError, ExecutionPipeline, ProcessorEndpoint},
    nonce::{NonceError, NonceManager, PreparedNonce, TxExecutionPlan},
    parsers::{
        pump_amm::{PumpAmmEvent, PumpAmmInstruction},
        pump_fun::{PumpFunEvent, PumpFunInstruction},
        ParsedEvent, ParsedInstruction,
    },
    swap::{
        common::{compute_pump_amm_price, compute_pump_fun_price},
        constants::{
            buy_quote_input_internal, get_buy_token_amount_from_sol_amount,
            get_sell_sol_amount_from_token_amount, sell_base_input_internal, Fees,
        },
        pump::{
            self, user_volume_accumulator_pda as pump_fun_volume_pda, BuyExactSolInAccounts,
            PumpFunBuyTxRequest, PumpFunCommonTxParams, PumpFunSellTxRequest, PumpFunTxBuilder,
            PumpTransactionBuilderError, SellAccounts as PumpFunSellAccounts,
        },
        pump_amm::{
            self, user_volume_accumulator_pda as pump_amm_volume_pda, BuyExactQuoteInAccounts,
            PumpAmmBuilderError, PumpAmmBuyTxRequest, PumpAmmCommonTxParams, PumpAmmSellTxRequest,
            PumpAmmTxBuilder, SellAccounts as PumpAmmSellAccounts,
        },
    },
    transaction_processor::{
        ParsedInstructionWithContext, ParsedTransaction, TokenBalanceChange, TokenBalanceKey,
    },
};

const DEFAULT_TOKEN_DECIMALS: u8 = 6;
const PUMP_FUN_CU_LIMIT: u32 = 100_000;
const PUMP_AMM_CU_LIMIT: u32 = 180_000;
const CONFIRMATION_TIMEOUT_SECS: u64 = 15;
const MIN_TARGET_SOL_LAMPORTS: u64 = 1000; // 0.000001 SOL
const NONCE_REFRESH_DELAY_MS: u64 = 700;
const DEAD_TRADE_WINDOW_SECS: u64 = 60;
const DEAD_TRADE_THRESHOLD_PCT: f64 = 3.0;

pub struct CopyTrader {
    config: Arc<Config>,
    execution: Option<Arc<CopyTradeRuntime>>,
    execution_enabled: bool,
    targets: HashMap<Pubkey, WalletTargetState>,
    position_index: PositionIndex,
    pump_fun: PumpFunTracker,
    pump_amm: PumpAmmTracker,
    operator: OperatorState,
    parsing_time_us: u64,
    grpc_dump: Option<Arc<GrpcDump>>,
}

pub enum TraderMessage {
    ProcessTransaction {
        parsed_tx: Box<ParsedTransaction>,
        confirmation: Option<PendingConfirmation>,
        update: Option<SubscribeUpdateTransaction>,
    },
}

#[derive(Debug, Default, Clone, Copy)]
pub struct HandleResult {
    pub target_event_mismatch: bool,
}

impl CopyTrader {
    pub async fn run(mut self, mut receiver: mpsc::Receiver<TraderMessage>) {
        while let Some(message) = receiver.recv().await {
            match message {
                TraderMessage::ProcessTransaction {
                    parsed_tx,
                    confirmation,
                    update,
                } => {
                    if let Some(ref pending) = confirmation {
                        self.handle_operator_confirmation(pending, &parsed_tx);
                    }
                    let handle_result = self.handle_parsed_transaction(&parsed_tx);
                    if handle_result.target_event_mismatch {
                        if let (Some(dump), Some(update)) = (self.grpc_dump.as_ref(), update) {
                            if let Err(err) = dump.dump_failed_transaction(&update, &parsed_tx) {
                                warn!("Failed to dump gRPC transaction: {err:?}");
                            }
                        }
                    }
                }
            }
        }
    }

    pub fn set_execution_enabled(&mut self, enabled: bool) {
        self.execution_enabled = enabled && self.execution.is_some();
    }

    pub fn new(
        config: Arc<Config>,
        execution: Option<Arc<CopyTradeRuntime>>,
        grpc_dump: Option<Arc<GrpcDump>>,
    ) -> Self {
        let mut targets = HashMap::new();
        let target_configs = config.target_wallets.clone();
        for target in target_configs {
            targets.insert(target.wallet, WalletTargetState::new(target));
        }

        let operator_wallet = config.operator_pubkey();
        Self {
            config,
            execution_enabled: execution.is_some(),
            execution,
            targets,
            position_index: PositionIndex::default(),
            pump_fun: PumpFunTracker::new(),
            pump_amm: PumpAmmTracker::new(),
            operator: OperatorState::new(operator_wallet),
            parsing_time_us: 0,
            grpc_dump,
        }
    }

    pub fn handle_parsed_transaction(&mut self, parsed_tx: &ParsedTransaction) -> HandleResult {
        self.parsing_time_us = parsed_tx.total_parsing_time_us;
        let balance_index = TokenBalanceIndex::new(&parsed_tx.token_balances);
        let instruction_index = InstructionIndex::new(&parsed_tx.instructions);
        let mut result = HandleResult::default();
        for instruction in &parsed_tx.instructions {
            self.handle_instruction(instruction);
        }
        for event in &parsed_tx.events {
            if self.handle_event_with_balances(
                event,
                &balance_index,
                &instruction_index,
                parsed_tx.compute_units_consumed,
            ) {
                result.target_event_mismatch = true;
            }
        }
        result
    }

    pub fn handle_operator_transaction(&mut self, parsed_tx: &ParsedTransaction) {
        if parsed_tx.events.is_empty() {
            return;
        }
        let balance_index = TokenBalanceIndex::new(&parsed_tx.token_balances);
        let instruction_index = InstructionIndex::new(&parsed_tx.instructions);
        for event in &parsed_tx.events {
            self.update_operator_from_event(event, &balance_index, &instruction_index);
        }
    }

    pub fn handle_operator_confirmation(
        &mut self,
        pending: &PendingConfirmation,
        parsed_tx: &ParsedTransaction,
    ) {
        self.handle_operator_transaction(parsed_tx);
        self.apply_operator_fill(pending, parsed_tx);
        self.update_tp_sl_position_after_confirmation(pending, parsed_tx);
        self.cleanup_tp_sl_after_confirmation(pending, parsed_tx);
        if let Some(runtime) = self.execution.as_ref() {
            runtime.handle_confirmed_transaction(pending);
        }
    }

    fn update_tp_sl_position_after_confirmation(
        &mut self,
        pending: &PendingConfirmation,
        parsed_tx: &ParsedTransaction,
    ) {
        let should_track = self
            .targets
            .get(&pending.target)
            .map(|state| !state.config.mirror_sells)
            .unwrap_or(false);
        if !should_track {
            return;
        }
        let buy_info = match pending.protocol {
            TradeProtocol::PumpFun => self.extract_pump_fun_buy(pending, parsed_tx),
            TradeProtocol::PumpAmm => self.extract_pump_amm_buy(pending, parsed_tx),
        };
        let Some((buy_price, tokens_bought)) = buy_info else {
            return;
        };
        let operator_total_after = self.operator.total_tokens(&pending.mint);
        if let Some(target) = self.targets.get_mut(&pending.target) {
            let inserted = CopyTrader::upsert_tp_sl_position(
                target,
                pending.mint,
                buy_price,
                tokens_bought,
                pending.protocol,
                operator_total_after,
            );
            if inserted {
                self.position_index
                    .insert(pending.mint, target.config.wallet);
            }
        }
    }

    fn upsert_tp_sl_position(
        target: &mut WalletTargetState,
        mint: Pubkey,
        buy_price: f64,
        tokens_bought: u64,
        protocol: TradeProtocol,
        operator_total_after: u64,
    ) -> bool {
        if buy_price <= 0.0 {
            return false;
        }
        let previous_tokens = operator_total_after.saturating_sub(tokens_bought);
        let take_profit_pct = target.config.take_profit_pct;
        let stop_loss_pct = target.config.stop_loss_pct;
        let mut was_new = false;
        let entry = match target.tp_sl_positions.entry(mint) {
            Entry::Occupied(entry) => entry.into_mut(),
            Entry::Vacant(vacant) => {
                was_new = true;
                vacant.insert(TpSlPosition::new(
                    protocol,
                    buy_price,
                    take_profit_pct,
                    stop_loss_pct,
                ))
            }
        };
        if previous_tokens == 0 {
            entry.buy_price = buy_price;
        } else {
            entry.record_additional_buy(previous_tokens, tokens_bought, buy_price);
        }
        entry.pending_sell = false;
        entry.last_log_at = Instant::now();
        log_tp_sl_targets(
            target.config.wallet,
            mint,
            entry.buy_price,
            entry.tp_price(),
            entry.sl_price(),
        );
        was_new
    }

    fn cleanup_tp_sl_after_confirmation(
        &mut self,
        pending: &PendingConfirmation,
        parsed_tx: &ParsedTransaction,
    ) {
        let Some(target) = self.targets.get_mut(&pending.target) else {
            return;
        };
        let operator = self.config.operator_pubkey();
        let sold = match pending.protocol {
            TradeProtocol::PumpFun => parsed_tx.events.iter().any(|event| {
                if let ParsedEvent::PumpFun(ev) = event {
                    matches!(ev, PumpFunEvent::TradeEvent { is_buy: false, user, mint, .. } if *user == operator && *mint == pending.mint)
                } else {
                    false
                }
            }),
            TradeProtocol::PumpAmm => parsed_tx.events.iter().any(|event| {
                if let ParsedEvent::PumpAmm(ev) = event {
                    matches!(ev, PumpAmmEvent::SellEvent { user, .. } if *user == operator)
                } else {
                    false
                }
            }),
        };
        if sold || self.operator.total_tokens(&pending.mint) == 0 {
            if target.tp_sl_positions.remove(&pending.mint).is_some() {
                self.position_index
                    .remove(&pending.mint, &target.config.wallet);
            }
        }
    }

    fn extract_pump_fun_buy(
        &self,
        pending: &PendingConfirmation,
        parsed_tx: &ParsedTransaction,
    ) -> Option<(f64, u64)> {
        let operator = self.config.operator_pubkey();
        parsed_tx.events.iter().find_map(|event| {
            if let ParsedEvent::PumpFun(PumpFunEvent::TradeEvent {
                is_buy,
                user,
                mint,
                virtual_sol_reserves,
                virtual_token_reserves,
                token_amount,
                ..
            }) = event
            {
                if !*is_buy || user != &operator || mint != &pending.mint {
                    return None;
                }
                return compute_pump_fun_price(*virtual_sol_reserves, *virtual_token_reserves)
                    .map(|price| (price, *token_amount));
            }
            None
        })
    }

    fn extract_pump_amm_buy(
        &self,
        _pending: &PendingConfirmation,
        parsed_tx: &ParsedTransaction,
    ) -> Option<(f64, u64)> {
        let operator = self.config.operator_pubkey();
        parsed_tx.events.iter().find_map(|event| {
            if let ParsedEvent::PumpAmm(ev) = event {
                match ev {
                    PumpAmmEvent::BuyEvent {
                        user,
                        pool_base_token_reserves,
                        pool_quote_token_reserves,
                        base_amount_out,
                        ..
                    } if *user == operator => {
                        let price = compute_pump_amm_price(
                            (*pool_base_token_reserves).into(),
                            (*pool_quote_token_reserves).into(),
                        );
                        Some((price, *base_amount_out))
                    }
                    _ => None,
                }
            } else {
                None
            }
        })
    }

    fn process_pump_fun_tp_sl(
        &mut self,
        event: &PumpFunEvent,
        instructions: &InstructionIndex<'_>,
    ) -> bool {
        let PumpFunEvent::TradeEvent {
            mint,
            virtual_sol_reserves,
            virtual_token_reserves,
            ..
        } = event;
        let Some(price) = compute_pump_fun_price(*virtual_sol_reserves, *virtual_token_reserves)
        else {
            return false;
        };
        if price <= 0.0 {
            return false;
        }
        let slot = event_slot(event);
        let operator = self.config.operator_pubkey();
        let mut mismatch = false;
        let mut actions: Vec<TpSlAction> = Vec::new();
        let target_wallets = self.position_index.targets_for(mint);
        if target_wallets.is_empty() {
            return mismatch;
        }
        for wallet in target_wallets {
            let Some(target) = self.targets.get_mut(&wallet) else {
                self.position_index.remove(mint, &wallet);
                continue;
            };
            if target.config.mirror_sells {
                continue;
            }
            if let Some(position) = target.tp_sl_positions.get_mut(mint) {
                let pct_change = position.percentage_change(price);
                if position.should_log() {
                    log_tp_sl_status(target.config.wallet, *mint, position, price, pct_change);
                    position.mark_logged();
                }
                if position.pending_sell {
                    continue;
                }
                let mut exit_trigger = None;
                if position.should_force_exit(
                    price,
                    DEAD_TRADE_THRESHOLD_PCT,
                    Duration::from_secs(DEAD_TRADE_WINDOW_SECS),
                ) {
                    exit_trigger = Some(TpSlTrigger::Stagnation);
                } else if let Some(trigger) = position.evaluate_trigger(pct_change) {
                    exit_trigger = Some(trigger);
                }
                if let Some(trigger) = exit_trigger {
                    let operator_tokens = self.operator.total_tokens(mint);
                    if operator_tokens == 0 {
                        if target.tp_sl_positions.remove(mint).is_some() {
                            self.position_index.remove(mint, &target.config.wallet);
                        }
                        continue;
                    }
                    let Some(mut accounts) = pump_fun_sell_accounts_from_event(event, instructions)
                    else {
                        mismatch = true;
                        continue;
                    };
                    retarget_pump_fun_sell_accounts(&mut accounts, &operator);
                    let payload = PumpFunSellPayload {
                        accounts,
                        amount: operator_tokens,
                        virtual_token_reserves: (*virtual_token_reserves).into(),
                        virtual_sol_reserves: (*virtual_sol_reserves).into(),
                    };
                    let expected_sol = get_sell_sol_amount_from_token_amount(
                        (*virtual_token_reserves).into(),
                        (*virtual_sol_reserves).into(),
                        operator_tokens,
                    );
                    let signal = ExecutionSignal::pump_fun_sell(
                        target.config.clone(),
                        slot,
                        expected_sol,
                        operator_tokens,
                        ExecutionPayload::PumpFunSell(payload),
                        self.parsing_time_us,
                        None,
                    );
                    position.pending_sell = true;
                    position.mark_logged();
                    actions.push(TpSlAction {
                        signal,
                        target_wallet: target.config.wallet,
                        mint: *mint,
                        trigger,
                        current_price: price,
                        pct_change,
                    });
                }
            }
        }
        for action in actions {
            log_tp_sl_trigger(
                action.target_wallet,
                action.mint,
                action.trigger,
                action.current_price,
                action.pct_change,
            );
            self.emit_execution_signal(action.signal);
        }
        mismatch
    }

    fn process_pump_amm_tp_sl(
        &mut self,
        event: &PumpAmmEvent,
        instructions: &InstructionIndex<'_>,
    ) -> bool {
        let slot = event_slot(event);
        let (base_reserve_u64, quote_reserve_u64, lp_fee_bps, protocol_fee_bps, coin_fee_bps) =
            match event {
                PumpAmmEvent::BuyEvent {
                    pool_base_token_reserves,
                    pool_quote_token_reserves,
                    lp_fee_basis_points,
                    protocol_fee_basis_points,
                    coin_creator_fee_basis_points,
                    ..
                }
                | PumpAmmEvent::SellEvent {
                    pool_base_token_reserves,
                    pool_quote_token_reserves,
                    lp_fee_basis_points,
                    protocol_fee_basis_points,
                    coin_creator_fee_basis_points,
                    ..
                } => (
                    *pool_base_token_reserves,
                    *pool_quote_token_reserves,
                    *lp_fee_basis_points,
                    *protocol_fee_basis_points,
                    *coin_creator_fee_basis_points,
                ),
            };
        if base_reserve_u64 == 0 || quote_reserve_u64 == 0 {
            return false;
        }
        let price = compute_pump_amm_price(base_reserve_u64 as u128, quote_reserve_u64 as u128);
        if price <= 0.0 {
            return false;
        }
        let Some((base_accounts, base_mint)) =
            pump_amm_sell_accounts_from_event(event, instructions)
        else {
            return true;
        };
        let fees = Fees {
            lp_fee_bps: (lp_fee_bps.min(u16::MAX as u64)) as u16,
            protocol_fee_bps: (protocol_fee_bps.min(u16::MAX as u64)) as u16,
            coin_creator_fee_bps: (coin_fee_bps.min(u16::MAX as u64)) as u16,
        };
        let operator = self.config.operator_pubkey();
        let mut mismatch = false;
        let mut actions: Vec<TpSlAction> = Vec::new();
        let target_wallets = self.position_index.targets_for(&base_mint);
        if target_wallets.is_empty() {
            return mismatch;
        }
        for wallet in target_wallets {
            let Some(target) = self.targets.get_mut(&wallet) else {
                self.position_index.remove(&base_mint, &wallet);
                continue;
            };
            if target.config.mirror_sells {
                continue;
            }
            if let Some(position) = target.tp_sl_positions.get_mut(&base_mint) {
                let pct_change = position.percentage_change(price);
                if position.should_log() {
                    log_tp_sl_status(target.config.wallet, base_mint, position, price, pct_change);
                    position.mark_logged();
                }
                if position.pending_sell {
                    continue;
                }
                let mut exit_trigger = None;
                if position.should_force_exit(
                    price,
                    DEAD_TRADE_THRESHOLD_PCT,
                    Duration::from_secs(DEAD_TRADE_WINDOW_SECS),
                ) {
                    exit_trigger = Some(TpSlTrigger::Stagnation);
                } else if let Some(trigger) = position.evaluate_trigger(pct_change) {
                    exit_trigger = Some(trigger);
                }
                if let Some(trigger) = exit_trigger {
                    let operator_tokens = self.operator.total_tokens(&base_mint);
                    if operator_tokens == 0 {
                        if target.tp_sl_positions.remove(&base_mint).is_some() {
                            self.position_index
                                .remove(&base_mint, &target.config.wallet);
                        }
                        continue;
                    }
                    let mut accounts = base_accounts.clone();
                    retarget_pump_amm_sell_accounts(&mut accounts, &operator);
                    let slippage_bps = slippage_pct_to_bps(target.config.slippage_pct) as u64;
                    let quote_result = match sell_base_input_internal(
                        operator_tokens,
                        slippage_bps,
                        base_reserve_u64,
                        quote_reserve_u64,
                        fees,
                    ) {
                        Ok(result) => result,
                        Err(err) => {
                            warn!("Pump AMM TP/SL math failed for mint {}: {err}", base_mint);
                            mismatch = true;
                            continue;
                        }
                    };
                    let payload = PumpAmmSellPayload {
                        accounts,
                        base_amount_in: operator_tokens,
                        base_reserve: base_reserve_u64,
                        quote_reserve: quote_reserve_u64,
                        fees,
                        expected_sol_out: quote_result.ui_quote,
                    };
                    let signal = ExecutionSignal::pump_amm_sell(
                        target.config.clone(),
                        slot,
                        quote_result.ui_quote,
                        operator_tokens,
                        ExecutionPayload::PumpAmmSell(payload),
                        self.parsing_time_us,
                        None,
                    );
                    position.pending_sell = true;
                    position.mark_logged();
                    actions.push(TpSlAction {
                        signal,
                        target_wallet: target.config.wallet,
                        mint: base_mint,
                        trigger,
                        current_price: price,
                        pct_change,
                    });
                }
            }
        }
        for action in actions {
            log_tp_sl_trigger(
                action.target_wallet,
                action.mint,
                action.trigger,
                action.current_price,
                action.pct_change,
            );
            self.emit_execution_signal(action.signal);
        }
        mismatch
    }

    pub fn handle_event(&mut self, event: &ParsedEvent) {
        let empty = TokenBalanceIndex::empty();
        let instructions = InstructionIndex::empty();
        let _ = self.handle_event_with_balances(event, &empty, &instructions, None);
    }

    fn emit_execution_signal(&self, signal: ExecutionSignal) {
        if !self.execution_enabled {
            return;
        }
        let runtime = match self.execution.as_ref() {
            Some(runtime) => Arc::clone(runtime),
            None => return,
        };

        tokio::spawn(async move {
            if let Err(err) = runtime.execute(signal).await {
                warn!("Execution pipeline failed: {err}");
            }
        });
    }

    fn handle_event_with_balances(
        &mut self,
        event: &ParsedEvent,
        balances: &TokenBalanceIndex<'_>,
        instructions: &InstructionIndex<'_>,
        compute_units_consumed: Option<u64>,
    ) -> bool {
        match event {
            ParsedEvent::PumpFun(ev) => {
                self.pump_fun.handle_event(ev);
                let tp_sl_mismatch = self.process_pump_fun_tp_sl(ev, instructions);
                let target_mismatch = self.update_pump_fun_targets(
                    ev,
                    balances,
                    instructions,
                    compute_units_consumed,
                );
                tp_sl_mismatch || target_mismatch
            }
            ParsedEvent::PumpAmm(ev) => {
                self.pump_amm.handle_event(ev);
                let tp_sl_mismatch = self.process_pump_amm_tp_sl(ev, instructions);
                let target_mismatch = self.update_pump_amm_targets(
                    ev,
                    balances,
                    instructions,
                    compute_units_consumed,
                );
                tp_sl_mismatch || target_mismatch
            }
            ParsedEvent::Log { .. } => false,
        }
    }

    fn update_operator_from_event(
        &mut self,
        event: &ParsedEvent,
        balances: &TokenBalanceIndex<'_>,
        _instructions: &InstructionIndex<'_>,
    ) {
        match event {
            ParsedEvent::PumpFun(ev) => match ev {
                PumpFunEvent::TradeEvent {
                    user,
                    mint,
                    sol_amount,
                    token_amount,
                    ..
                } => {
                    if user != &self.operator.wallet {
                        return;
                    }
                    let slot = event_slot(ev);
                    Self::apply_base_token_update(
                        &mut self.operator.pump_fun,
                        balances.by_owner_mint(user, mint),
                        slot,
                        Some(*token_amount),
                        Some(*mint),
                    );
                    Self::apply_quote_update(
                        &mut self.operator.pump_fun,
                        balances.native_balance_for_owner(user),
                        slot,
                        Some(*sol_amount),
                    );
                }
            },
            ParsedEvent::PumpAmm(ev) => match ev {
                PumpAmmEvent::BuyEvent {
                    user,
                    user_base_token_account,
                    user_quote_token_account,
                    base_amount_out,
                    user_quote_amount_in,
                    ..
                } => {
                    if user != &self.operator.wallet {
                        return;
                    }
                    let slot = event_slot(ev);
                    Self::apply_base_token_update(
                        &mut self.operator.pump_amm,
                        balances.by_token_account(user_base_token_account),
                        slot,
                        Some(*base_amount_out),
                        None,
                    );
                    Self::apply_quote_update(
                        &mut self.operator.pump_amm,
                        balances.by_token_account(user_quote_token_account),
                        slot,
                        Some(*user_quote_amount_in),
                    );
                }
                PumpAmmEvent::SellEvent {
                    user,
                    user_base_token_account,
                    user_quote_token_account,
                    base_amount_in,
                    user_quote_amount_out,
                    ..
                } => {
                    if user != &self.operator.wallet {
                        return;
                    }
                    let slot = event_slot(ev);
                    Self::apply_base_token_update(
                        &mut self.operator.pump_amm,
                        balances.by_token_account(user_base_token_account),
                        slot,
                        Some(*base_amount_in),
                        None,
                    );
                    Self::apply_quote_update(
                        &mut self.operator.pump_amm,
                        balances.by_token_account(user_quote_token_account),
                        slot,
                        Some(*user_quote_amount_out),
                    );
                }
            },
            ParsedEvent::Log { .. } => {}
        }
    }

    pub fn handle_instruction(&mut self, instruction: &ParsedInstructionWithContext) {
        match &instruction.instruction {
            ParsedInstruction::PumpFun(ref pf) => {
                self.pump_fun.handle_instruction(pf);
            }
            ParsedInstruction::PumpAmm(ref pa) => {
                self.pump_amm.handle_instruction(pa);
            }
            ParsedInstruction::Unknown { .. } => {}
        }
    }

    pub fn is_target_wallet(&self, wallet: &Pubkey) -> bool {
        self.targets.contains_key(wallet)
    }

    pub fn wallet_snapshot(&self, wallet: &Pubkey) -> Option<WalletSnapshot> {
        self.targets.get(wallet).map(|state| state.snapshot())
    }

    pub fn pump_fun_snapshot(&self, wallet: &Pubkey) -> Option<PumpFunSnapshot> {
        self.pump_fun
            .holdings
            .get(wallet)
            .map(|state| state.snapshot())
    }

    pub fn pump_amm_snapshot(&self, wallet: &Pubkey) -> Option<PumpAmmSnapshot> {
        self.pump_amm
            .holdings
            .get(wallet)
            .map(|state| state.snapshot())
    }

    fn update_pump_fun_targets(
        &mut self,
        event: &PumpFunEvent,
        balances: &TokenBalanceIndex<'_>,
        instructions: &InstructionIndex<'_>,
        compute_units_consumed: Option<u64>,
    ) -> bool {
        let PumpFunEvent::TradeEvent {
            user,
            mint,
            sol_amount,
            token_amount,
            is_buy,
            virtual_token_reserves,
            virtual_sol_reserves,
            real_token_reserves,
            ..
        } = event;

        let Some(target) = self.targets.get_mut(user) else {
            return false;
        };

        if *is_buy {
            info!(
                "Target {} bought {:.4} tokens for {:.4} SOL (mint {})",
                user,
                tokens_to_amount(*token_amount),
                lamports_to_sol(*sol_amount),
                mint
            );
        }

        let slot = event_slot(event);
        Self::apply_base_token_update(
            &mut target.pump_fun,
            balances.by_owner_mint(user, mint),
            slot,
            Some(*token_amount),
            Some(*mint),
        );
        Self::apply_quote_update(
            &mut target.pump_fun,
            balances.native_balance_for_owner(user),
            slot,
            Some(*sol_amount),
        );

        let payload = match build_pump_fun_payload(event, instructions) {
            Some(payload) => payload,
            None => return true,
        };

        match (*is_buy, payload) {
            (true, ExecutionPayload::PumpFunBuy(mut buy_payload)) => {
                if *sol_amount < MIN_TARGET_SOL_LAMPORTS {
                    debug!(
                        "Skipping PumpFun buy mirror for {} due to small spend {} lamports",
                        user, sol_amount
                    );
                    return false;
                }
                let mut spend = self.config.buy_amount_lamports();
                if spend == 0 {
                    spend = *sol_amount;
                    debug!(
                        "BUY_AMOUNT_SOL not configured; mirroring target spend {} lamports",
                        spend
                    );
                }
                if spend == 0 {
                    return false;
                }
                target
                    .pump_fun_positions
                    .record_target_buy(*mint, *token_amount);
                if target.config.mirror_sells {
                    target
                        .mirror_positions
                        .record_target_buy(*mint, *token_amount);
                }
                let operator_tokens = get_buy_token_amount_from_sol_amount(
                    (*virtual_token_reserves).into(),
                    (*virtual_sol_reserves).into(),
                    (*real_token_reserves).into(),
                    spend,
                );
                if operator_tokens == 0 {
                    return false;
                }
                info!(
                    "Buying {:.4} tokens for {:.4} SOL (mint {}, target {})",
                    tokens_to_amount(operator_tokens),
                    lamports_to_sol(spend),
                    mint,
                    user
                );
                buy_payload.spendable_sol_in = spend;
                let signal = ExecutionSignal::pump_fun_buy(
                    target.config.clone(),
                    slot,
                    spend,
                    operator_tokens,
                    ExecutionPayload::PumpFunBuy(buy_payload),
                    self.parsing_time_us,
                    compute_units_consumed,
                );
                self.emit_execution_signal(signal);
                false
            }
            (false, ExecutionPayload::PumpFunSell(mut sell_payload)) => {
                if !target.config.mirror_sells {
                    return false;
                }
                let operator_available = self.operator.total_tokens(mint);
                let sell_tokens =
                    target
                        .mirror_positions
                        .plan_sell(*mint, *token_amount, operator_available);
                if sell_tokens == 0 {
                    return false;
                }
                let target_holdings_pre = balances
                    .by_owner_mint(user, mint)
                    .and_then(|change| change.pre_amount)
                    .unwrap_or(0);
                let target_pct = if target_holdings_pre > 0 {
                    (*token_amount as f64 / target_holdings_pre as f64) * 100.0
                } else {
                    0.0
                };
                let operator_pct = if operator_available > 0 {
                    (sell_tokens as f64 / operator_available as f64) * 100.0
                } else {
                    0.0
                };
                info!(
                    "Target {} sold {:.4} tokens for {:.4} SOL (sold {:.2}% of position); mirroring {:.2}% of operator holdings (mint {})",
                    user,
                    tokens_to_amount(*token_amount),
                    lamports_to_sol(*sol_amount),
                    target_pct,
                    operator_pct,
                    mint
                );
                sell_payload.amount = sell_tokens;
                let expected_sol = get_sell_sol_amount_from_token_amount(
                    (*virtual_token_reserves).into(),
                    (*virtual_sol_reserves).into(),
                    sell_tokens,
                );
                let signal = ExecutionSignal::pump_fun_sell(
                    target.config.clone(),
                    slot,
                    expected_sol,
                    sell_tokens,
                    ExecutionPayload::PumpFunSell(sell_payload),
                    self.parsing_time_us,
                    compute_units_consumed,
                );
                self.emit_execution_signal(signal);
                false
            }
            (_, other) => {
                debug!("Unexpected PumpFun payload variant: {:?}", other);
                false
            }
        }
    }

    fn update_pump_amm_targets(
        &mut self,
        event: &PumpAmmEvent,
        balances: &TokenBalanceIndex<'_>,
        instructions: &InstructionIndex<'_>,
        compute_units_consumed: Option<u64>,
    ) -> bool {
        match event {
            PumpAmmEvent::BuyEvent {
                user,
                user_base_token_account,
                user_quote_token_account,
                base_amount_out,
                user_quote_amount_in,
                ..
            } => {
                let Some(target) = self.targets.get_mut(user) else {
                    return false;
                };
                if *user_quote_amount_in < MIN_TARGET_SOL_LAMPORTS {
                    debug!(
                        "Skipping PumpAmm buy mirror for {} due to small spend {} lamports",
                        user, user_quote_amount_in
                    );
                    return false;
                }
                let slot = event_slot(event);
                Self::apply_base_token_update(
                    &mut target.pump_amm,
                    balances.by_token_account(user_base_token_account),
                    slot,
                    Some(*base_amount_out),
                    None,
                );
                Self::apply_quote_update(
                    &mut target.pump_amm,
                    balances.by_token_account(user_quote_token_account),
                    slot,
                    Some(*user_quote_amount_in),
                );
                let mut payload = match build_pump_amm_buy_payload(event, instructions) {
                    Some(ExecutionPayload::PumpAmmBuy(payload)) => payload,
                    Some(other) => {
                        debug!("Unexpected Pump AMM buy payload variant: {:?}", other);
                        return false;
                    }
                    None => return true,
                };
                info!(
                    "Target {} bought {:.4} tokens for {:.4} SOL (pool {})",
                    user,
                    tokens_to_amount(*base_amount_out),
                    lamports_to_sol(*user_quote_amount_in),
                    payload.accounts.pool
                );
                target
                    .pump_amm_positions
                    .record_target_buy(payload.accounts.base_mint, *base_amount_out);
                if target.config.mirror_sells {
                    target
                        .mirror_positions
                        .record_target_buy(payload.accounts.base_mint, *base_amount_out);
                }
                let mut spend = self.config.buy_amount_lamports();
                if spend == 0 {
                    spend = *user_quote_amount_in;
                    debug!(
                        "BUY_AMOUNT_SOL not configured; mirroring target spend {} lamports",
                        spend
                    );
                }
                if spend == 0 {
                    return false;
                }
                let operator_tokens = match buy_quote_input_internal(
                    spend,
                    0,
                    payload.base_reserve,
                    payload.quote_reserve,
                    payload.fees,
                ) {
                    Ok(result) => result.base,
                    Err(err) => {
                        warn!("Pump AMM buy math failed: {err}");
                        return false;
                    }
                };
                if operator_tokens == 0 {
                    return false;
                }
                info!(
                    "Buying {:.4} tokens for {:.4} SOL (pool {}, target {})",
                    tokens_to_amount(operator_tokens),
                    lamports_to_sol(spend),
                    payload.accounts.pool,
                    user
                );
                payload.spendable_quote_in = spend;
                let signal = ExecutionSignal::pump_amm_buy(
                    target.config.clone(),
                    slot,
                    spend,
                    operator_tokens,
                    ExecutionPayload::PumpAmmBuy(payload),
                    self.parsing_time_us,
                    compute_units_consumed,
                );
                self.emit_execution_signal(signal);
                false
            }
            PumpAmmEvent::SellEvent {
                user,
                user_base_token_account,
                user_quote_token_account,
                base_amount_in,
                user_quote_amount_out,
                ..
            } => {
                let Some(target) = self.targets.get_mut(user) else {
                    return false;
                };
                let slot = event_slot(event);
                Self::apply_base_token_update(
                    &mut target.pump_amm,
                    balances.by_token_account(user_base_token_account),
                    slot,
                    Some(*base_amount_in),
                    None,
                );
                Self::apply_quote_update(
                    &mut target.pump_amm,
                    balances.by_token_account(user_quote_token_account),
                    slot,
                    Some(*user_quote_amount_out),
                );
                let mut payload = match build_pump_amm_sell_payload(event, instructions) {
                    Some(ExecutionPayload::PumpAmmSell(payload)) => payload,
                    Some(other) => {
                        debug!("Unexpected Pump AMM sell payload variant: {:?}", other);
                        return false;
                    }
                    None => return true,
                };
                if !target.config.mirror_sells {
                    return false;
                }
                let base_mint = payload.accounts.base_mint;
                let operator_available = self.operator.total_tokens(&base_mint);
                let sell_tokens = target.mirror_positions.plan_sell(
                    base_mint,
                    *base_amount_in,
                    operator_available,
                );
                if sell_tokens == 0 {
                    return false;
                }
                let target_holdings_pre = balances
                    .by_token_account(user_base_token_account)
                    .and_then(|change| change.pre_amount)
                    .unwrap_or(0);
                let target_pct = if target_holdings_pre > 0 {
                    (*base_amount_in as f64 / target_holdings_pre as f64) * 100.0
                } else {
                    0.0
                };
                let operator_pct = if operator_available > 0 {
                    (sell_tokens as f64 / operator_available as f64) * 100.0
                } else {
                    0.0
                };
                info!(
                    "Target {} sold {:.4} tokens for {:.4} SOL (sold {:.2}% of position); mirroring {:.2}% of operator holdings (pool {})",
                    user,
                    tokens_to_amount(*base_amount_in),
                    lamports_to_sol(*user_quote_amount_out),
                    target_pct,
                    operator_pct,
                    payload.accounts.pool
                );
                payload.base_amount_in = sell_tokens;
                let slippage_bps = slippage_pct_to_bps(target.config.slippage_pct) as u64;
                let quote_result = match sell_base_input_internal(
                    sell_tokens,
                    slippage_bps,
                    payload.base_reserve,
                    payload.quote_reserve,
                    payload.fees,
                ) {
                    Ok(result) => result,
                    Err(err) => {
                        warn!("Pump AMM sell math failed: {err}");
                        return false;
                    }
                };
                payload.expected_sol_out = quote_result.ui_quote;
                let signal = ExecutionSignal::pump_amm_sell(
                    target.config.clone(),
                    slot,
                    quote_result.ui_quote,
                    sell_tokens,
                    ExecutionPayload::PumpAmmSell(payload),
                    self.parsing_time_us,
                    compute_units_consumed,
                );
                self.emit_execution_signal(signal);
                false
            }
        }
    }

    fn apply_base_token_update(
        holdings: &mut WalletHoldings,
        change: Option<&TokenBalanceChange>,
        slot: u64,
        fallback_amount: Option<u64>,
        fallback_mint: Option<Pubkey>,
    ) {
        if let Some(change) = change {
            if let Some(post_amount) = change.post_amount {
                holdings.update_token_position(
                    change.key.mint,
                    change.token_account,
                    post_amount,
                    change.decimals,
                    slot,
                );
                return;
            }
        }

        if let (Some(amount), Some(mint)) = (fallback_amount, fallback_mint) {
            holdings.update_token_position(mint, None, amount, DEFAULT_TOKEN_DECIMALS, slot);
        }
    }

    fn apply_operator_fill(
        &mut self,
        pending: &PendingConfirmation,
        parsed_tx: &ParsedTransaction,
    ) {
        let Some(target) = self.targets.get_mut(&pending.target) else {
            warn!(
                "Confirmed transaction for unknown target {}",
                pending.target
            );
            return;
        };
        let operator_key = self.operator.wallet;
        for event in &parsed_tx.events {
            match (pending.protocol, event) {
                (
                    TradeProtocol::PumpFun,
                    ParsedEvent::PumpFun(PumpFunEvent::TradeEvent {
                        user,
                        mint,
                        token_amount,
                        is_buy,
                        ..
                    }),
                ) if user == &operator_key && *is_buy => {
                    target
                        .pump_fun_positions
                        .record_operator_buy(*mint, *token_amount);
                    target
                        .mirror_positions
                        .record_operator_buy(*mint, *token_amount);
                }
                (
                    TradeProtocol::PumpAmm,
                    ParsedEvent::PumpAmm(PumpAmmEvent::BuyEvent {
                        user,
                        base_amount_out,
                        ..
                    }),
                ) if user == &operator_key => {
                    target
                        .pump_amm_positions
                        .record_operator_buy(pending.mint, *base_amount_out);
                    target
                        .mirror_positions
                        .record_operator_buy(pending.mint, *base_amount_out);
                }
                _ => {}
            }
        }
    }

    fn apply_quote_update(
        holdings: &mut WalletHoldings,
        change: Option<&TokenBalanceChange>,
        slot: u64,
        fallback_lamports: Option<u64>,
    ) {
        if let Some(change) = change {
            if let Some(post_amount) = change.post_amount {
                if change.key.mint == native_mint::id() {
                    holdings.update_sol_balance_from_token_amount(
                        post_amount,
                        change.decimals,
                        slot,
                    );
                } else {
                    holdings.update_token_position(
                        change.key.mint,
                        change.token_account,
                        post_amount,
                        change.decimals,
                        slot,
                    );
                }
                return;
            }
        }

        if let Some(lamports) = fallback_lamports {
            holdings.update_sol_balance_from_lamports(lamports, slot);
        }
    }
}

fn build_pump_fun_payload(
    event: &PumpFunEvent,
    instructions: &InstructionIndex<'_>,
) -> Option<ExecutionPayload> {
    match event {
        PumpFunEvent::TradeEvent {
            is_buy,
            virtual_token_reserves,
            virtual_sol_reserves,
            real_token_reserves,
            context_instruction_index,
            context_position,
            context_parent_position,
            ..
        } => {
            let ctx = match instructions.find_instruction_with_fallback(
                *context_instruction_index,
                *context_position,
                Some(*context_parent_position),
                |ix| matches!(ix.instruction, ParsedInstruction::PumpFun(_)),
            ) {
                Some(ix) => ix,
                None => {
                    warn!(
                        "Missing PumpFun instruction for event (idx={} depth={} parent={})",
                        context_instruction_index, context_position, context_parent_position
                    );
                    return None;
                }
            };
            match (is_buy, &ctx.instruction) {
                (
                    true,
                    ParsedInstruction::PumpFun(PumpFunInstruction::BuyExactSolIn {
                        spendable_sol_in,
                        track_volume,
                        global,
                        fee_recipient,
                        mint,
                        bonding_curve,
                        associated_bonding_curve,
                        associated_user,
                        user,
                        system_program,
                        token_program,
                        creator_vault,
                        event_authority,
                        program,
                        global_volume_accumulator,
                        user_volume_accumulator,
                        fee_config,
                        fee_program,
                        ..
                    }),
                ) => {
                    let accounts = BuyExactSolInAccounts {
                        global: *global,
                        fee_recipient: *fee_recipient,
                        mint: *mint,
                        bonding_curve: *bonding_curve,
                        associated_bonding_curve: *associated_bonding_curve,
                        associated_user: *associated_user,
                        user: *user,
                        system_program: *system_program,
                        token_program: *token_program,
                        creator_vault: *creator_vault,
                        event_authority: *event_authority,
                        program: *program,
                        global_volume_accumulator: *global_volume_accumulator,
                        user_volume_accumulator: *user_volume_accumulator,
                        fee_config: *fee_config,
                        fee_program: *fee_program,
                    };
                    Some(ExecutionPayload::PumpFunBuy(PumpFunBuyPayload {
                        accounts,
                        spendable_sol_in: *spendable_sol_in,
                        virtual_token_reserves: (*virtual_token_reserves).into(),
                        virtual_sol_reserves: (*virtual_sol_reserves).into(),
                        real_token_reserves: (*real_token_reserves).into(),
                        track_volume: *track_volume,
                    }))
                }
                (
                    true,
                    ParsedInstruction::PumpFun(PumpFunInstruction::Buy {
                        max_sol_cost,
                        track_volume,
                        global,
                        fee_recipient,
                        mint,
                        bonding_curve,
                        associated_bonding_curve,
                        associated_user,
                        user,
                        system_program,
                        token_program,
                        creator_vault,
                        event_authority,
                        program,
                        global_volume_accumulator,
                        user_volume_accumulator,
                        fee_config,
                        fee_program,
                        ..
                    }),
                ) => {
                    let accounts = BuyExactSolInAccounts {
                        global: *global,
                        fee_recipient: *fee_recipient,
                        mint: *mint,
                        bonding_curve: *bonding_curve,
                        associated_bonding_curve: *associated_bonding_curve,
                        associated_user: *associated_user,
                        user: *user,
                        system_program: *system_program,
                        token_program: *token_program,
                        creator_vault: *creator_vault,
                        event_authority: *event_authority,
                        program: *program,
                        global_volume_accumulator: *global_volume_accumulator,
                        user_volume_accumulator: *user_volume_accumulator,
                        fee_config: *fee_config,
                        fee_program: *fee_program,
                    };
                    Some(ExecutionPayload::PumpFunBuy(PumpFunBuyPayload {
                        accounts,
                        spendable_sol_in: *max_sol_cost,
                        virtual_token_reserves: (*virtual_token_reserves).into(),
                        virtual_sol_reserves: (*virtual_sol_reserves).into(),
                        real_token_reserves: (*real_token_reserves).into(),
                        track_volume: *track_volume,
                    }))
                }
                (
                    false,
                    ParsedInstruction::PumpFun(PumpFunInstruction::Sell {
                        amount,
                        global,
                        fee_recipient,
                        mint,
                        bonding_curve,
                        associated_bonding_curve,
                        associated_user,
                        user,
                        system_program,
                        creator_vault,
                        token_program,
                        event_authority,
                        program,
                        fee_config,
                        fee_program,
                        ..
                    }),
                ) => {
                    let accounts = PumpFunSellAccounts {
                        global: *global,
                        fee_recipient: *fee_recipient,
                        mint: *mint,
                        bonding_curve: *bonding_curve,
                        associated_bonding_curve: *associated_bonding_curve,
                        associated_user: *associated_user,
                        user: *user,
                        system_program: *system_program,
                        creator_vault: *creator_vault,
                        token_program: *token_program,
                        event_authority: *event_authority,
                        program: *program,
                        fee_config: *fee_config,
                        fee_program: *fee_program,
                    };
                    Some(ExecutionPayload::PumpFunSell(PumpFunSellPayload {
                        accounts,
                        amount: *amount,
                        virtual_token_reserves: (*virtual_token_reserves).into(),
                        virtual_sol_reserves: (*virtual_sol_reserves).into(),
                    }))
                }
                _ => None,
            }
        }
    }
}

fn build_pump_amm_buy_payload(
    event: &PumpAmmEvent,
    instructions: &InstructionIndex<'_>,
) -> Option<ExecutionPayload> {
    let PumpAmmEvent::BuyEvent {
        context_instruction_index,
        context_position,
        context_parent_position,
        pool_base_token_reserves,
        pool_quote_token_reserves,
        lp_fee_basis_points,
        protocol_fee_basis_points,
        coin_creator_fee_basis_points,
        ..
    } = event
    else {
        return None;
    };

    let ctx = match instructions.find_instruction_with_fallback(
        *context_instruction_index,
        *context_position,
        Some(*context_parent_position),
        |ix| matches!(ix.instruction, ParsedInstruction::PumpAmm(_)),
    ) {
        Some(ix) => ix,
        None => {
            warn!(
                "Missing PumpAmm instruction for buy event (idx={} depth={} parent={})",
                context_instruction_index, context_position, context_parent_position
            );
            return None;
        }
    };

    if let ParsedInstruction::PumpAmm(PumpAmmInstruction::BuyExactQuoteIn {
        spendable_quote_in,
        track_volume,
        pool,
        user,
        global_config,
        base_mint,
        quote_mint,
        user_base_token_account,
        user_quote_token_account,
        pool_base_token_account,
        pool_quote_token_account,
        protocol_fee_recipient,
        protocol_fee_recipient_token_account,
        base_token_program,
        quote_token_program,
        system_program,
        associated_token_program,
        event_authority,
        program,
        coin_creator_vault_ata,
        coin_creator_vault_authority,
        global_volume_accumulator,
        user_volume_accumulator,
        fee_config,
        fee_program,
        ..
    }) = &ctx.instruction
    {
        let accounts = BuyExactQuoteInAccounts {
            pool: *pool,
            user: *user,
            global_config: *global_config,
            base_mint: *base_mint,
            quote_mint: *quote_mint,
            user_base_token_account: *user_base_token_account,
            user_quote_token_account: *user_quote_token_account,
            pool_base_token_account: *pool_base_token_account,
            pool_quote_token_account: *pool_quote_token_account,
            protocol_fee_recipient: *protocol_fee_recipient,
            protocol_fee_recipient_token_account: *protocol_fee_recipient_token_account,
            base_token_program: *base_token_program,
            quote_token_program: *quote_token_program,
            system_program: *system_program,
            associated_token_program: *associated_token_program,
            event_authority: *event_authority,
            program: *program,
            coin_creator_vault_ata: *coin_creator_vault_ata,
            coin_creator_vault_authority: *coin_creator_vault_authority,
            global_volume_accumulator: *global_volume_accumulator,
            user_volume_accumulator: *user_volume_accumulator,
            fee_config: *fee_config,
            fee_program: *fee_program,
        };
        let fees = Fees {
            lp_fee_bps: (*lp_fee_basis_points).min(u16::MAX as u64) as u16,
            protocol_fee_bps: (*protocol_fee_basis_points).min(u16::MAX as u64) as u16,
            coin_creator_fee_bps: (*coin_creator_fee_basis_points).min(u16::MAX as u64) as u16,
        };
        return Some(ExecutionPayload::PumpAmmBuy(PumpAmmBuyPayload {
            accounts,
            spendable_quote_in: *spendable_quote_in,
            base_reserve: *pool_base_token_reserves,
            quote_reserve: *pool_quote_token_reserves,
            fees,
            track_volume: *track_volume,
        }));
    }

    None
}

fn build_pump_amm_sell_payload(
    event: &PumpAmmEvent,
    instructions: &InstructionIndex<'_>,
) -> Option<ExecutionPayload> {
    let PumpAmmEvent::SellEvent {
        context_instruction_index,
        context_position,
        context_parent_position,
        pool_base_token_reserves,
        pool_quote_token_reserves,
        lp_fee_basis_points,
        protocol_fee_basis_points,
        coin_creator_fee_basis_points,
        user_quote_amount_out,
        ..
    } = event
    else {
        return None;
    };

    let ctx = match instructions.find_instruction_with_fallback(
        *context_instruction_index,
        *context_position,
        Some(*context_parent_position),
        |ix| matches!(ix.instruction, ParsedInstruction::PumpAmm(_)),
    ) {
        Some(ix) => ix,
        None => {
            warn!(
                "Missing PumpAmm instruction for sell event (idx={} depth={} parent={})",
                context_instruction_index, context_position, context_parent_position
            );
            return None;
        }
    };

    if let ParsedInstruction::PumpAmm(PumpAmmInstruction::Sell {
        base_amount_in,
        pool,
        user,
        global_config,
        base_mint,
        quote_mint,
        user_base_token_account,
        user_quote_token_account,
        pool_base_token_account,
        pool_quote_token_account,
        protocol_fee_recipient,
        protocol_fee_recipient_token_account,
        base_token_program,
        quote_token_program,
        system_program,
        associated_token_program,
        event_authority,
        program,
        coin_creator_vault_ata,
        coin_creator_vault_authority,
        fee_config,
        fee_program,
        ..
    }) = &ctx.instruction
    {
        let accounts = PumpAmmSellAccounts {
            pool: *pool,
            user: *user,
            global_config: *global_config,
            base_mint: *base_mint,
            quote_mint: *quote_mint,
            user_base_token_account: *user_base_token_account,
            user_quote_token_account: *user_quote_token_account,
            pool_base_token_account: *pool_base_token_account,
            pool_quote_token_account: *pool_quote_token_account,
            protocol_fee_recipient: *protocol_fee_recipient,
            protocol_fee_recipient_token_account: *protocol_fee_recipient_token_account,
            base_token_program: *base_token_program,
            quote_token_program: *quote_token_program,
            system_program: *system_program,
            associated_token_program: *associated_token_program,
            event_authority: *event_authority,
            program: *program,
            coin_creator_vault_ata: *coin_creator_vault_ata,
            coin_creator_vault_authority: *coin_creator_vault_authority,
            fee_config: *fee_config,
            fee_program: *fee_program,
        };
        let fees = Fees {
            lp_fee_bps: (*lp_fee_basis_points).min(u16::MAX as u64) as u16,
            protocol_fee_bps: (*protocol_fee_basis_points).min(u16::MAX as u64) as u16,
            coin_creator_fee_bps: (*coin_creator_fee_basis_points).min(u16::MAX as u64) as u16,
        };
        return Some(ExecutionPayload::PumpAmmSell(PumpAmmSellPayload {
            accounts,
            base_amount_in: *base_amount_in,
            base_reserve: *pool_base_token_reserves,
            quote_reserve: *pool_quote_token_reserves,
            fees,
            expected_sol_out: *user_quote_amount_out,
        }));
    }

    None
}
#[derive(Clone)]
struct WalletTargetState {
    config: TargetWalletConfig,
    pump_fun: WalletHoldings,
    pump_amm: WalletHoldings,
    pump_fun_positions: MirrorLedger,
    pump_amm_positions: MirrorLedger,
    mirror_positions: MirrorLedger,
    tp_sl_positions: HashMap<Pubkey, TpSlPosition>,
}

impl WalletTargetState {
    fn new(config: TargetWalletConfig) -> Self {
        Self {
            config,
            pump_fun: WalletHoldings::default(),
            pump_amm: WalletHoldings::default(),
            pump_fun_positions: MirrorLedger::default(),
            pump_amm_positions: MirrorLedger::default(),
            mirror_positions: MirrorLedger::default(),
            tp_sl_positions: HashMap::new(),
        }
    }

    fn snapshot(&self) -> WalletSnapshot {
        WalletSnapshot {
            wallet: self.config.wallet,
            slippage_pct: self.config.slippage_pct,
            pump_fun: HoldingSnapshot::from(&self.pump_fun),
            pump_amm: HoldingSnapshot::from(&self.pump_amm),
        }
    }
}

#[derive(Default)]
struct PositionIndex {
    index: HashMap<Pubkey, HashSet<Pubkey>>,
}

impl PositionIndex {
    fn insert(&mut self, mint: Pubkey, wallet: Pubkey) {
        self.index.entry(mint).or_default().insert(wallet);
    }

    fn remove(&mut self, mint: &Pubkey, wallet: &Pubkey) {
        if let Some(targets) = self.index.get_mut(mint) {
            targets.remove(wallet);
            if targets.is_empty() {
                self.index.remove(mint);
            }
        }
    }

    fn get_targets(&self, mint: &Pubkey) -> Option<&HashSet<Pubkey>> {
        self.index.get(mint)
    }

    fn targets_for(&self, mint: &Pubkey) -> Vec<Pubkey> {
        self.index
            .get(mint)
            .map(|set| set.iter().copied().collect())
            .unwrap_or_default()
    }
}

#[derive(Clone)]
struct TpSlPosition {
    protocol: TradeProtocol,
    buy_price: f64,
    take_profit_pct: Option<f64>,
    stop_loss_pct: Option<f64>,
    pending_sell: bool,
    last_log_at: Instant,
    drift_baseline_price: Option<f64>,
    drift_baseline_at: Option<Instant>,
}

#[derive(Clone, Copy)]
enum TpSlTrigger {
    TakeProfit,
    StopLoss,
    Stagnation,
}

struct TpSlAction {
    signal: ExecutionSignal,
    target_wallet: Pubkey,
    mint: Pubkey,
    trigger: TpSlTrigger,
    current_price: f64,
    pct_change: f64,
}

impl TpSlPosition {
    fn new(
        protocol: TradeProtocol,
        buy_price: f64,
        take_profit_pct: Option<f64>,
        stop_loss_pct: Option<f64>,
    ) -> Self {
        Self {
            protocol,
            buy_price,
            take_profit_pct,
            stop_loss_pct,
            pending_sell: false,
            last_log_at: Instant::now(),
            drift_baseline_price: None,
            drift_baseline_at: None,
        }
    }

    fn tp_price(&self) -> Option<f64> {
        self.take_profit_pct
            .map(|pct| self.buy_price * (1.0 + pct / 100.0))
    }

    fn sl_price(&self) -> Option<f64> {
        self.stop_loss_pct
            .map(|pct| self.buy_price * (1.0 - pct / 100.0))
    }

    fn percentage_change(&self, current_price: f64) -> f64 {
        if self.buy_price <= f64::EPSILON {
            return 0.0;
        }
        ((current_price - self.buy_price) / self.buy_price) * 100.0
    }

    fn evaluate_trigger(&self, pct_change: f64) -> Option<TpSlTrigger> {
        if let Some(tp) = self.take_profit_pct {
            if pct_change >= tp {
                return Some(TpSlTrigger::TakeProfit);
            }
        }
        if let Some(sl) = self.stop_loss_pct {
            if pct_change <= -sl {
                return Some(TpSlTrigger::StopLoss);
            }
        }
        None
    }

    fn record_additional_buy(&mut self, previous_tokens: u64, new_tokens: u64, new_price: f64) {
        if new_tokens == 0 {
            return;
        }
        if previous_tokens == 0 || self.buy_price <= 0.0 {
            self.buy_price = new_price;
            return;
        }
        let total = previous_tokens.saturating_add(new_tokens);
        if total == 0 {
            self.buy_price = new_price;
            return;
        }
        let blended = ((self.buy_price * previous_tokens as f64) + (new_price * new_tokens as f64))
            / total as f64;
        self.buy_price = blended;
    }

    fn should_log(&self) -> bool {
        self.last_log_at.elapsed() >= Duration::from_secs(5)
    }

    fn mark_logged(&mut self) {
        self.last_log_at = Instant::now();
    }

    fn should_force_exit(
        &mut self,
        current_price: f64,
        threshold_pct: f64,
        window: Duration,
    ) -> bool {
        let now = Instant::now();
        match (self.drift_baseline_price, self.drift_baseline_at) {
            (Some(base), Some(last)) if now.duration_since(last) >= window => {
                self.drift_baseline_price = Some(current_price);
                self.drift_baseline_at = Some(now);
                if base.abs() <= f64::EPSILON {
                    return true;
                }
                let pct_change = ((current_price - base) / base) * 100.0;
                pct_change.abs() <= threshold_pct
            }
            (None, _) | (_, None) => {
                self.drift_baseline_price = Some(current_price);
                self.drift_baseline_at = Some(now);
                false
            }
            _ => false,
        }
    }
}

struct OperatorState {
    wallet: Pubkey,
    pump_fun: WalletHoldings,
    pump_amm: WalletHoldings,
}

impl OperatorState {
    fn new(wallet: Pubkey) -> Self {
        Self {
            wallet,
            pump_fun: WalletHoldings::default(),
            pump_amm: WalletHoldings::default(),
        }
    }

    fn pump_fun_tokens(&self, mint: &Pubkey) -> u64 {
        self.pump_fun.token_amount(mint)
    }

    fn pump_amm_tokens(&self, mint: &Pubkey) -> u64 {
        self.pump_amm.token_amount(mint)
    }

    fn total_tokens(&self, mint: &Pubkey) -> u64 {
        self.pump_fun_tokens(mint)
            .saturating_add(self.pump_amm_tokens(mint))
    }
}

#[derive(Clone, Default)]
struct WalletHoldings {
    sol_amount: f64,
    last_update_slot: Option<u64>,
    tokens: HashMap<Pubkey, TokenPosition>,
}

#[derive(Clone, Copy, Debug, Default)]
struct TokenPosition {
    token_account: Option<Pubkey>,
    raw_amount: u64,
    amount: f64,
    decimals: u8,
    last_update_slot: Option<u64>,
}

impl WalletHoldings {
    fn update_token_position(
        &mut self,
        mint: Pubkey,
        token_account: Option<Pubkey>,
        raw_amount: u64,
        decimals: u8,
        slot: u64,
    ) {
        let entry = self.tokens.entry(mint).or_default();
        entry.token_account = token_account;
        entry.raw_amount = raw_amount;
        entry.amount = amount_to_ui(raw_amount, decimals);
        entry.decimals = decimals;
        entry.last_update_slot = Some(slot);
        self.last_update_slot = Some(slot);
    }

    fn update_sol_balance_from_token_amount(&mut self, raw_amount: u64, decimals: u8, slot: u64) {
        self.sol_amount = amount_to_ui(raw_amount, decimals);
        self.last_update_slot = Some(slot);
    }

    fn update_sol_balance_from_lamports(&mut self, lamports: u64, slot: u64) {
        self.sol_amount = lamports_to_sol(lamports);
        self.last_update_slot = Some(slot);
    }

    fn token_amount(&self, mint: &Pubkey) -> u64 {
        self.tokens.get(mint).map(|pos| pos.raw_amount).unwrap_or(0)
    }
}

#[derive(Clone, Default)]
struct MirrorLedger {
    positions: HashMap<Pubkey, MirrorPosition>,
}

#[derive(Clone, Default)]
struct MirrorPosition {
    target_buys: u128,
    target_sells: u128,
    operator_buys: u128,
    operator_sells: u128,
}

impl MirrorLedger {
    fn record_target_buy(&mut self, mint: Pubkey, target_tokens: u64) {
        if target_tokens == 0 {
            return;
        }
        let entry = self.positions.entry(mint).or_default();
        entry.target_buys = entry.target_buys.saturating_add(target_tokens as u128);
    }

    fn record_operator_buy(&mut self, mint: Pubkey, operator_tokens: u64) {
        if operator_tokens == 0 {
            return;
        }
        let entry = self.positions.entry(mint).or_default();
        entry.operator_buys = entry.operator_buys.saturating_add(operator_tokens as u128);
        if entry.operator_sells > entry.operator_buys {
            entry.operator_sells = entry.operator_buys;
        }
        self.maybe_close(mint);
    }

    fn plan_sell(&mut self, mint: Pubkey, target_sell_tokens: u64, operator_available: u64) -> u64 {
        if target_sell_tokens == 0 || operator_available == 0 {
            return 0;
        }
        let Some(entry) = self.positions.get_mut(&mint) else {
            return 0;
        };
        if entry.target_buys == 0 || entry.operator_buys == 0 {
            return 0;
        }

        entry.target_sells = entry
            .target_sells
            .saturating_add(target_sell_tokens as u128)
            .min(entry.target_buys);

        let desired_operator_sold =
            entry.operator_buys.saturating_mul(entry.target_sells) / entry.target_buys;
        let pending = desired_operator_sold.saturating_sub(entry.operator_sells);
        if pending == 0 {
            return 0;
        }

        let mirrored_available = entry
            .operator_buys
            .saturating_sub(entry.operator_sells)
            .min(operator_available as u128);

        if mirrored_available == 0 {
            return 0;
        }

        let sell_amount = pending.min(mirrored_available) as u64;
        if sell_amount == 0 {
            return 0;
        }

        entry.operator_sells = entry
            .operator_sells
            .saturating_add(sell_amount as u128)
            .min(entry.operator_buys);

        self.maybe_close(mint);

        sell_amount
    }

    fn maybe_close(&mut self, mint: Pubkey) {
        if let Some(entry) = self.positions.get(&mint) {
            if entry.operator_sells >= entry.operator_buys
                && entry.target_sells >= entry.target_buys
            {
                self.positions.remove(&mint);
            }
        }
    }
}

struct PumpFunTracker {
    holdings: HashMap<Pubkey, PumpFunWalletState>,
}

impl PumpFunTracker {
    fn new() -> Self {
        Self {
            holdings: HashMap::new(),
        }
    }

    fn handle_instruction(&mut self, _instruction: &crate::parsers::pump_fun::PumpFunInstruction) {}

    fn handle_event(&mut self, event: &PumpFunEvent) {
        match event {
            PumpFunEvent::TradeEvent { user, .. } => {
                debug!("Received PumpFun trade event for user {}", user);
                let entry = self
                    .holdings
                    .entry(*user)
                    .or_insert_with(PumpFunWalletState::default);
                entry.update_from_event(event);
            }
        }
    }
}

#[derive(Default)]
struct PumpFunWalletState {
    sol_amount: f64,
    token_amount: f64,
    virtual_sol_reserves: u64,
    virtual_token_reserves: u64,
    real_sol_reserves: u64,
    real_token_reserves: u64,
    last_update_slot: Option<u64>,
}

impl PumpFunWalletState {
    fn update_from_event(&mut self, event: &PumpFunEvent) {
        match event {
            PumpFunEvent::TradeEvent {
                sol_amount,
                token_amount,
                virtual_sol_reserves,
                virtual_token_reserves,
                real_sol_reserves,
                real_token_reserves,
                ..
            } => {
                self.sol_amount = lamports_to_sol(*sol_amount);
                self.token_amount = tokens_to_amount(*token_amount);
                self.virtual_sol_reserves = *virtual_sol_reserves;
                self.virtual_token_reserves = *virtual_token_reserves;
                self.real_sol_reserves = *real_sol_reserves;
                self.real_token_reserves = *real_token_reserves;
                self.last_update_slot = Some(event_slot(event));
            }
        }
    }

    fn snapshot(&self) -> PumpFunSnapshot {
        PumpFunSnapshot {
            sol_amount: self.sol_amount,
            token_amount: self.token_amount,
            virtual_sol_reserves: self.virtual_sol_reserves,
            virtual_token_reserves: self.virtual_token_reserves,
            real_sol_reserves: self.real_sol_reserves,
            real_token_reserves: self.real_token_reserves,
            last_update_slot: self.last_update_slot,
        }
    }
}

struct PumpAmmTracker {
    holdings: HashMap<Pubkey, PumpAmmWalletState>,
}

impl PumpAmmTracker {
    fn new() -> Self {
        Self {
            holdings: HashMap::new(),
        }
    }

    fn handle_instruction(&mut self, _instruction: &crate::parsers::pump_amm::PumpAmmInstruction) {}

    fn handle_event(&mut self, event: &PumpAmmEvent) {
        match event {
            PumpAmmEvent::BuyEvent {
                user,
                user_quote_amount_in,
                base_amount_out,
                pool_base_token_reserves,
                pool_quote_token_reserves,
                lp_fee_basis_points,
                protocol_fee_basis_points,
                coin_creator_fee_basis_points,
                ..
            } => {
                debug!("Received Pump AMM buy event for user {}", user);
                let entry = self
                    .holdings
                    .entry(*user)
                    .or_insert_with(PumpAmmWalletState::default);
                entry.sol_amount = lamports_to_sol(*user_quote_amount_in);
                entry.token_amount = tokens_to_amount(*base_amount_out);
                entry.pool_base_reserve = *pool_base_token_reserves;
                entry.pool_quote_reserve = *pool_quote_token_reserves;
                entry.lp_fee_bps = *lp_fee_basis_points;
                entry.protocol_fee_bps = *protocol_fee_basis_points;
                entry.coin_creator_fee_bps = *coin_creator_fee_basis_points;
                entry.last_update_slot = Some(event_slot(event));
            }
            PumpAmmEvent::SellEvent {
                user,
                user_quote_amount_out,
                base_amount_in,
                pool_base_token_reserves,
                pool_quote_token_reserves,
                lp_fee_basis_points,
                protocol_fee_basis_points,
                coin_creator_fee_basis_points,
                ..
            } => {
                debug!("Received Pump AMM sell event for user {}", user);
                let entry = self
                    .holdings
                    .entry(*user)
                    .or_insert_with(PumpAmmWalletState::default);
                entry.sol_amount = lamports_to_sol(*user_quote_amount_out);
                entry.token_amount = tokens_to_amount(*base_amount_in);
                entry.pool_base_reserve = *pool_base_token_reserves;
                entry.pool_quote_reserve = *pool_quote_token_reserves;
                entry.lp_fee_bps = *lp_fee_basis_points;
                entry.protocol_fee_bps = *protocol_fee_basis_points;
                entry.coin_creator_fee_bps = *coin_creator_fee_basis_points;
                entry.last_update_slot = Some(event_slot(event));
            }
        }
    }
}

#[derive(Default)]
struct PumpAmmWalletState {
    sol_amount: f64,
    token_amount: f64,
    pool_base_reserve: u64,
    pool_quote_reserve: u64,
    lp_fee_bps: u64,
    protocol_fee_bps: u64,
    coin_creator_fee_bps: u64,
    last_update_slot: Option<u64>,
}

impl PumpAmmWalletState {
    fn snapshot(&self) -> PumpAmmSnapshot {
        PumpAmmSnapshot {
            sol_amount: self.sol_amount,
            token_amount: self.token_amount,
            pool_base_reserve: self.pool_base_reserve,
            pool_quote_reserve: self.pool_quote_reserve,
            lp_fee_bps: self.lp_fee_bps,
            protocol_fee_bps: self.protocol_fee_bps,
            coin_creator_fee_bps: self.coin_creator_fee_bps,
            last_update_slot: self.last_update_slot,
        }
    }
}

#[derive(Clone, Debug)]
pub struct WalletSnapshot {
    pub wallet: Pubkey,
    pub slippage_pct: f64,
    pub pump_fun: HoldingSnapshot,
    pub pump_amm: HoldingSnapshot,
}

#[derive(Clone, Debug, Default)]
pub struct HoldingSnapshot {
    pub sol_amount: f64,
    pub last_update_slot: Option<u64>,
    pub tokens: HashMap<Pubkey, MintHoldingSnapshot>,
}

impl From<&WalletHoldings> for HoldingSnapshot {
    fn from(value: &WalletHoldings) -> Self {
        let tokens = value
            .tokens
            .iter()
            .map(|(mint, position)| (*mint, MintHoldingSnapshot::from(position)))
            .collect();
        HoldingSnapshot {
            sol_amount: value.sol_amount,
            last_update_slot: value.last_update_slot,
            tokens,
        }
    }
}

#[derive(Clone, Copy, Debug, Default)]
pub struct MintHoldingSnapshot {
    pub token_account: Option<Pubkey>,
    pub raw_amount: u64,
    pub amount: f64,
    pub decimals: u8,
    pub last_update_slot: Option<u64>,
}

impl From<&TokenPosition> for MintHoldingSnapshot {
    fn from(position: &TokenPosition) -> Self {
        MintHoldingSnapshot {
            token_account: position.token_account,
            raw_amount: position.raw_amount,
            amount: position.amount,
            decimals: position.decimals,
            last_update_slot: position.last_update_slot,
        }
    }
}

#[derive(Clone, Copy, Debug, Default)]
pub struct PumpFunSnapshot {
    pub sol_amount: f64,
    pub token_amount: f64,
    pub virtual_sol_reserves: u64,
    pub virtual_token_reserves: u64,
    pub real_sol_reserves: u64,
    pub real_token_reserves: u64,
    pub last_update_slot: Option<u64>,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct PumpAmmSnapshot {
    pub sol_amount: f64,
    pub token_amount: f64,
    pub pool_base_reserve: u64,
    pub pool_quote_reserve: u64,
    pub lp_fee_bps: u64,
    pub protocol_fee_bps: u64,
    pub coin_creator_fee_bps: u64,
    pub last_update_slot: Option<u64>,
}

fn event_slot(event: &impl HasSlot) -> u64 {
    event.slot()
}

trait HasSlot {
    fn slot(&self) -> u64;
}

impl HasSlot for PumpFunEvent {
    fn slot(&self) -> u64 {
        match self {
            PumpFunEvent::TradeEvent { timestamp, .. } => normalize_timestamp(*timestamp),
        }
    }
}

impl HasSlot for PumpAmmEvent {
    fn slot(&self) -> u64 {
        match self {
            PumpAmmEvent::BuyEvent { timestamp, .. } => normalize_timestamp(*timestamp),
            PumpAmmEvent::SellEvent { timestamp, .. } => normalize_timestamp(*timestamp),
        }
    }
}

fn normalize_timestamp(value: i64) -> u64 {
    if value < 0 {
        0
    } else {
        value as u64
    }
}

fn slippage_pct_to_bps(pct: f64) -> u16 {
    let bps = (pct * 100.0).round();
    bps.clamp(0.0, 10_000.0) as u16
}

fn lamports_to_sol(value: u64) -> f64 {
    value as f64 / 1_000_000_000.0
}

fn tokens_to_amount(value: u64) -> f64 {
    value as f64 / 1_000_000.0
}

fn amount_to_ui(value: u64, decimals: u8) -> f64 {
    if decimals == 0 {
        return value as f64;
    }
    let scale = 10f64.powi(decimals as i32);
    value as f64 / scale
}

fn retarget_pump_fun_buy_accounts(accounts: &mut BuyExactSolInAccounts, operator: &Pubkey) {
    accounts.user = *operator;
    accounts.associated_user = derive_ata(operator, &accounts.mint, &accounts.token_program);
    accounts.user_volume_accumulator = pump_fun_volume_pda(operator);
}

fn retarget_pump_fun_sell_accounts(accounts: &mut PumpFunSellAccounts, operator: &Pubkey) {
    accounts.user = *operator;
    accounts.associated_user = derive_ata(operator, &accounts.mint, &accounts.token_program);
}

fn retarget_pump_amm_buy_accounts(accounts: &mut BuyExactQuoteInAccounts, operator: &Pubkey) {
    accounts.user = *operator;
    accounts.user_base_token_account =
        derive_ata(operator, &accounts.base_mint, &accounts.base_token_program);
    accounts.user_quote_token_account = derive_ata(
        operator,
        &accounts.quote_mint,
        &accounts.quote_token_program,
    );
    accounts.user_volume_accumulator = pump_amm_volume_pda(operator);
}

fn retarget_pump_amm_sell_accounts(accounts: &mut PumpAmmSellAccounts, operator: &Pubkey) {
    accounts.user = *operator;
    accounts.user_base_token_account =
        derive_ata(operator, &accounts.base_mint, &accounts.base_token_program);
    accounts.user_quote_token_account = derive_ata(
        operator,
        &accounts.quote_mint,
        &accounts.quote_token_program,
    );
}

fn derive_ata(owner: &Pubkey, mint: &Pubkey, token_program: &Pubkey) -> Pubkey {
    get_associated_token_address_with_program_id(owner, mint, token_program)
}

fn format_price(value: Option<f64>) -> String {
    value
        .map(|price| format!("{:.6}", price))
        .unwrap_or_else(|| "N/A".to_string())
}

fn log_tp_sl_targets(
    target_wallet: Pubkey,
    mint: Pubkey,
    buy_price: f64,
    tp_price: Option<f64>,
    sl_price: Option<f64>,
) {
    info!(
        "TP/SL | Target {} mint {} | Buy Price: {:.6} SOL | Target Price (TP): {} | Target Price (SL): {}",
        target_wallet,
        mint,
        buy_price,
        format_price(tp_price),
        format_price(sl_price),
    );
}

fn log_tp_sl_status(
    target_wallet: Pubkey,
    mint: Pubkey,
    position: &TpSlPosition,
    current_price: f64,
    pct_change: f64,
) {
    info!(
        "TP/SL | Target {} mint {} | Buy Price: {:.6} SOL | Current Price: {:.6} SOL | Target Price (TP): {} | Target Price (SL): {} | Current Percentage: {:+.2}%",
        target_wallet,
        mint,
        position.buy_price,
        current_price,
        format_price(position.tp_price()),
        format_price(position.sl_price()),
        pct_change,
    );
}

fn log_tp_sl_trigger(
    target_wallet: Pubkey,
    mint: Pubkey,
    trigger: TpSlTrigger,
    current_price: f64,
    pct_change: f64,
) {
    let reason = match trigger {
        TpSlTrigger::TakeProfit => "Take Profit",
        TpSlTrigger::StopLoss => "Stop Loss",
        TpSlTrigger::Stagnation => "Dead Trade",
    };
    info!(
        "TP/SL | Target {} mint {} | Triggered {} at {:.6} SOL ({:+.2}% vs buy price)",
        target_wallet, mint, reason, current_price, pct_change
    );
}

#[derive(Clone)]
pub struct GrpcDump {
    dir: PathBuf,
}

impl GrpcDump {
    pub fn new_from_env() -> anyhow::Result<Self> {
        let dir = std::env::var("GRPC_DUMP_DIR").unwrap_or_else(|_| "grpc_dumps".to_string());
        let path = PathBuf::from(dir);
        fs::create_dir_all(&path)?;
        Ok(Self { dir: path })
    }

    pub fn dir(&self) -> &Path {
        &self.dir
    }

    pub fn dump_failed_transaction(
        &self,
        update: &SubscribeUpdateTransaction,
        parsed_tx: &ParsedTransaction,
    ) -> anyhow::Result<()> {
        let signature = update
            .transaction
            .as_ref()
            .map(|info| info.signature.clone())
            .filter(|sig| !sig.is_empty())
            .map(|sig| bs58::encode(sig).into_string())
            .unwrap_or_else(|| format!("slot-{}", update.slot));

        let mut path = self.dir.clone();
        path.push(format!("{signature}.json"));

        if path.exists() {
            return Ok(());
        }

        let payload = json!({
            "signature": signature,
            "slot": update.slot,
            "reason": "target_event_mismatch",
            "transaction": update
                .transaction
                .as_ref()
                .map(|info| serialize_transaction_info(info)),
            "parsed_summary": summarize_parsed_transaction(parsed_tx),
        });

        fs::write(&path, serde_json::to_string_pretty(&payload)?)?;
        Ok(())
    }
}

fn serialize_transaction_info(info: &SubscribeUpdateTransactionInfo) -> Value {
    json!({
        "signature": encode_signature(&info.signature),
        "is_vote": info.is_vote,
        "index": info.index,
        "transaction": info.transaction.as_ref().map(|tx| serialize_confirmed_transaction(tx)),
        "meta": info.meta.as_ref().map(|meta| serialize_meta(meta)),
    })
}

fn serialize_confirmed_transaction(tx: &confirmed_block::Transaction) -> Value {
    json!({
        "signatures": tx.signatures.iter().map(|sig| encode_signature(sig)).collect::<Vec<_>>(),
        "message": tx.message.as_ref().map(|msg| serialize_message(msg)),
    })
}

fn serialize_message(message: &confirmed_block::Message) -> Value {
    json!({
        "header": message.header.as_ref().map(|header| json!({
            "num_required_signatures": header.num_required_signatures,
            "num_readonly_signed_accounts": header.num_readonly_signed_accounts,
            "num_readonly_unsigned_accounts": header.num_readonly_unsigned_accounts,
        })),
        "account_keys": message
            .account_keys
            .iter()
            .map(|key| encode_pubkey_like(key))
            .collect::<Vec<_>>(),
        "recent_blockhash": encode_pubkey_like(&message.recent_blockhash),
        "instructions": message
            .instructions
            .iter()
            .map(|ix| serialize_compiled_instruction(ix))
            .collect::<Vec<_>>(),
        "versioned": message.versioned,
        "address_table_lookups": message
            .address_table_lookups
            .iter()
            .map(|lookup| serialize_lookup(lookup))
            .collect::<Vec<_>>(),
    })
}

fn serialize_compiled_instruction(ix: &confirmed_block::CompiledInstruction) -> Value {
    json!({
        "program_id_index": ix.program_id_index,
        "accounts": ix.accounts.clone(),
        "data": encode_data(&ix.data),
    })
}

fn serialize_lookup(lookup: &confirmed_block::MessageAddressTableLookup) -> Value {
    json!({
        "account_key": encode_pubkey_like(&lookup.account_key),
        "writable_indexes": lookup.writable_indexes.clone(),
        "readonly_indexes": lookup.readonly_indexes.clone(),
    })
}

fn serialize_meta(meta: &confirmed_block::TransactionStatusMeta) -> Value {
    json!({
        "err": meta.err.as_ref().map(|err| encode_data(&err.err)),
        "fee": meta.fee,
        "pre_balances": meta.pre_balances,
        "post_balances": meta.post_balances,
        "inner_instructions": meta
            .inner_instructions
            .iter()
            .map(|inner| serialize_inner_instructions(inner))
            .collect::<Vec<_>>(),
        "log_messages": meta.log_messages,
        "pre_token_balances": meta
            .pre_token_balances
            .iter()
            .map(|bal| serialize_token_balance(bal))
            .collect::<Vec<_>>(),
        "post_token_balances": meta
            .post_token_balances
            .iter()
            .map(|bal| serialize_token_balance(bal))
            .collect::<Vec<_>>(),
        "rewards": meta.rewards.iter().map(|reward| serialize_reward(reward)).collect::<Vec<_>>(),
        "loaded_writable_addresses": meta
            .loaded_writable_addresses
            .iter()
            .map(|addr| encode_pubkey_like(addr))
            .collect::<Vec<_>>(),
        "loaded_readonly_addresses": meta
            .loaded_readonly_addresses
            .iter()
            .map(|addr| encode_pubkey_like(addr))
            .collect::<Vec<_>>(),
        "return_data": meta.return_data.as_ref().map(|data| serialize_return_data(data)),
        "compute_units_consumed": meta.compute_units_consumed,
    })
}

fn serialize_inner_instructions(inner: &confirmed_block::InnerInstructions) -> Value {
    json!({
        "index": inner.index,
        "instructions": inner
            .instructions
            .iter()
            .map(|ix| serialize_inner_instruction(ix))
            .collect::<Vec<_>>(),
    })
}

fn serialize_inner_instruction(ix: &confirmed_block::InnerInstruction) -> Value {
    json!({
        "program_id_index": ix.program_id_index,
        "accounts": ix.accounts.clone(),
        "data": encode_data(&ix.data),
        "stack_height": ix.stack_height,
    })
}

fn serialize_token_balance(balance: &confirmed_block::TokenBalance) -> Value {
    json!({
        "account_index": balance.account_index,
        "mint": &balance.mint,
        "owner": &balance.owner,
        "program_id": &balance.program_id,
        "ui_token_amount": balance
            .ui_token_amount
            .as_ref()
            .map(|amount| serialize_ui_token_amount(amount)),
    })
}

fn serialize_ui_token_amount(amount: &confirmed_block::UiTokenAmount) -> Value {
    json!({
        "ui_amount": amount.ui_amount,
        "decimals": amount.decimals,
        "amount": amount.amount,
        "ui_amount_string": amount.ui_amount_string,
    })
}

fn serialize_reward(reward: &confirmed_block::Reward) -> Value {
    json!({
        "pubkey": reward.pubkey,
        "lamports": reward.lamports,
        "post_balance": reward.post_balance,
        "reward_type": reward.reward_type,
        "commission": reward.commission,
    })
}

fn serialize_return_data(data: &confirmed_block::ReturnData) -> Value {
    json!({
        "program_id": encode_pubkey_like(&data.program_id),
        "data": encode_data(&data.data),
    })
}

fn summarize_parsed_transaction(parsed_tx: &ParsedTransaction) -> Value {
    let instructions = parsed_tx
        .instructions
        .iter()
        .map(|ix| {
            json!({
                "program_id": ix.program_id.to_string(),
                "index": ix.instruction_index,
                "stack_depth": ix.stack_depth,
                "details": format!("{:?}", ix.instruction),
            })
        })
        .collect::<Vec<_>>();
    let events = parsed_tx
        .events
        .iter()
        .map(|event| format!("{:?}", event))
        .collect::<Vec<_>>();

    json!({
        "instruction_count": parsed_tx.instructions.len(),
        "event_count": parsed_tx.events.len(),
        "instructions": instructions,
        "events": events,
        "token_balance_changes": parsed_tx.token_balances.len(),
    })
}

fn encode_signature(bytes: &[u8]) -> String {
    if bytes.is_empty() {
        return String::new();
    }
    bs58::encode(bytes).into_string()
}

fn encode_pubkey_like(bytes: &[u8]) -> String {
    if bytes.len() == 32 {
        bs58::encode(bytes).into_string()
    } else {
        encode_data(bytes)
    }
}

fn encode_data(bytes: &[u8]) -> String {
    BASE64_ENGINE.encode(bytes)
}

struct TokenBalanceIndex<'a> {
    by_owner_mint: HashMap<TokenBalanceKey, &'a TokenBalanceChange>,
    by_account: HashMap<Pubkey, &'a TokenBalanceChange>,
}

impl<'a> TokenBalanceIndex<'a> {
    fn empty() -> Self {
        Self {
            by_owner_mint: HashMap::new(),
            by_account: HashMap::new(),
        }
    }

    fn new(balances: &'a [TokenBalanceChange]) -> Self {
        let mut by_owner_mint = HashMap::with_capacity(balances.len());
        let mut by_account = HashMap::with_capacity(balances.len());
        for balance in balances {
            by_owner_mint.insert(balance.key, balance);
            if let Some(token_account) = balance.token_account {
                by_account.insert(token_account, balance);
            }
        }
        Self {
            by_owner_mint,
            by_account,
        }
    }

    fn by_owner_mint(&self, owner: &Pubkey, mint: &Pubkey) -> Option<&'a TokenBalanceChange> {
        self.by_owner_mint
            .get(&TokenBalanceKey {
                owner: *owner,
                mint: *mint,
            })
            .copied()
    }

    fn by_token_account(&self, account: &Pubkey) -> Option<&'a TokenBalanceChange> {
        self.by_account.get(account).copied()
    }

    fn native_balance_for_owner(&self, owner: &Pubkey) -> Option<&'a TokenBalanceChange> {
        self.by_owner_mint(owner, &native_mint::id())
    }
}

struct InstructionIndex<'a> {
    map: HashMap<(usize, usize), &'a ParsedInstructionWithContext>,
}

impl<'a> InstructionIndex<'a> {
    fn empty() -> Self {
        Self {
            map: HashMap::new(),
        }
    }

    fn new(instructions: &'a [ParsedInstructionWithContext]) -> Self {
        let mut map = HashMap::with_capacity(instructions.len());
        for instruction in instructions {
            map.insert(
                (instruction.instruction_index, instruction.stack_depth),
                instruction,
            );
        }
        Self { map }
    }

    fn get(&self, index: usize, depth: usize) -> Option<&'a ParsedInstructionWithContext> {
        self.map.get(&(index, depth)).copied()
    }

    /// Locate an instruction by index, preferring a specific stack depth but falling back
    /// to another depth or the closest matching instruction that satisfies the predicate.
    fn find_instruction_with_fallback<F>(
        &self,
        instruction_index: usize,
        preferred_depth: usize,
        fallback_depth: Option<usize>,
        mut predicate: F,
    ) -> Option<&'a ParsedInstructionWithContext>
    where
        F: FnMut(&ParsedInstructionWithContext) -> bool,
    {
        if let Some(ix) = self.get(instruction_index, preferred_depth) {
            if predicate(ix) {
                return Some(ix);
            }
        }

        if let Some(depth) = fallback_depth {
            if let Some(ix) = self.get(instruction_index, depth) {
                if predicate(ix) {
                    return Some(ix);
                }
            }
        }

        self.map
            .values()
            .copied()
            .filter(|ix| ix.instruction_index == instruction_index)
            .filter(|ix| predicate(ix))
            .min_by_key(|ix| ix.stack_depth)
    }
}

fn pump_fun_sell_accounts_from_event(
    event: &PumpFunEvent,
    instructions: &InstructionIndex<'_>,
) -> Option<PumpFunSellAccounts> {
    let PumpFunEvent::TradeEvent {
        context_instruction_index,
        context_position,
        context_parent_position,
        ..
    } = event;
    let instruction = instructions.find_instruction_with_fallback(
        *context_instruction_index,
        *context_position,
        Some(*context_parent_position),
        |ix| matches!(ix.instruction, ParsedInstruction::PumpFun(_)),
    )?;
    if let ParsedInstruction::PumpFun(ref parsed) = instruction.instruction {
        return pump_fun_accounts_from_instruction(parsed);
    }
    None
}

#[allow(unreachable_patterns)]
fn pump_fun_accounts_from_instruction(
    instruction: &PumpFunInstruction,
) -> Option<PumpFunSellAccounts> {
    match instruction {
        PumpFunInstruction::Buy {
            global,
            fee_recipient,
            mint,
            bonding_curve,
            associated_bonding_curve,
            associated_user,
            user,
            system_program,
            token_program,
            creator_vault,
            event_authority,
            program,
            fee_config,
            fee_program,
            ..
        }
        | PumpFunInstruction::BuyExactSolIn {
            global,
            fee_recipient,
            mint,
            bonding_curve,
            associated_bonding_curve,
            associated_user,
            user,
            system_program,
            token_program,
            creator_vault,
            event_authority,
            program,
            fee_config,
            fee_program,
            ..
        } => Some(PumpFunSellAccounts {
            global: *global,
            fee_recipient: *fee_recipient,
            mint: *mint,
            bonding_curve: *bonding_curve,
            associated_bonding_curve: *associated_bonding_curve,
            associated_user: *associated_user,
            user: *user,
            system_program: *system_program,
            creator_vault: *creator_vault,
            token_program: *token_program,
            event_authority: *event_authority,
            program: *program,
            fee_config: *fee_config,
            fee_program: *fee_program,
        }),
        PumpFunInstruction::Sell {
            global,
            fee_recipient,
            mint,
            bonding_curve,
            associated_bonding_curve,
            associated_user,
            user,
            system_program,
            creator_vault,
            token_program,
            event_authority,
            program,
            fee_config,
            fee_program,
            ..
        } => Some(PumpFunSellAccounts {
            global: *global,
            fee_recipient: *fee_recipient,
            mint: *mint,
            bonding_curve: *bonding_curve,
            associated_bonding_curve: *associated_bonding_curve,
            associated_user: *associated_user,
            user: *user,
            system_program: *system_program,
            creator_vault: *creator_vault,
            token_program: *token_program,
            event_authority: *event_authority,
            program: *program,
            fee_config: *fee_config,
            fee_program: *fee_program,
        }),
        _ => None,
    }
}

fn pump_amm_sell_accounts_from_event(
    event: &PumpAmmEvent,
    instructions: &InstructionIndex<'_>,
) -> Option<(PumpAmmSellAccounts, Pubkey)> {
    let (instruction_index, position, parent_position) = match event {
        PumpAmmEvent::BuyEvent {
            context_instruction_index,
            context_position,
            context_parent_position,
            ..
        }
        | PumpAmmEvent::SellEvent {
            context_instruction_index,
            context_position,
            context_parent_position,
            ..
        } => (
            *context_instruction_index,
            *context_position,
            *context_parent_position,
        ),
    };
    let instruction = instructions.find_instruction_with_fallback(
        instruction_index,
        position,
        Some(parent_position),
        |ix| matches!(ix.instruction, ParsedInstruction::PumpAmm(_)),
    )?;
    if let ParsedInstruction::PumpAmm(ref parsed) = instruction.instruction {
        return pump_amm_accounts_from_instruction(parsed);
    }
    None
}

#[allow(unreachable_patterns)]
fn pump_amm_accounts_from_instruction(
    instruction: &PumpAmmInstruction,
) -> Option<(PumpAmmSellAccounts, Pubkey)> {
    match instruction {
        PumpAmmInstruction::Buy {
            pool,
            user,
            global_config,
            base_mint,
            quote_mint,
            user_base_token_account,
            user_quote_token_account,
            pool_base_token_account,
            pool_quote_token_account,
            protocol_fee_recipient,
            protocol_fee_recipient_token_account,
            base_token_program,
            quote_token_program,
            system_program,
            associated_token_program,
            event_authority,
            program,
            coin_creator_vault_ata,
            coin_creator_vault_authority,
            fee_config,
            fee_program,
            ..
        }
        | PumpAmmInstruction::BuyExactQuoteIn {
            pool,
            user,
            global_config,
            base_mint,
            quote_mint,
            user_base_token_account,
            user_quote_token_account,
            pool_base_token_account,
            pool_quote_token_account,
            protocol_fee_recipient,
            protocol_fee_recipient_token_account,
            base_token_program,
            quote_token_program,
            system_program,
            associated_token_program,
            event_authority,
            program,
            coin_creator_vault_ata,
            coin_creator_vault_authority,
            fee_config,
            fee_program,
            ..
        } => Some((
            PumpAmmSellAccounts {
                pool: *pool,
                user: *user,
                global_config: *global_config,
                base_mint: *base_mint,
                quote_mint: *quote_mint,
                user_base_token_account: *user_base_token_account,
                user_quote_token_account: *user_quote_token_account,
                pool_base_token_account: *pool_base_token_account,
                pool_quote_token_account: *pool_quote_token_account,
                protocol_fee_recipient: *protocol_fee_recipient,
                protocol_fee_recipient_token_account: *protocol_fee_recipient_token_account,
                base_token_program: *base_token_program,
                quote_token_program: *quote_token_program,
                system_program: *system_program,
                associated_token_program: *associated_token_program,
                event_authority: *event_authority,
                program: *program,
                coin_creator_vault_ata: *coin_creator_vault_ata,
                coin_creator_vault_authority: *coin_creator_vault_authority,
                fee_config: *fee_config,
                fee_program: *fee_program,
            },
            *base_mint,
        )),
        PumpAmmInstruction::Sell {
            pool,
            user,
            global_config,
            base_mint,
            quote_mint,
            user_base_token_account,
            user_quote_token_account,
            pool_base_token_account,
            pool_quote_token_account,
            protocol_fee_recipient,
            protocol_fee_recipient_token_account,
            base_token_program,
            quote_token_program,
            system_program,
            associated_token_program,
            event_authority,
            program,
            coin_creator_vault_ata,
            coin_creator_vault_authority,
            fee_config,
            fee_program,
            ..
        } => Some((
            PumpAmmSellAccounts {
                pool: *pool,
                user: *user,
                global_config: *global_config,
                base_mint: *base_mint,
                quote_mint: *quote_mint,
                user_base_token_account: *user_base_token_account,
                user_quote_token_account: *user_quote_token_account,
                pool_base_token_account: *pool_base_token_account,
                pool_quote_token_account: *pool_quote_token_account,
                protocol_fee_recipient: *protocol_fee_recipient,
                protocol_fee_recipient_token_account: *protocol_fee_recipient_token_account,
                base_token_program: *base_token_program,
                quote_token_program: *quote_token_program,
                system_program: *system_program,
                associated_token_program: *associated_token_program,
                event_authority: *event_authority,
                program: *program,
                coin_creator_vault_ata: *coin_creator_vault_ata,
                coin_creator_vault_authority: *coin_creator_vault_authority,
                fee_config: *fee_config,
                fee_program: *fee_program,
            },
            *base_mint,
        )),
        _ => None,
    }
}

#[derive(Clone, Copy, Debug)]
pub enum TradeProtocol {
    PumpFun,
    PumpAmm,
}

impl TradeProtocol {
    fn cu_limit(&self, observed_cost: Option<u64>) -> u32 {
        match observed_cost {
            Some(cost) => {
                let buffered = cost + 20_000;
                buffered as u32
            }
            None => match self {
                TradeProtocol::PumpFun => PUMP_FUN_CU_LIMIT,
                TradeProtocol::PumpAmm => PUMP_AMM_CU_LIMIT,
            },
        }
    }

    fn processors(&self) -> &'static [ProcessorEndpoint] {
        &[
            ProcessorEndpoint::Helius,
            ProcessorEndpoint::Astralane,
            ProcessorEndpoint::Blockrazor,
            ProcessorEndpoint::Stellium,
            ProcessorEndpoint::Flashblock,
            ProcessorEndpoint::ZeroSlot,
            ProcessorEndpoint::StandardRpc,
        ]
    }
}

#[derive(Clone, Debug)]
pub struct ExecutionSignal {
    pub protocol: TradeProtocol,
    pub target: Pubkey,
    pub slot: u64,
    pub sol_amount: Option<u64>,
    pub token_amount: Option<u64>,
    pub slippage_bps: u16,
    pub side: TradeSide,
    pub payload: ExecutionPayload,
    pub parsing_time_us: u64,
    pub created_at: Instant,
    pub observed_cu_consumed: Option<u64>,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TradeSide {
    Buy,
    Sell,
}

impl ExecutionSignal {
    fn pump_fun_buy(
        target: TargetWalletConfig,
        slot: u64,
        sol: u64,
        token: u64,
        payload: ExecutionPayload,
        parsing_time_us: u64,
        observed_cu_consumed: Option<u64>,
    ) -> Self {
        Self {
            protocol: TradeProtocol::PumpFun,
            target: target.wallet,
            slot,
            sol_amount: Some(sol),
            token_amount: Some(token),
            slippage_bps: slippage_pct_to_bps(target.slippage_pct),
            side: TradeSide::Buy,
            payload,
            parsing_time_us,
            observed_cu_consumed,
            created_at: Instant::now(),
        }
    }

    fn pump_fun_sell(
        target: TargetWalletConfig,
        slot: u64,
        sol: u64,
        token: u64,
        payload: ExecutionPayload,
        parsing_time_us: u64,
        observed_cu_consumed: Option<u64>,
    ) -> Self {
        Self {
            protocol: TradeProtocol::PumpFun,
            target: target.wallet,
            slot,
            sol_amount: Some(sol),
            token_amount: Some(token),
            slippage_bps: slippage_pct_to_bps(target.slippage_pct),
            side: TradeSide::Sell,
            payload,
            parsing_time_us,
            observed_cu_consumed,
            created_at: Instant::now(),
        }
    }

    fn pump_amm_buy(
        target: TargetWalletConfig,
        slot: u64,
        sol_in: u64,
        base_out: u64,
        payload: ExecutionPayload,
        parsing_time_us: u64,
        observed_cu_consumed: Option<u64>,
    ) -> Self {
        Self {
            protocol: TradeProtocol::PumpAmm,
            target: target.wallet,
            slot,
            sol_amount: Some(sol_in),
            token_amount: Some(base_out),
            slippage_bps: slippage_pct_to_bps(target.slippage_pct),
            side: TradeSide::Buy,
            payload,
            parsing_time_us,
            observed_cu_consumed,
            created_at: Instant::now(),
        }
    }

    fn pump_amm_sell(
        target: TargetWalletConfig,
        slot: u64,
        sol_out: u64,
        base_in: u64,
        payload: ExecutionPayload,
        parsing_time_us: u64,
        observed_cu_consumed: Option<u64>,
    ) -> Self {
        Self {
            protocol: TradeProtocol::PumpAmm,
            target: target.wallet,
            slot,
            sol_amount: Some(sol_out),
            token_amount: Some(base_in),
            slippage_bps: slippage_pct_to_bps(target.slippage_pct),
            side: TradeSide::Sell,
            payload,
            parsing_time_us,
            observed_cu_consumed,
            created_at: Instant::now(),
        }
    }
}

#[derive(Clone, Debug)]
pub enum ExecutionPayload {
    PumpFunBuy(PumpFunBuyPayload),
    PumpFunSell(PumpFunSellPayload),
    PumpAmmBuy(PumpAmmBuyPayload),
    PumpAmmSell(PumpAmmSellPayload),
}

#[derive(Clone, Debug)]
pub struct PumpFunBuyPayload {
    pub accounts: BuyExactSolInAccounts,
    pub spendable_sol_in: u64,
    pub virtual_token_reserves: u128,
    pub virtual_sol_reserves: u128,
    pub real_token_reserves: u128,
    pub track_volume: bool,
}

#[derive(Clone, Debug)]
pub struct PumpFunSellPayload {
    pub accounts: PumpFunSellAccounts,
    pub amount: u64,
    pub virtual_token_reserves: u128,
    pub virtual_sol_reserves: u128,
}

#[derive(Clone, Debug)]
pub struct PumpAmmBuyPayload {
    pub accounts: BuyExactQuoteInAccounts,
    pub spendable_quote_in: u64,
    pub base_reserve: u64,
    pub quote_reserve: u64,
    pub fees: Fees,
    pub track_volume: bool,
}

#[derive(Clone, Debug)]
pub struct PumpAmmSellPayload {
    pub accounts: PumpAmmSellAccounts,
    pub base_amount_in: u64,
    pub base_reserve: u64,
    pub quote_reserve: u64,
    pub fees: Fees,
    pub expected_sol_out: u64,
}

pub struct PreparedExecution {
    pub protocol: TradeProtocol,
    pub target: Pubkey,
    pub slot: u64,
    pub nonce_slot: usize,
    pub plan: TxExecutionPlan,
    pub tips: Vec<(ProcessorEndpoint, Pubkey)>,
}

pub struct CopyTradeRuntime {
    #[allow(dead_code)]
    config: Arc<Config>,
    nonce_manager: Arc<NonceManager>,
    #[allow(dead_code)]
    executor: Arc<ExecutionPipeline>,
    confirmation_tracker: Arc<ConfirmationTracker>,
    cached_plans: Mutex<HashMap<usize, CachedPlan>>,
    next_slot: AtomicUsize,
}

struct CachedPlan {
    cu_limit: u32,
    plan: TxExecutionPlan,
}

#[derive(Clone, Copy, Debug)]
struct FeeSchedule {
    compute_unit_price_micro_lamports: u64,
    tip_lamports: u64,
}

impl FeeSchedule {
    fn matches_plan(self, plan: &TxExecutionPlan) -> bool {
        plan.compute_unit_price_micro_lamports == self.compute_unit_price_micro_lamports
            && plan.tip_lamports == self.tip_lamports
    }
}

impl CopyTradeRuntime {
    pub async fn execute(&self, signal: ExecutionSignal) -> Result<(), CopyTradeExecError> {
        let prepared = self.prepare_execution(&signal)?;
        debug!(
            "Prepared {:?} execution for target {} at slot {} using nonce slot {} (blockhash {}, cu_price={} -lamports, tip={} lamports)",
            signal.protocol,
            signal.target,
            signal.slot,
            prepared.nonce_slot,
            prepared.plan.nonce.blockhash,
            prepared.plan.compute_unit_price_micro_lamports,
            prepared.plan.tip_lamports
        );
        for (processor, tip) in &prepared.tips {
            debug!("Processor {} tip destination {}", processor.as_str(), tip);
        }
        self.dispatch(signal, prepared).await
    }

    pub fn new(
        config: Arc<Config>,
        nonce_manager: Arc<NonceManager>,
        executor: Arc<ExecutionPipeline>,
        confirmation_tracker: Arc<ConfirmationTracker>,
    ) -> Result<Self, NonceError> {
        let runtime = Self {
            config,
            nonce_manager,
            executor,
            confirmation_tracker,
            cached_plans: Mutex::new(HashMap::new()),
            next_slot: AtomicUsize::new(0),
        };
        runtime.prime_cache()?;
        Ok(runtime)
    }

    pub fn prepare_execution(
        &self,
        signal: &ExecutionSignal,
    ) -> Result<PreparedExecution, CopyTradeExecError> {
        let cu_limit = signal.protocol.cu_limit(signal.observed_cu_consumed);
        let fee_schedule = self.fee_schedule_for_signal(signal, cu_limit);
        let (slot_index, plan) = self.reserve_plan(cu_limit, fee_schedule)?;
        let tips = signal
            .protocol
            .processors()
            .iter()
            .map(|processor| {
                (
                    *processor,
                    ExecutionPipeline::random_tip_address(*processor),
                )
            })
            .collect();

        Ok(PreparedExecution {
            protocol: signal.protocol,
            target: signal.target,
            slot: signal.slot,
            nonce_slot: slot_index,
            plan,
            tips,
        })
    }

    pub fn handle_confirmed_transaction(&self, pending: &PendingConfirmation) {
        thread::sleep(Duration::from_millis(NONCE_REFRESH_DELAY_MS));
        let schedule = self.default_fee_schedule(pending.cu_limit);
        if let Err(err) = self.refresh_slot(pending.nonce_slot, pending.cu_limit, schedule) {
            warn!(
                "Failed to refresh nonce slot {} after {:?} confirmation: {err}",
                pending.nonce_slot, pending.protocol
            );
        } else {
            debug!(
                "Refreshed nonce slot {} after {:?} confirmation",
                pending.nonce_slot, pending.protocol
            );
            self.nonce_manager
                .log_nonce_state(&pending.prepared_nonce.account);
        }
    }

    pub fn handle_expired_confirmation(&self, pending: PendingConfirmation) {
        warn!(
            "{:?} transaction timed out before confirmation (nonce slot {})",
            pending.protocol, pending.nonce_slot
        );
        let schedule = self.default_fee_schedule(pending.cu_limit);
        if let Err(err) = self.refresh_slot(pending.nonce_slot, pending.cu_limit, schedule) {
            warn!(
                "Failed to refresh nonce slot {} after timeout: {err}",
                pending.nonce_slot
            );
        }
    }

    async fn dispatch(
        &self,
        signal: ExecutionSignal,
        prepared: PreparedExecution,
    ) -> Result<(), CopyTradeExecError> {
        let operator = self.config.operator_keypair();
        let operator_pubkey = operator.pubkey();
        let cu_limit = signal.protocol.cu_limit(signal.observed_cu_consumed);

        let trade_mint = match &signal.payload {
            ExecutionPayload::PumpFunBuy(payload) => payload.accounts.mint,
            ExecutionPayload::PumpFunSell(payload) => payload.accounts.mint,
            ExecutionPayload::PumpAmmBuy(payload) => payload.accounts.base_mint,
            ExecutionPayload::PumpAmmSell(payload) => payload.accounts.base_mint,
        };

        let build_start = Instant::now();
        let mut payloads = Vec::with_capacity(prepared.tips.len());
        for (processor, tip_destination) in &prepared.tips {
            let tx = self.build_transaction_for_processor(
                &signal,
                &prepared,
                *processor,
                *tip_destination,
                &operator_pubkey,
                operator.as_ref(),
            )?;
            let signature = tx
                .signatures
                .get(0)
                .cloned()
                .ok_or_else(|| CopyTradeExecError::UnsupportedInstruction)?
                .as_ref()
                .to_vec();
            let pending = PendingConfirmation {
                signature: signature.clone(),
                nonce_slot: prepared.nonce_slot,
                prepared_nonce: prepared.plan.nonce,
                cu_limit,
                protocol: signal.protocol,
                target: signal.target,
                mint: trade_mint,
                sent_at: Instant::now(),
            };
            self.confirmation_tracker.record(pending);
            let signature_str = bs58::encode(&signature).into_string();
            info!(
                "Dispatching {:?} tx {} for target {} mint {} via {} (nonce slot {}, tip dest {}, nonce hash {})",
                signal.protocol,
                signature_str,
                signal.target,
                trade_mint,
                processor.as_str(),
                prepared.nonce_slot,
                tip_destination,
                prepared.plan.nonce.blockhash
            );
            let encoded = ExecutionPipeline::encode_versioned_transaction(&tx)
                .map_err(CopyTradeExecError::Encoding)?;
            info!(
                "Tx {} base64 payload for {}: {}",
                signature_str,
                processor.as_str(),
                encoded
            );
            payloads.push((*processor, encoded, signature, signature_str));
        }
        let creation_duration = build_start.elapsed();

        enum SendOutcome {
            Success {
                processor: ProcessorEndpoint,
                signature: String,
                send_duration: Duration,
                total_duration: Duration,
            },
            Failure {
                processor: ProcessorEndpoint,
                signature: String,
                error: ExecutionError,
                send_duration: Duration,
                total_duration: Duration,
            },
        }

        let futures = payloads
            .into_iter()
            .map(|(processor, encoded, signature, signature_str)| {
                let executor = Arc::clone(&self.executor);
                let tracker = Arc::clone(&self.confirmation_tracker);
                let created_at = signal.created_at;
                async move {
                    let send_start = Instant::now();
                    match executor.send_base64(processor, &encoded).await {
                        Ok(_) => SendOutcome::Success {
                            processor,
                            signature: signature_str.clone(),
                            send_duration: send_start.elapsed(),
                            total_duration: created_at.elapsed(),
                        },
                        Err(err) => {
                            tracker.remove_signature(&signature);
                            SendOutcome::Failure {
                                processor,
                                signature: signature_str.clone(),
                                error: err,
                                send_duration: send_start.elapsed(),
                                total_duration: created_at.elapsed(),
                            }
                        }
                    }
                }
            });

        let outcomes = future::join_all(futures).await;
        let mut success = false;
        for outcome in &outcomes {
            match outcome {
                SendOutcome::Success {
                    processor,
                    signature,
                    ..
                } => {
                    success = true;
                    info!(
                        "{} accepted mirrored transaction {}",
                        processor.as_str(),
                        signature
                    );
                }
                SendOutcome::Failure {
                    processor,
                    signature,
                    error,
                    ..
                } => {
                    warn!(
                        "{} sendTransaction failed for {}: {}",
                        processor.as_str(),
                        signature,
                        error
                    );
                }
            }
        }

        let mut profile_lines = vec![
            format!("Parsing Time: {} s", signal.parsing_time_us),
            format!(
                "Transaction Creation + signing time: {} ms",
                creation_duration.as_millis()
            ),
        ];

        for outcome in &outcomes {
            match outcome {
                SendOutcome::Success {
                    processor,
                    send_duration,
                    total_duration,
                    ..
                } => profile_lines.push(format!(
                    "Sent to {} in {} ms (end-to-end {} ms)",
                    processor.as_str(),
                    send_duration.as_millis(),
                    total_duration.as_millis()
                )),
                SendOutcome::Failure {
                    processor,
                    send_duration,
                    total_duration,
                    error,
                    ..
                } => profile_lines.push(format!(
                    "Failed to send to {} after {} ms (end-to-end {} ms): {}",
                    processor.as_str(),
                    send_duration.as_millis(),
                    total_duration.as_millis(),
                    error
                )),
            }
        }

        info!(
            "{:?} profiling for target {}:\n    {}",
            signal.protocol,
            signal.target,
            profile_lines.join("\n    ")
        );

        if success {
            Ok(())
        } else {
            self.confirmation_tracker.cancel_slot(prepared.nonce_slot);
            self.restore_slot(prepared.nonce_slot, cu_limit, prepared.plan);
            Err(CopyTradeExecError::NoProcessorAccepted)
        }
    }

    fn build_transaction_for_processor(
        &self,
        signal: &ExecutionSignal,
        prepared: &PreparedExecution,
        processor: ProcessorEndpoint,
        tip_destination: Pubkey,
        operator_pubkey: &Pubkey,
        operator: &dyn Signer,
    ) -> Result<VersionedTransaction, CopyTradeExecError> {
        let instructions = self.build_instructions(
            signal,
            prepared,
            processor,
            tip_destination,
            operator_pubkey,
        )?;
        let mut message = Message::new(&instructions, Some(operator_pubkey));
        message.recent_blockhash = prepared.plan.nonce.blockhash;
        VersionedTransaction::try_new(VersionedMessage::Legacy(message), &[operator])
            .map_err(CopyTradeExecError::Signing)
    }

    fn build_instructions(
        &self,
        signal: &ExecutionSignal,
        prepared: &PreparedExecution,
        processor: ProcessorEndpoint,
        tip_destination: Pubkey,
        operator_pubkey: &Pubkey,
    ) -> Result<Vec<Instruction>, CopyTradeExecError> {
        let (compute_unit_price, tip_lamports) = if processor == ProcessorEndpoint::StandardRpc {
            let cu_limit = signal.protocol.cu_limit(signal.observed_cu_consumed);
            let tip_as_priority = if cu_limit > 0 {
                (prepared.plan.tip_lamports as u128 * 1_000_000 / cu_limit as u128) as u64
            } else {
                0
            };
            (
                prepared
                    .plan
                    .compute_unit_price_micro_lamports
                    .saturating_add(tip_as_priority),
                0,
            )
        } else {
            (
                prepared.plan.compute_unit_price_micro_lamports,
                prepared.plan.tip_lamports,
            )
        };

        match (&signal.payload, signal.protocol) {
            (ExecutionPayload::PumpFunBuy(payload), TradeProtocol::PumpFun) => {
                let mut accounts = payload.accounts.clone();
                retarget_pump_fun_buy_accounts(&mut accounts, operator_pubkey);
                let buy = pump::BuyExactSolInRequest {
                    accounts: &accounts,
                    spendable_sol_in: payload.spendable_sol_in,
                    virtual_token_reserves: payload.virtual_token_reserves,
                    virtual_sol_reserves: payload.virtual_sol_reserves,
                    real_token_reserves: payload.real_token_reserves,
                    slippage_bps: signal.slippage_bps,
                    track_volume: payload.track_volume,
                };
                let common = PumpFunCommonTxParams {
                    payer: *operator_pubkey,
                    nonce_account: prepared.plan.nonce.account,
                    nonce_authority: *operator_pubkey,
                    compute_unit_price_micro_lamports: compute_unit_price,
                    tip_destination,
                    tip_lamports,
                    cu_limit: signal.protocol.cu_limit(signal.observed_cu_consumed),
                    token_program: accounts.token_program,
                };
                let request = PumpFunBuyTxRequest {
                    common,
                    ata_owner: *operator_pubkey,
                    ata_payer: *operator_pubkey,
                    buy,
                };
                PumpFunTxBuilder::build_buy_transaction(request)
                    .map_err(CopyTradeExecError::PumpFunBuilder)
            }
            (ExecutionPayload::PumpFunSell(payload), TradeProtocol::PumpFun) => {
                let mut accounts = payload.accounts.clone();
                retarget_pump_fun_sell_accounts(&mut accounts, operator_pubkey);
                let sell = pump::SellRequest {
                    accounts: &accounts,
                    amount: payload.amount,
                    virtual_token_reserves: payload.virtual_token_reserves,
                    virtual_sol_reserves: payload.virtual_sol_reserves,
                    slippage_bps: signal.slippage_bps,
                };
                let common = PumpFunCommonTxParams {
                    payer: *operator_pubkey,
                    nonce_account: prepared.plan.nonce.account,
                    nonce_authority: *operator_pubkey,
                    compute_unit_price_micro_lamports: compute_unit_price,
                    tip_destination,
                    tip_lamports,
                    cu_limit: signal.protocol.cu_limit(signal.observed_cu_consumed),
                    token_program: accounts.token_program,
                };
                let request = PumpFunSellTxRequest { common, sell };
                PumpFunTxBuilder::build_sell_transaction(request)
                    .map_err(CopyTradeExecError::PumpFunBuilder)
            }
            (ExecutionPayload::PumpAmmBuy(payload), TradeProtocol::PumpAmm) => {
                let mut accounts = payload.accounts.clone();
                retarget_pump_amm_buy_accounts(&mut accounts, operator_pubkey);
                let buy = pump_amm::BuyExactQuoteInRequest {
                    accounts: &accounts,
                    spendable_quote_in: payload.spendable_quote_in,
                    base_reserve: payload.base_reserve,
                    quote_reserve: payload.quote_reserve,
                    fees: payload.fees,
                    slippage_bps: signal.slippage_bps,
                    track_volume: payload.track_volume,
                };
                let common = PumpAmmCommonTxParams {
                    payer: *operator_pubkey,
                    nonce_account: prepared.plan.nonce.account,
                    nonce_authority: *operator_pubkey,
                    compute_unit_price_micro_lamports: compute_unit_price,
                    tip_destination,
                    tip_lamports,
                    cu_limit: signal.protocol.cu_limit(signal.observed_cu_consumed),
                    base_token_program: accounts.base_token_program,
                };
                let request = PumpAmmBuyTxRequest {
                    common,
                    base_ata_owner: *operator_pubkey,
                    base_ata_payer: *operator_pubkey,
                    buy,
                };
                PumpAmmTxBuilder::build_buy_transaction(request)
                    .map_err(CopyTradeExecError::PumpAmmBuilder)
            }
            (ExecutionPayload::PumpAmmSell(payload), TradeProtocol::PumpAmm) => {
                let mut accounts = payload.accounts.clone();
                retarget_pump_amm_sell_accounts(&mut accounts, operator_pubkey);
                let sell = pump_amm::SellRequest {
                    accounts: &accounts,
                    base_amount_in: payload.base_amount_in,
                    base_reserve: payload.base_reserve,
                    quote_reserve: payload.quote_reserve,
                    fees: payload.fees,
                    slippage_bps: signal.slippage_bps,
                };
                let common = PumpAmmCommonTxParams {
                    payer: *operator_pubkey,
                    nonce_account: prepared.plan.nonce.account,
                    nonce_authority: *operator_pubkey,
                    compute_unit_price_micro_lamports: compute_unit_price,
                    tip_destination,
                    tip_lamports,
                    cu_limit: signal.protocol.cu_limit(signal.observed_cu_consumed),
                    base_token_program: accounts.base_token_program,
                };
                let request = PumpAmmSellTxRequest {
                    common,
                    quote_wrap_amount: payload.expected_sol_out,
                    sell,
                };
                PumpAmmTxBuilder::build_sell_transaction(request)
                    .map_err(CopyTradeExecError::PumpAmmBuilder)
            }
            _ => Err(CopyTradeExecError::UnsupportedInstruction),
        }
    }
    fn prime_cache(&self) -> Result<(), NonceError> {
        for slot in 0..self.nonce_slots() {
            let schedule = self.default_fee_schedule(PUMP_FUN_CU_LIMIT);
            self.refresh_slot(slot, PUMP_FUN_CU_LIMIT, schedule)?;
        }
        Ok(())
    }

    fn reserve_plan(
        &self,
        cu_limit: u32,
        fee_schedule: FeeSchedule,
    ) -> Result<(usize, TxExecutionPlan), NonceError> {
        let slot = self.next_slot.fetch_add(1, Ordering::Relaxed) % self.nonce_slots();
        {
            let mut cache = self.cached_plans.lock().unwrap();
            if let Some(entry) = cache.remove(&slot) {
                if entry.cu_limit == cu_limit && fee_schedule.matches_plan(&entry.plan) {
                    return Ok((slot, entry.plan));
                }
            }
        }
        let plan = self.refresh_slot(slot, cu_limit, fee_schedule)?;
        self.cached_plans.lock().unwrap().remove(&slot);
        Ok((slot, plan))
    }

    fn refresh_slot(
        &self,
        slot: usize,
        cu_limit: u32,
        fee_schedule: FeeSchedule,
    ) -> Result<TxExecutionPlan, NonceError> {
        let plan = self.nonce_manager.plan_for_slot(
            slot,
            cu_limit,
            fee_schedule.compute_unit_price_micro_lamports,
            fee_schedule.tip_lamports,
        )?;
        self.cached_plans
            .lock()
            .unwrap()
            .insert(slot, CachedPlan { cu_limit, plan });
        Ok(plan)
    }

    fn nonce_slots(&self) -> usize {
        self.nonce_manager.nonce_accounts().len().max(1)
    }

    fn restore_slot(&self, slot: usize, cu_limit: u32, plan: TxExecutionPlan) {
        self.cached_plans
            .lock()
            .unwrap()
            .insert(slot, CachedPlan { cu_limit, plan });
    }

    fn default_fee_schedule(&self, cu_limit: u32) -> FeeSchedule {
        FeeSchedule {
            compute_unit_price_micro_lamports: self
                .config
                .compute_unit_price_microlamports(cu_limit),
            tip_lamports: self.config.tx_tip_lamports(),
        }
    }

    fn fee_schedule_for_signal(&self, signal: &ExecutionSignal, cu_limit: u32) -> FeeSchedule {
        match signal.side {
            TradeSide::Buy => FeeSchedule {
                compute_unit_price_micro_lamports: self
                    .config
                    .buy_compute_unit_price_microlamports(cu_limit),
                tip_lamports: self.config.buy_tx_tip_lamports(),
            },
            TradeSide::Sell => FeeSchedule {
                compute_unit_price_micro_lamports: self
                    .config
                    .sell_compute_unit_price_microlamports(cu_limit),
                tip_lamports: self.config.sell_tx_tip_lamports(),
            },
        }
    }
}

#[derive(Debug, Error)]
pub enum CopyTradeExecError {
    #[error("nonce planning failed: {0}")]
    Nonce(#[from] NonceError),
    #[error("pump fun builder error: {0}")]
    PumpFunBuilder(#[from] PumpTransactionBuilderError),
    #[error("pump amm builder error: {0}")]
    PumpAmmBuilder(#[from] PumpAmmBuilderError),
    #[error("transaction signing failed: {0}")]
    Signing(#[from] SignerError),
    #[error("encoding error: {0}")]
    Encoding(ExecutionError),
    #[error("no processor accepted transaction")]
    NoProcessorAccepted,
    #[error("unsupported instruction for execution")]
    UnsupportedInstruction,
}

#[derive(Clone)]
pub struct PendingConfirmation {
    pub signature: Vec<u8>,
    pub nonce_slot: usize,
    pub prepared_nonce: PreparedNonce,
    pub cu_limit: u32,
    pub protocol: TradeProtocol,
    pub target: Pubkey,
    pub mint: Pubkey,
    pub sent_at: Instant,
}

pub struct ConfirmationTracker {
    inner: Mutex<PendingMaps>,
    runtime: Mutex<Option<Weak<CopyTradeRuntime>>>,
}

struct PendingMaps {
    by_signature: HashMap<Vec<u8>, PendingConfirmation>,
    by_slot: HashMap<usize, HashSet<Vec<u8>>>,
}

impl ConfirmationTracker {
    pub fn new() -> Self {
        Self {
            inner: Mutex::new(PendingMaps {
                by_signature: HashMap::new(),
                by_slot: HashMap::new(),
            }),
            runtime: Mutex::new(None),
        }
    }

    pub fn attach_runtime(&self, runtime: &Arc<CopyTradeRuntime>) {
        *self.runtime.lock().unwrap() = Some(Arc::downgrade(runtime));
    }

    pub fn record(self: &Arc<Self>, entry: PendingConfirmation) {
        {
            let mut guard = self.inner.lock().unwrap();
            guard
                .by_slot
                .entry(entry.nonce_slot)
                .or_default()
                .insert(entry.signature.clone());
            guard.by_signature.insert(entry.signature.clone(), entry);
        }
        let tracker = Arc::clone(self);
        tokio::spawn(async move {
            sleep(Duration::from_secs(CONFIRMATION_TIMEOUT_SECS)).await;
            tracker.expire_overdue();
        });
    }

    fn expire_overdue(&self) {
        let expired_entries = {
            let mut guard = self.inner.lock().unwrap();
            let now = Instant::now();
            let expired_signatures: Vec<_> = guard
                .by_signature
                .iter()
                .filter_map(|(signature, entry)| {
                    if now.duration_since(entry.sent_at)
                        >= Duration::from_secs(CONFIRMATION_TIMEOUT_SECS)
                    {
                        Some(signature.clone())
                    } else {
                        None
                    }
                })
                .collect();

            let mut removed = Vec::new();
            for signature in expired_signatures {
                if let Some(entry) = guard.by_signature.remove(&signature) {
                    if let Some(signatures) = guard.by_slot.get_mut(&entry.nonce_slot) {
                        signatures.retain(|sig| sig != &signature);
                        if signatures.is_empty() {
                            guard.by_slot.remove(&entry.nonce_slot);
                        }
                    }
                    removed.push(entry);
                }
            }
            removed
        };

        for entry in expired_entries {
            if let Some(runtime) = self
                .runtime
                .lock()
                .unwrap()
                .as_ref()
                .and_then(|weak| weak.upgrade())
            {
                runtime.handle_expired_confirmation(entry);
            }
        }
    }

    pub fn remove_signature(&self, signature: &[u8]) -> Option<PendingConfirmation> {
        let mut guard = self.inner.lock().unwrap();
        let key = signature.to_vec();
        let entry = guard.by_signature.remove(&key)?;
        if let Some(signatures) = guard.by_slot.get_mut(&entry.nonce_slot) {
            signatures.retain(|sig| sig.as_slice() != signature);
            if signatures.is_empty() {
                guard.by_slot.remove(&entry.nonce_slot);
            }
        }
        Some(entry)
    }

    pub fn take(&self, signature: &[u8]) -> Option<PendingConfirmation> {
        let mut guard = self.inner.lock().unwrap();
        let key = signature.to_vec();
        let entry = guard.by_signature.remove(&key)?;
        if let Some(signatures) = guard.by_slot.remove(&entry.nonce_slot) {
            for sig in signatures {
                if sig.as_slice() != entry.signature.as_slice() {
                    guard.by_signature.remove(&sig);
                }
            }
        }
        Some(entry)
    }

    pub fn cancel_slot(&self, slot: usize) {
        let mut guard = self.inner.lock().unwrap();
        if let Some(signatures) = guard.by_slot.remove(&slot) {
            for signature in signatures {
                guard.by_signature.remove(&signature);
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parsers::pump_amm::PumpAmmInstruction;
    use crate::parsers::pump_fun;
    use crate::parsers::pump_fun::PumpFunInstruction;

    #[test]
    fn trade_protocol_profiles() {
        assert_eq!(TradeProtocol::PumpFun.cu_limit(None), PUMP_FUN_CU_LIMIT);
        assert_eq!(TradeProtocol::PumpAmm.cu_limit(None), PUMP_AMM_CU_LIMIT);
        assert_eq!(TradeProtocol::PumpFun.cu_limit(Some(50_000)), 70_000);
        let pump_fun_processors = TradeProtocol::PumpFun.processors();
        assert_eq!(pump_fun_processors.len(), 6);
        assert_eq!(pump_fun_processors, TradeProtocol::PumpAmm.processors());
        assert!(pump_fun_processors.contains(&ProcessorEndpoint::Stellium));
        assert!(pump_fun_processors.contains(&ProcessorEndpoint::Flashblock));
    }

    #[test]
    fn proportional_sells_follow_example() {
        let mut ledger = MirrorLedger::default();
        let mint = Pubkey::new_unique();
        ledger.record_target_buy(mint, 1_000);
        ledger.record_operator_buy(mint, 100);

        let mut available = 100;
        let sell1 = ledger.plan_sell(mint, 250, available);
        assert_eq!(sell1, 25);
        available -= sell1;

        let sell2 = ledger.plan_sell(mint, 500, available);
        assert_eq!(sell2, 50);
        available -= sell2;

        let sell3 = ledger.plan_sell(mint, 250, available);
        assert_eq!(sell3, 25);
        available -= sell3;

        assert_eq!(available, 0);
    }

    #[test]
    fn instruction_index_falls_back_to_parent_depth() {
        let new_key = || Pubkey::new_unique();
        let pump_fun_instruction = ParsedInstructionWithContext {
            instruction: ParsedInstruction::PumpFun(PumpFunInstruction::Sell {
                amount: 1,
                min_sol_output: 1,
                global: new_key(),
                fee_recipient: new_key(),
                mint: new_key(),
                bonding_curve: new_key(),
                associated_bonding_curve: new_key(),
                associated_user: new_key(),
                user: new_key(),
                system_program: new_key(),
                creator_vault: new_key(),
                token_program: new_key(),
                event_authority: new_key(),
                program: pump_fun::PUMP_FUN_PROGRAM_ID,
                fee_config: new_key(),
                fee_program: new_key(),
            }),
            program_id: pump_fun::PUMP_FUN_PROGRAM_ID,
            instruction_index: 2,
            stack_depth: 0,
        };

        let cpi_event_instruction = ParsedInstructionWithContext {
            instruction: ParsedInstruction::Unknown {
                program_id: pump_fun::PUMP_FUN_PROGRAM_ID,
                data: vec![],
            },
            program_id: pump_fun::PUMP_FUN_PROGRAM_ID,
            instruction_index: 2,
            stack_depth: 1,
        };

        let instructions = vec![pump_fun_instruction.clone(), cpi_event_instruction];
        let index = InstructionIndex::new(&instructions);

        let found = index.find_instruction_with_fallback(2, 1, Some(0), |ix| {
            matches!(ix.instruction, ParsedInstruction::PumpFun(_))
        });

        assert!(found.is_some());
        assert_eq!(found.unwrap().stack_depth, 0);
        assert!(matches!(
            found.unwrap().instruction,
            ParsedInstruction::PumpFun(_)
        ));
    }

    #[test]
    fn pump_fun_payload_builds_with_parent_depth() {
        let new_key = || Pubkey::new_unique();
        let pump_fun_buy = ParsedInstructionWithContext {
            instruction: ParsedInstruction::PumpFun(PumpFunInstruction::BuyExactSolIn {
                spendable_sol_in: 1,
                min_tokens_out: 1,
                track_volume: true,
                global: new_key(),
                fee_recipient: new_key(),
                mint: new_key(),
                bonding_curve: new_key(),
                associated_bonding_curve: new_key(),
                associated_user: new_key(),
                user: new_key(),
                system_program: new_key(),
                token_program: new_key(),
                creator_vault: new_key(),
                event_authority: new_key(),
                program: pump_fun::PUMP_FUN_PROGRAM_ID,
                global_volume_accumulator: new_key(),
                user_volume_accumulator: new_key(),
                fee_config: new_key(),
                fee_program: new_key(),
            }),
            program_id: pump_fun::PUMP_FUN_PROGRAM_ID,
            instruction_index: 4,
            stack_depth: 0,
        };
        let instructions = vec![pump_fun_buy.clone()];
        let index = InstructionIndex::new(&instructions);

        let event = PumpFunEvent::TradeEvent {
            mint: new_key(),
            sol_amount: 1,
            token_amount: 1,
            is_buy: true,
            user: new_key(),
            timestamp: 0,
            virtual_sol_reserves: 1,
            virtual_token_reserves: 1,
            real_sol_reserves: 1,
            real_token_reserves: 1,
            fee_recipient: new_key(),
            fee_basis_points: 0,
            fee: 0,
            creator: new_key(),
            creator_fee_basis_points: 0,
            creator_fee: 0,
            track_volume: true,
            total_unclaimed_tokens: 0,
            total_claimed_tokens: 0,
            current_sol_volume: 0,
            last_update_timestamp: 0,
            ix_name: "buy".to_string(),
            context_instruction_index: 4,
            context_position: 1,
            context_parent_position: 0,
        };

        let payload = build_pump_fun_payload(&event, &index);
        assert!(matches!(payload, Some(ExecutionPayload::PumpFunBuy(_))));
    }

    #[test]
    fn pump_amm_payload_builds_with_parent_depth() {
        let new_key = || Pubkey::new_unique();
        let pump_amm_sell = ParsedInstructionWithContext {
            instruction: ParsedInstruction::PumpAmm(PumpAmmInstruction::Sell {
                base_amount_in: 1,
                min_quote_amount_out: 1,
                pool: new_key(),
                user: new_key(),
                global_config: new_key(),
                base_mint: new_key(),
                quote_mint: new_key(),
                user_base_token_account: new_key(),
                user_quote_token_account: new_key(),
                pool_base_token_account: new_key(),
                pool_quote_token_account: new_key(),
                protocol_fee_recipient: new_key(),
                protocol_fee_recipient_token_account: new_key(),
                base_token_program: new_key(),
                quote_token_program: new_key(),
                system_program: new_key(),
                associated_token_program: new_key(),
                event_authority: new_key(),
                program: crate::parsers::pump_amm::PUMP_AMM_PROGRAM_ID,
                coin_creator_vault_ata: new_key(),
                coin_creator_vault_authority: new_key(),
                fee_config: new_key(),
                fee_program: new_key(),
            }),
            program_id: crate::parsers::pump_amm::PUMP_AMM_PROGRAM_ID,
            instruction_index: 7,
            stack_depth: 0,
        };
        let instructions = vec![pump_amm_sell.clone()];
        let index = InstructionIndex::new(&instructions);

        let event = PumpAmmEvent::SellEvent {
            timestamp: 0,
            base_amount_in: 1,
            min_quote_amount_out: 1,
            user_base_token_reserves: 0,
            user_quote_token_reserves: 0,
            pool_base_token_reserves: 10,
            pool_quote_token_reserves: 10,
            quote_amount_out: 1,
            lp_fee_basis_points: 0,
            lp_fee: 0,
            protocol_fee_basis_points: 0,
            protocol_fee: 0,
            quote_amount_out_without_lp_fee: 1,
            user_quote_amount_out: 1,
            pool: new_key(),
            user: new_key(),
            user_base_token_account: new_key(),
            user_quote_token_account: new_key(),
            protocol_fee_recipient: new_key(),
            protocol_fee_recipient_token_account: new_key(),
            coin_creator: new_key(),
            coin_creator_fee_basis_points: 0,
            coin_creator_fee: 0,
            context_instruction_index: 7,
            context_position: 1,
            context_parent_position: 0,
        };

        let payload = build_pump_amm_sell_payload(&event, &index);
        assert!(matches!(payload, Some(ExecutionPayload::PumpAmmSell(_))));
    }

    #[test]
    fn operator_total_tokens_sums_protocol_balances() {
        let mint = Pubkey::new_unique();
        let mut operator = OperatorState::new(Pubkey::new_unique());
        operator
            .pump_fun
            .update_token_position(mint, None, 1_000, DEFAULT_TOKEN_DECIMALS, 0);
        operator
            .pump_amm
            .update_token_position(mint, None, 500, DEFAULT_TOKEN_DECIMALS, 0);
        assert_eq!(operator.total_tokens(&mint), 1_500);
    }

    #[test]
    fn cross_positions_enable_mixed_protocol_sells() {
        let config = TargetWalletConfig {
            wallet: Pubkey::new_unique(),
            slippage_pct: 1.0,
            mirror_sells: true,
            take_profit_pct: None,
            stop_loss_pct: None,
        };
        let mut state = WalletTargetState::new(config);
        let mint = Pubkey::new_unique();
        state.pump_fun_positions.record_target_buy(mint, 1_000);
        state.mirror_positions.record_target_buy(mint, 1_000);
        state.pump_fun_positions.record_operator_buy(mint, 100);
        state.mirror_positions.record_operator_buy(mint, 100);
        assert_eq!(state.pump_amm_positions.plan_sell(mint, 500, 100), 0);
        let mirrored = state.mirror_positions.plan_sell(mint, 500, 100);
        assert_eq!(mirrored, 50);
    }
}
</file>

<file path="executor.rs">
use std::{
    fmt,
    sync::{
        atomic::{AtomicU64, Ordering},
        Arc,
    },
    time::Duration,
};

use base64::{engine::general_purpose, Engine as _};
use log::{debug, info, warn};
use rand::{seq::SliceRandom, thread_rng};
use reqwest::{
    header::{HeaderMap, HeaderValue, CONTENT_TYPE},
    Client,
};
use serde::Deserialize;
use serde_json::json;
use solana_sdk::{pubkey::Pubkey, transaction::VersionedTransaction};
use tokio::{task::JoinHandle, time::sleep};

use crate::{
    config::Config,
    swap::constants::{
        ASTRALANE_TIP_ACCOUNTS, BLOCKRAZOR_TIP_ACCOUNTS, FLASH_BLOCK_TIP_ACCOUNTS,
        HELIUS_TIP_ACCOUNTS, STELLIUM_TIP_ACCOUNTS, ZERO_SLOT_TIP_ACCOUNTS,
    },
};

#[allow(dead_code)]
const HELIUS_SEND_ENDPOINT: &str = "http://fra-sender.helius-rpc.com/fast";
const HELIUS_PING_ENDPOINT: &str = "http://fra-sender.helius-rpc.com/ping";
const HELIUS_INTERVAL: Duration = Duration::from_secs(5);
#[allow(dead_code)]
const ASTRALANE_SEND_ENDPOINT: &str = "http://fr.gateway.astralane.io/iris2";
const ASTRALANE_HEALTH_ENDPOINT: &str = "http://fr.gateway.astralane.io/gethealth";
const ASTRALANE_INTERVAL: Duration = Duration::from_secs(5);
#[allow(dead_code)]
const BLOCKRAZOR_SEND_ENDPOINT: &str = "http://frankfurt.solana.blockrazor.xyz:443/sendTransaction";
const BLOCKRAZOR_HEALTH_ENDPOINT: &str = "http://frankfurt.solana.blockrazor.xyz:443/health";
const BLOCKRAZOR_INTERVAL: Duration = Duration::from_secs(5);
const STELLIUM_ENDPOINT: &str = "http://fra1.flashrpc.com";
const STELLIUM_INTERVAL: Duration = Duration::from_secs(5);
const FLASHBLOCK_ENDPOINT: &str = "http://fra.flashblock.trade";
const FLASHBLOCK_INTERVAL: Duration = Duration::from_secs(5);
const ZERO_SLOT_SEND_ENDPOINT: &str = "http://de1.0slot.trade";
const ZERO_SLOT_HEALTH_ENDPOINT: &str = "http://de1.0slot.trade/health";
const ZERO_SLOT_INTERVAL: Duration = Duration::from_secs(5);
#[allow(dead_code)]
static REQUEST_COUNTER: AtomicU64 = AtomicU64::new(1);

#[derive(Debug, Deserialize)]
struct HealthResponse {
    #[serde(default)]
    result: Option<String>,
    #[serde(default)]
    status: Option<String>,
}

pub fn spawn_connection_warmers(config: Arc<Config>) -> Vec<JoinHandle<()>> {
    let client = build_http_client();
    let mut handles = Vec::new();

    handles.push(tokio::spawn(warm_helius(client.clone())));

    if !config.astralane_api_key.is_empty() {
        handles.push(tokio::spawn(warm_astralane(
            client.clone(),
            config.astralane_api_key.clone(),
        )));
    } else {
        info!("Astralane API key missing; skipping Astralane connection warmer");
    }

    if !config.blockrazor_api_key.is_empty() {
        handles.push(tokio::spawn(warm_blockrazor(
            client.clone(),
            config.blockrazor_api_key.clone(),
        )));
    } else {
        info!("Blockrazor API key missing; skipping Blockrazor connection warmer");
    }

    if !config.stellium_api_key.is_empty() {
        handles.push(tokio::spawn(warm_stellium(
            client.clone(),
            config.stellium_api_key.clone(),
        )));
    } else {
        info!("Stellium API key missing; skipping Stellium connection warmer");
    }

    if !config.flashblock_api_key.is_empty() {
        handles.push(tokio::spawn(warm_flashblock(client.clone())));
    } else {
        info!("Flashblock API key missing; skipping Flashblock connection warmer");
    }

    if !config.zero_slot_api_key.is_empty() {
        handles.push(tokio::spawn(warm_zero_slot(client)));
    } else {
        info!("Zero Slot API key missing; skipping Zero Slot connection warmer");
    }

    handles
}

async fn warm_helius(client: Client) {
    loop {
        match client.get(HELIUS_PING_ENDPOINT).send().await {
            Ok(response) => {
                if let Err(err) = response.error_for_status_ref() {
                    warn!(
                        "Helius ping failed (status {}): {err}",
                        err.status().unwrap_or_default()
                    );
                }
            }
            Err(err) => warn!("Helius ping request error: {err}"),
        }

        sleep(HELIUS_INTERVAL).await;
    }
}

async fn warm_astralane(client: Client, api_key: String) {
    let mut headers = HeaderMap::new();
    if let Ok(value) = HeaderValue::from_str(&api_key) {
        headers.insert("api_key", value);
    } else {
        warn!("Astralane API key contains invalid characters for header; skipping warmer");
        return;
    }

    loop {
        match client
            .get(ASTRALANE_HEALTH_ENDPOINT)
            .headers(headers.clone())
            .send()
            .await
        {
            Ok(response) => {
                if let Err(err) = response.error_for_status_ref() {
                    warn!(
                        "Astralane health ping failed (status {}): {err}",
                        err.status().unwrap_or_default()
                    );
                }
            }
            Err(err) => warn!("Astralane health request error: {err}"),
        }

        sleep(ASTRALANE_INTERVAL).await;
    }
}

async fn warm_blockrazor(client: Client, api_key: String) {
    let mut headers = HeaderMap::new();
    headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
    match HeaderValue::from_str(&api_key) {
        Ok(value) => {
            headers.insert("apikey", value);
        }
        Err(_) => {
            warn!("Blockrazor API key contains invalid characters; skipping warmer");
            return;
        }
    };

    loop {
        match client
            .get(BLOCKRAZOR_HEALTH_ENDPOINT)
            .headers(headers.clone())
            .send()
            .await
        {
            Ok(response) => match response.error_for_status() {
                Ok(resp) => {
                    if let Ok(body) = resp.text().await {
                        if let Ok(parsed) = serde_json::from_str::<HealthResponse>(&body) {
                            if let Some(status) = parsed.status.or(parsed.result) {
                                debug!("Blockrazor health: {}", status);
                            }
                        }
                    }
                }
                Err(err) => warn!(
                    "Blockrazor health failed (status {}): {err}",
                    err.status().unwrap_or_default()
                ),
            },
            Err(err) => warn!("Blockrazor health request error: {err}"),
        }

        sleep(BLOCKRAZOR_INTERVAL).await;
    }
}

async fn warm_stellium(client: Client, api_key: String) {
    let api_key = api_key.trim().to_owned();
    if api_key.is_empty() {
        warn!("Stellium API key missing; skipping warmer");
        return;
    }
    let url = format!("{STELLIUM_ENDPOINT}/{api_key}");
    loop {
        match client.get(&url).send().await {
            Ok(response) => {
                if let Err(err) = response.error_for_status_ref() {
                    warn!(
                        "Stellium warm ping failed (status {}): {err}",
                        err.status().unwrap_or_default()
                    );
                }
            }
            Err(err) => warn!("Stellium warm request error: {err}"),
        }
        sleep(STELLIUM_INTERVAL).await;
    }
}

async fn warm_flashblock(client: Client) {
    loop {
        match client.get(FLASHBLOCK_ENDPOINT).send().await {
            Ok(response) => {
                if let Err(err) = response.error_for_status_ref() {
                    warn!(
                        "Flashblock warm ping failed (status {}): {err}",
                        err.status().unwrap_or_default()
                    );
                }
            }
            Err(err) => warn!("Flashblock warm request error: {err}"),
        }
        sleep(FLASHBLOCK_INTERVAL).await;
    }
}

async fn warm_zero_slot(client: Client) {
    loop {
        match client.get(ZERO_SLOT_HEALTH_ENDPOINT).send().await {
            Ok(response) => {
                if let Err(err) = response.error_for_status_ref() {
                    warn!(
                        "Zero Slot warm ping failed (status {}): {err}",
                        err.status().unwrap_or_default()
                    );
                }
            }
            Err(err) => warn!("Zero Slot warm request error: {err}"),
        }
        sleep(ZERO_SLOT_INTERVAL).await;
    }
}

fn build_http_client() -> Client {
    Client::builder()
        .tcp_nodelay(true)
        .pool_idle_timeout(Some(Duration::from_secs(90)))
        .pool_max_idle_per_host(8)
        .build()
        .expect("failed to build reqwest client")
}

#[allow(dead_code)]
#[derive(Clone)]
pub struct ExecutionPipeline {
    client: Client,
    config: Arc<Config>,
}

#[allow(dead_code)]
impl ExecutionPipeline {
    pub fn new(config: Arc<Config>) -> Self {
        Self {
            client: build_http_client(),
            config,
        }
    }

    pub fn random_tip_address(processor: ProcessorEndpoint) -> Pubkey {
        match processor {
            ProcessorEndpoint::Helius => random_tip_from(&HELIUS_TIP_ACCOUNTS),
            ProcessorEndpoint::Astralane => random_tip_from(&ASTRALANE_TIP_ACCOUNTS),
            ProcessorEndpoint::Blockrazor => random_tip_from(&BLOCKRAZOR_TIP_ACCOUNTS),
            ProcessorEndpoint::Stellium => random_tip_from(&STELLIUM_TIP_ACCOUNTS),
            ProcessorEndpoint::Flashblock => random_tip_from(&FLASH_BLOCK_TIP_ACCOUNTS),
            ProcessorEndpoint::ZeroSlot => random_tip_from(&ZERO_SLOT_TIP_ACCOUNTS),
            ProcessorEndpoint::StandardRpc => Pubkey::default(),
        }
    }

    pub fn encode_versioned_transaction(
        tx: &VersionedTransaction,
    ) -> Result<String, ExecutionError> {
        let bytes =
            bincode::serialize(tx).map_err(|err| ExecutionError::Serialization(err.to_string()))?;
        Ok(general_purpose::STANDARD.encode(bytes))
    }

    pub fn encode_bytes(bytes: &[u8]) -> String {
        general_purpose::STANDARD.encode(bytes)
    }

    pub async fn send_base64(
        &self,
        processor: ProcessorEndpoint,
        encoded_tx: &str,
    ) -> Result<(), ExecutionError> {
        match processor {
            ProcessorEndpoint::Helius => self.send_helius(encoded_tx).await,
            ProcessorEndpoint::Astralane => self.send_astralane(encoded_tx).await,
            ProcessorEndpoint::Blockrazor => self.send_blockrazor(encoded_tx).await,
            ProcessorEndpoint::Stellium => self.send_stellium(encoded_tx).await,
            ProcessorEndpoint::Flashblock => self.send_flashblock(encoded_tx).await,
            ProcessorEndpoint::ZeroSlot => self.send_zero_slot(encoded_tx).await,
            ProcessorEndpoint::StandardRpc => self.send_rpc(encoded_tx).await,
        }
    }

    async fn send_helius(&self, encoded_tx: &str) -> Result<(), ExecutionError> {
        let body = json!({
            "id": next_request_id("helius"),
            "jsonrpc": "2.0",
            "method": "sendTransaction",
            "params": [
                encoded_tx,
                {
                    "encoding": "base64",
                    "skipPreflight": true,
                    "maxRetries": 0
                }
            ]
        });

        let response = self
            .client
            .post(HELIUS_SEND_ENDPOINT)
            .json(&body)
            .send()
            .await
            .map_err(ExecutionError::Request)?;

        let status = response.status();
        let text = response.text().await.unwrap_or_default();
        if !status.is_success() {
            return Err(ExecutionError::HttpResponse {
                processor: ProcessorEndpoint::Helius,
                status: Some(status),
                body: text,
            });
        }

        info!(
            "Helius sendTransaction response {} body {}",
            status.as_u16(),
            text
        );
        Ok(())
    }

    async fn send_astralane(&self, encoded_tx: &str) -> Result<(), ExecutionError> {
        let api_key = self.config.astralane_api_key.as_str().trim().to_owned();
        if api_key.is_empty() {
            return Err(ExecutionError::MissingAstralaneKey);
        }

        let url = format!("{ASTRALANE_SEND_ENDPOINT}?api-key={api_key}&method=sendTransaction");

        let response = self
            .client
            .post(url)
            .header(CONTENT_TYPE, "text/plain")
            .body(encoded_tx.to_owned())
            .send()
            .await
            .map_err(ExecutionError::Request)?;

        let status = response.status();
        let text = response.text().await.unwrap_or_default();
        if !status.is_success() {
            return Err(ExecutionError::HttpResponse {
                processor: ProcessorEndpoint::Astralane,
                status: Some(status),
                body: text,
            });
        }

        info!(
            "Astralane sendTransaction response {} body {}",
            status.as_u16(),
            text
        );
        Ok(())
    }

    async fn send_blockrazor(&self, encoded_tx: &str) -> Result<(), ExecutionError> {
        let api_key = self.config.blockrazor_api_key.as_str().trim().to_owned();
        if api_key.is_empty() {
            return Err(ExecutionError::MissingBlockrazorKey);
        }

        let mut headers = HeaderMap::new();
        headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
        let api_key_header =
            HeaderValue::from_str(&api_key).map_err(|_| ExecutionError::InvalidApiKey {
                processor: ProcessorEndpoint::Blockrazor,
            })?;
        headers.insert("apikey", api_key_header);

        let body = json!({
            "transaction": encoded_tx,
            "mode": "fast"
        });

        let response = self
            .client
            .post(BLOCKRAZOR_SEND_ENDPOINT)
            .headers(headers)
            .json(&body)
            .send()
            .await
            .map_err(ExecutionError::Request)?;

        let status = response.status();
        let text = response.text().await.unwrap_or_default();
        if !status.is_success() {
            return Err(ExecutionError::HttpResponse {
                processor: ProcessorEndpoint::Blockrazor,
                status: Some(status),
                body: text,
            });
        }

        info!(
            "Blockrazor sendTransaction response {} body {}",
            status.as_u16(),
            text
        );
        Ok(())
    }

    async fn send_stellium(&self, encoded_tx: &str) -> Result<(), ExecutionError> {
        let api_key = self.config.stellium_api_key.as_str().trim().to_owned();
        if api_key.is_empty() {
            return Err(ExecutionError::MissingStelliumKey);
        }

        let url = format!("{STELLIUM_ENDPOINT}/{api_key}");
        let body = json!({
            "jsonrpc": "2.0",
            "id": next_request_id("stellium"),
            "method": "sendTransaction",
            "params": [
                [encoded_tx],
                {
                    "encoding": "base64"
                }
            ]
        });

        let response = self
            .client
            .post(url)
            .json(&body)
            .send()
            .await
            .map_err(ExecutionError::Request)?;

        let status = response.status();
        let text = response.text().await.unwrap_or_default();
        if !status.is_success() {
            return Err(ExecutionError::HttpResponse {
                processor: ProcessorEndpoint::Stellium,
                status: Some(status),
                body: text,
            });
        }

        info!(
            "Stellium sendTransaction response {} body {}",
            status.as_u16(),
            text
        );
        Ok(())
    }

    async fn send_flashblock(&self, encoded_tx: &str) -> Result<(), ExecutionError> {
        let api_key = self.config.flashblock_api_key.as_str().trim().to_owned();
        if api_key.is_empty() {
            return Err(ExecutionError::MissingFlashblockKey);
        }

        let mut headers = HeaderMap::new();
        headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
        let auth_header =
            HeaderValue::from_str(&api_key).map_err(|_| ExecutionError::InvalidApiKey {
                processor: ProcessorEndpoint::Flashblock,
            })?;
        headers.insert("Authorization", auth_header);

        let body = json!({
            "jsonrpc": "2.0",
            "id": next_numeric_request_id(),
            "method": "sendTransaction",
            "params": [
                [encoded_tx],
                {
                    "encoding": "base64"
                }
            ]
        });

        let response = self
            .client
            .post(FLASHBLOCK_ENDPOINT)
            .headers(headers)
            .json(&body)
            .send()
            .await
            .map_err(ExecutionError::Request)?;

        let status = response.status();
        let text = response.text().await.unwrap_or_default();
        if !status.is_success() {
            return Err(ExecutionError::HttpResponse {
                processor: ProcessorEndpoint::Flashblock,
                status: Some(status),
                body: text,
            });
        }

        info!(
            "Flashblock sendTransaction response {} body {}",
            status.as_u16(),
            text
        );
        Ok(())
    }

    async fn send_zero_slot(&self, encoded_tx: &str) -> Result<(), ExecutionError> {
        let api_key = self.config.zero_slot_api_key.as_str().trim().to_owned();
        if api_key.is_empty() {
            return Err(ExecutionError::MissingZeroSlotKey);
        }

        let url = format!("{}/?api-key={}", ZERO_SLOT_SEND_ENDPOINT, api_key);

        let body = json!({
            "jsonrpc": "2.0",
            "id": next_numeric_request_id(),
            "method": "sendTransaction",
            "params": [
                encoded_tx,
                {
                    "encoding": "base64"
                }
            ]
        });

        let response = self
            .client
            .post(url)
            .header("Content-Type", "application/json")
            .json(&body)
            .send()
            .await
            .map_err(ExecutionError::Request)?;

        let status = response.status();
        let text = response.text().await.unwrap_or_default();
        if !status.is_success() {
            return Err(ExecutionError::HttpResponse {
                processor: ProcessorEndpoint::ZeroSlot,
                status: Some(status),
                body: text,
            });
        }

        info!(
            "ZeroSlot sendTransaction response {} body {}",
            status.as_u16(),
            text
        );
        Ok(())
    }

    async fn send_rpc(&self, encoded_tx: &str) -> Result<(), ExecutionError> {
        let url = self.config.rpc_url.as_str().trim();
        if url.is_empty() {
            return Err(ExecutionError::MissingRpcUrl);
        }

        let body = json!({
            "jsonrpc": "2.0",
            "id": next_numeric_request_id(),
            "method": "sendTransaction",
            "params": [
                encoded_tx,
                {
                    "encoding": "base64",
                    "skipPreflight": true,
                    "maxRetries": 0
                }
            ]
        });

        let response = self
            .client
            .post(url)
            .header("Content-Type", "application/json")
            .json(&body)
            .send()
            .await
            .map_err(ExecutionError::Request)?;

        let status = response.status();
        let text = response.text().await.unwrap_or_default();
        if !status.is_success() {
            return Err(ExecutionError::HttpResponse {
                processor: ProcessorEndpoint::StandardRpc,
                status: Some(status),
                body: text,
            });
        }

        info!(
            "StandardRpc sendTransaction response {} body {}",
            status.as_u16(),
            text
        );
        Ok(())
    }
}

#[allow(dead_code)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum ProcessorEndpoint {
    Helius,
    Astralane,
    Blockrazor,
    Stellium,
    Flashblock,
    ZeroSlot,
    StandardRpc,
}

impl ProcessorEndpoint {
    pub fn as_str(&self) -> &'static str {
        match self {
            ProcessorEndpoint::Helius => "Helius",
            ProcessorEndpoint::Astralane => "Astralane",
            ProcessorEndpoint::Blockrazor => "Blockrazor",
            ProcessorEndpoint::Stellium => "Stellium",
            ProcessorEndpoint::Flashblock => "Flashblock",
            ProcessorEndpoint::ZeroSlot => "ZeroSlot",
            ProcessorEndpoint::StandardRpc => "StandardRpc",
        }
    }
}

impl fmt::Display for ProcessorEndpoint {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.as_str())
    }
}

#[allow(dead_code)]
#[derive(thiserror::Error, Debug)]
pub enum ExecutionError {
    #[error("Astralane API key missing")]
    MissingAstralaneKey,
    #[error("Blockrazor API key missing")]
    MissingBlockrazorKey,
    #[error("Stellium API key missing")]
    MissingStelliumKey,
    #[error("Flashblock API key missing")]
    MissingFlashblockKey,
    #[error("Zero Slot API key missing")]
    MissingZeroSlotKey,
    #[error("Standard RPC URL missing")]
    MissingRpcUrl,
    #[error("{processor} API key contains invalid characters")]
    InvalidApiKey { processor: ProcessorEndpoint },
    #[error("{processor} returned HTTP error {status:?}: {body}")]
    HttpResponse {
        processor: ProcessorEndpoint,
        status: Option<reqwest::StatusCode>,
        body: String,
    },
    #[error("request error: {0}")]
    Request(#[from] reqwest::Error),
    #[error("serialization error: {0}")]
    Serialization(String),
}

#[allow(dead_code)]
fn random_tip_from(tips: &[Pubkey]) -> Pubkey {
    let mut rng = thread_rng();
    *tips
        .choose(&mut rng)
        .expect("tip account list should not be empty")
}

#[allow(dead_code)]
fn next_request_id(prefix: &str) -> String {
    let counter = REQUEST_COUNTER.fetch_add(1, Ordering::Relaxed);
    format!("{prefix}-{counter}")
}

fn next_numeric_request_id() -> u64 {
    REQUEST_COUNTER.fetch_add(1, Ordering::Relaxed)
}
</file>

<file path="lazy_signature.rs">
use std::fmt;
use std::sync::OnceLock;

/// A signature that lazily encodes to base58 string
#[derive(Clone)]
pub struct LazySignature {
    raw: Vec<u8>,
    encoded: OnceLock<String>,
}

impl LazySignature {
    /// Create a new lazy signature from raw bytes
    pub fn new(raw: Vec<u8>) -> Self {
        Self {
            raw,
            encoded: OnceLock::new(),
        }
    }

    /// Get the raw signature bytes
    pub fn raw(&self) -> &[u8] {
        &self.raw
    }

    /// Get the base58-encoded signature string
    pub fn encoded(&self) -> &str {
        self.encoded
            .get_or_init(|| bs58::encode(&self.raw).into_string())
    }

    /// Convert to a base58 string (consumes self)
    pub fn into_string(self) -> String {
        self.encoded
            .into_inner()
            .unwrap_or_else(|| bs58::encode(&self.raw).into_string())
    }
}

impl fmt::Debug for LazySignature {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("LazySignature")
            .field("signature", &self.encoded())
            .finish()
    }
}

impl fmt::Display for LazySignature {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.encoded())
    }
}

impl PartialEq for LazySignature {
    fn eq(&self, other: &Self) -> bool {
        self.raw == other.raw
    }
}

impl Eq for LazySignature {}

impl std::hash::Hash for LazySignature {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.raw.hash(state);
    }
}

impl From<Vec<u8>> for LazySignature {
    fn from(raw: Vec<u8>) -> Self {
        Self::new(raw)
    }
}

impl From<&[u8]> for LazySignature {
    fn from(raw: &[u8]) -> Self {
        Self::new(raw.to_vec())
    }
}

impl AsRef<[u8]> for LazySignature {
    fn as_ref(&self) -> &[u8] {
        &self.raw
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_lazy_signature_creation() {
        let raw = vec![1, 2, 3, 4, 5];
        let sig = LazySignature::new(raw.clone());
        assert_eq!(sig.raw(), &raw);
    }

    #[test]
    fn test_lazy_encoding() {
        let raw = vec![1, 2, 3, 4, 5];
        let sig = LazySignature::new(raw.clone());

        // First call should compute the encoding
        let encoded1 = sig.encoded();
        // Second call should return the cached value
        let encoded2 = sig.encoded();

        assert_eq!(encoded1, encoded2);
        assert_eq!(encoded1, bs58::encode(&raw).into_string());
    }

    #[test]
    fn test_equality() {
        let raw1 = vec![1, 2, 3, 4, 5];
        let raw2 = vec![1, 2, 3, 4, 5];
        let raw3 = vec![5, 4, 3, 2, 1];

        let sig1 = LazySignature::new(raw1);
        let sig2 = LazySignature::new(raw2);
        let sig3 = LazySignature::new(raw3);

        assert_eq!(sig1, sig2);
        assert_ne!(sig1, sig3);
    }

    #[test]
    fn test_display() {
        let raw = vec![1, 2, 3, 4, 5];
        let sig = LazySignature::new(raw.clone());
        let expected = bs58::encode(&raw).into_string();

        assert_eq!(format!("{}", sig), expected);
    }

    #[test]
    fn test_into_string() {
        let raw = vec![1, 2, 3, 4, 5];
        let sig = LazySignature::new(raw.clone());
        let expected = bs58::encode(&raw).into_string();

        assert_eq!(sig.into_string(), expected);
    }
}
</file>

<file path="main.rs">
mod config;
mod copytrade;
mod executor;
mod lazy_signature;
mod nonce;
mod parsers;
mod program_registry;
mod serialization;
mod swap;
mod transaction_processor;

use log::{debug, error, info, warn};
use tokio::sync::mpsc;
use {
    futures::{sink::SinkExt, stream::StreamExt},
    solana_rpc_client::rpc_client::RpcClient,
    std::{collections::HashMap, env, sync::Arc, time::Duration},
    tonic::transport::channel::ClientTlsConfig,
    yellowstone_grpc_client::{GeyserGrpcClient, Interceptor},
    yellowstone_grpc_proto::{
        geyser::SubscribeRequestFilterTransactions,
        prelude::{
            subscribe_update::UpdateOneof, CommitmentLevel, SubscribeRequest, SubscribeRequestPing,
            SubscribeUpdateTransaction,
        },
    },
};

use crate::{
    config::Config,
    copytrade::{ConfirmationTracker, CopyTradeRuntime, CopyTrader, GrpcDump, TraderMessage},
    executor::ExecutionPipeline,
    nonce::NonceManager,
    program_registry::ProgramRegistry,
    transaction_processor::{ParsedTransaction, TransactionProcessor},
};

type TxnFilterMap = HashMap<String, SubscribeRequestFilterTransactions>;

const PUMP_FUN: &str = "6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P";
const PUMP_AMM: &str = "pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA";
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    env::set_var(
        env_logger::DEFAULT_FILTER_ENV,
        env::var_os(env_logger::DEFAULT_FILTER_ENV).unwrap_or_else(|| "info".into()),
    );
    env_logger::init();

    let config = Arc::new(Config::load()?);
    log_startup_summary(&config);
    info!(
        "Operator {} ready | sol_balance={:.4} | rpc={} | grpc={}",
        config.operator_pubkey(),
        0.0,
        config.rpc_url,
        config.grpc_endpoint
    );
    let _connection_warmers = executor::spawn_connection_warmers(Arc::clone(&config));

    // Create program registry with default parsers
    let registry = Arc::new(ProgramRegistry::with_defaults());
    info!("Created program registry with {} parsers", registry.len());

    let nonce_manager = Arc::new(NonceManager::new(Arc::clone(&config))?);
    info!(
        "Loaded {} nonce account(s) for operator",
        nonce_manager.nonce_accounts().len()
    );

    // Create transaction processor
    let processor = Arc::new(TransactionProcessor::new(registry));

    let execution_pipeline = Arc::new(ExecutionPipeline::new(Arc::clone(&config)));
    let confirmation_tracker = Arc::new(ConfirmationTracker::new());
    let copy_trade_runtime = Arc::new(CopyTradeRuntime::new(
        Arc::clone(&config),
        Arc::clone(&nonce_manager),
        Arc::clone(&execution_pipeline),
        Arc::clone(&confirmation_tracker),
    )?);
    confirmation_tracker.attach_runtime(&copy_trade_runtime);

    let grpc_dump = match env::var("GRPC_DUMP") {
        Ok(value) if value.eq_ignore_ascii_case("true") => match GrpcDump::new_from_env() {
            Ok(dump) => {
                info!(
                    "gRPC dump enabled; writing failed target transactions to {}",
                    dump.dir().display()
                );
                Some(Arc::new(dump))
            }
            Err(err) => {
                warn!("Failed to initialize gRPC dump directory: {err:?}");
                None
            }
        },
        _ => None,
    };

    let (trader_tx, trader_rx) = mpsc::channel(1000);
    let trader = CopyTrader::new(
        Arc::clone(&config),
        Some(Arc::clone(&copy_trade_runtime)),
        grpc_dump.clone(),
    );
    tokio::spawn(trader.run(trader_rx));

    let client = connect_geyser(&config).await?;
    debug!("Connected");

    let request = build_subscribe_request()?;
    geyser_subscribe(client, request, processor, trader_tx, confirmation_tracker).await?;

    Ok(())
}

async fn geyser_subscribe(
    mut client: GeyserGrpcClient<impl Interceptor>,
    request: SubscribeRequest,
    processor: Arc<TransactionProcessor>,
    trader_tx: mpsc::Sender<TraderMessage>,
    confirmations: Arc<ConfirmationTracker>,
) -> anyhow::Result<()> {
    let (mut subscribe_tx, mut stream) = client.subscribe_with_request(Some(request)).await?;

    debug!("stream opened");

    while let Some(message) = stream.next().await {
        match message {
            Ok(msg) => match msg.update_oneof {
                Some(UpdateOneof::Transaction(update)) => {
                    process_transaction_update(update, &processor, &trader_tx, &confirmations)
                        .await;
                }
                Some(UpdateOneof::Ping(_)) => {
                    subscribe_tx
                        .send(SubscribeRequest {
                            ping: Some(SubscribeRequestPing { id: 1 }),
                            ..Default::default()
                        })
                        .await?;
                }
                Some(UpdateOneof::Pong(_)) => {}
                None => {
                    error!("update not found in the message");
                    break;
                }
                _ => {}
            },
            Err(error) => {
                error!("error: {error:?}");
                break;
            }
        }
    }

    debug!("stream closed");
    Ok(())
}

/// Process a transaction update from the gRPC stream
async fn process_transaction_update(
    update: SubscribeUpdateTransaction,
    processor: &Arc<TransactionProcessor>,
    trader_tx: &mpsc::Sender<TraderMessage>,
    confirmations: &Arc<ConfirmationTracker>,
) {
    // Extract transaction info
    let tx_info = match update.transaction.as_ref() {
        Some(info) => info,
        None => {
            error!("Transaction update missing transaction info");
            return;
        }
    };

    // Extract signature
    let signature = &tx_info.signature;
    if signature.is_empty() {
        error!("Transaction update missing signature");
        return;
    }

    // Log the signature at debug level to avoid clutter
    debug!(
        "Processing transaction: {}",
        bs58::encode(signature).into_string()
    );

    // Process the transaction
    match processor.process_yellowstone_transaction(signature, tx_info) {
        Ok(parsed_tx) => {
            // Log parsing performance metrics at debug to reduce noise
            let sig_str = bs58::encode(&parsed_tx.signature.raw()).into_string();
            debug!(
                "Transaction {} parsed in {}s | Instructions: {} | Events: {}",
                sig_str,
                parsed_tx.total_parsing_time_us,
                parsed_tx.instructions.len(),
                parsed_tx.events.len()
            );
            log_parsed_details(&sig_str, &parsed_tx);
            let pending = confirmations.take(parsed_tx.signature.raw());
            if let Some(ref confirmation) = pending {
                let latency = confirmation.sent_at.elapsed();
                info!(
                    "{:?} transaction {} landed on Geyser in {:?}",
                    confirmation.protocol, sig_str, latency
                );
            }
            let message = TraderMessage::ProcessTransaction {
                parsed_tx: Box::new(parsed_tx),
                confirmation: pending,
                update: Some(update),
            };
            if let Err(err) = trader_tx.send(message).await {
                warn!("Failed to enqueue transaction for trader: {err}");
            }
        }
        Err(e) => {
            warn!(
                "Failed to parse transaction {}: {:?}",
                bs58::encode(signature).into_string(),
                e
            );
        }
    }
}

fn log_startup_summary(config: &Config) {
    let rpc = RpcClient::new_with_timeout(config.rpc_url.clone(), Duration::from_secs(10));
    let operator = config.operator_pubkey();
    let balance_lamports = match rpc.get_balance(&operator) {
        Ok(value) => value,
        Err(err) => {
            warn!("Failed to fetch operator SOL balance: {err}");
            0
        }
    };
    let balance_sol = balance_lamports as f64 / 1_000_000_000.0;

    info!(
        "Startup | operator={} | sol={:.4} | buy_sol={:.4} | priority_fees={:.4} | tip_sol={:.6}",
        operator, balance_sol, config.buy_amount_sol, config.priority_fees, config.tx_tip_sol,
    );
    info!(
        "Endpoints | rpc={} | grpc={}",
        config.rpc_url, config.grpc_endpoint
    );

    if config.target_wallets.is_empty() {
        info!("Targets | none configured");
    } else {
        for (idx, target) in config.target_wallets.iter().enumerate() {
            info!(
                "Target {:02} | wallet={} | slippage={:.2}%",
                idx + 1,
                target.wallet,
                target.slippage_pct,
            );
        }
    }
}

fn log_parsed_details(signature: &str, parsed_tx: &ParsedTransaction) {
    const MAX_ITEMS: usize = 3;

    if parsed_tx.instructions.is_empty() && parsed_tx.events.is_empty() {
        debug!(
            "Transaction {} has no parsed instructions or events",
            signature
        );
        return;
    }

    for instruction in parsed_tx.instructions.iter().take(MAX_ITEMS) {
        debug!(
            "Tx {} | Instruction idx={} depth={} program={} kind={:?}",
            signature,
            instruction.instruction_index,
            instruction.stack_depth,
            instruction.program_id,
            instruction.instruction
        );
    }

    if parsed_tx.instructions.len() > MAX_ITEMS {
        debug!(
            "Tx {} |  {} more instructions omitted",
            signature,
            parsed_tx.instructions.len() - MAX_ITEMS
        );
    }

    for (event_idx, event) in parsed_tx.events.iter().take(MAX_ITEMS).enumerate() {
        debug!("Tx {} | Event {} -> {:?}", signature, event_idx, event);
    }

    if parsed_tx.events.len() > MAX_ITEMS {
        debug!(
            "Tx {} |  {} more events omitted",
            signature,
            parsed_tx.events.len() - MAX_ITEMS
        );
    }
}

async fn connect_geyser(config: &Config) -> anyhow::Result<GeyserGrpcClient<impl Interceptor>> {
    let mut builder = GeyserGrpcClient::build_from_shared(config.grpc_endpoint.clone())?
        .connect_timeout(Duration::from_secs(10))
        .timeout(Duration::from_secs(10))
        .tls_config(ClientTlsConfig::new().with_native_roots())?
        .max_decoding_message_size(1024 * 1024 * 1024)
        .tcp_nodelay(true);

    if let Some(token) = &config.grpc_x_token {
        builder = builder.x_token(Some(token.clone()))?;
    }

    builder.connect().await.map_err(Into::into)
}

fn build_subscribe_request() -> anyhow::Result<SubscribeRequest> {
    let mut transactions: TxnFilterMap = HashMap::new();

    transactions.insert(
        "client".to_owned(),
        SubscribeRequestFilterTransactions {
            vote: Some(false),
            failed: Some(false),
            account_include: vec![PUMP_FUN.to_string(), PUMP_AMM.to_string()],
            account_exclude: vec![],
            account_required: vec![],
            signature: None,
        },
    );

    Ok(SubscribeRequest {
        accounts: HashMap::default(),
        slots: HashMap::default(),
        transactions,
        transactions_status: HashMap::default(),
        blocks: HashMap::default(),
        blocks_meta: HashMap::default(),
        entry: HashMap::default(),
        commitment: Some(CommitmentLevel::Processed as i32),
        accounts_data_slice: Vec::default(),
        ping: None,
        from_slot: None,
    })
}
</file>

<file path="nonce.rs">
use log::{info, warn};
use serde_json::{json, Value};
use solana_client::{rpc_client::RpcClient, rpc_request::RpcRequest};
use solana_rpc_client_api::client_error::Error as RpcClientError;
use solana_sdk::{
    hash::Hash,
    nonce::state::State as NonceState,
    pubkey::Pubkey,
    signature::{Keypair, Signature, Signer},
    system_instruction,
    transaction::Transaction,
};
use std::{
    collections::HashSet,
    fs,
    path::{Path, PathBuf},
    str::FromStr,
    sync::Arc,
    time::Duration,
};

use crate::config::Config;

pub struct NonceManager {
    rpc: RpcClient,
    operator: Arc<Keypair>,
    config: Arc<Config>,
    pub nonce_accounts: Vec<PubkeySlot>,
}

#[derive(Clone, Copy, Debug)]
pub struct PubkeySlot {
    pub index: usize,
    pub pubkey: Pubkey,
}

#[derive(Clone, Copy, Debug)]
pub struct PreparedNonce {
    pub account: Pubkey,
    pub blockhash: Hash,
}

#[derive(Clone, Copy, Debug)]
pub struct TxExecutionPlan {
    pub nonce: PreparedNonce,
    pub compute_unit_price_micro_lamports: u64,
    pub tip_lamports: u64,
}

impl NonceManager {
    pub fn new(config: Arc<Config>) -> Result<Self, NonceError> {
        let rpc = RpcClient::new_with_timeout(config.rpc_url.clone(), Duration::from_secs(10));

        let mut nonce_accounts = Vec::new();
        for (i, maybe_pubkey) in config.nonce_accounts.iter().enumerate() {
            if let Some(pubkey) = maybe_pubkey {
                nonce_accounts.push(PubkeySlot {
                    index: i,
                    pubkey: *pubkey,
                });
            }
        }

        let mut manager = Self {
            rpc,
            operator: config.operator_keypair(),
            config,
            nonce_accounts,
        };

        manager.ensure_nonce_accounts()?;
        manager.log_nonce_states();

        Ok(manager)
    }

    fn ensure_nonce_accounts(&mut self) -> Result<(), NonceError> {
        let mut modified = false;
        let target_count = self.config.nonce_accounts.len();

        for slot in 0..target_count {
            if self.nonce_accounts.iter().any(|entry| entry.index == slot) {
                continue;
            }

            let new_nonce = self.create_nonce_account()?;
            self.nonce_accounts.push(PubkeySlot {
                index: slot,
                pubkey: new_nonce,
            });
            modified = true;
        }

        self.nonce_accounts.sort_by_key(|entry| entry.index);
        if modified {
            self.persist_nonce_accounts()?;
        }
        Ok(())
    }

    fn create_nonce_account(&self) -> Result<Pubkey, NonceError> {
        let nonce_keypair = Keypair::new();
        let rent = self
            .rpc
            .get_minimum_balance_for_rent_exemption(NonceState::size())
            .map_err(NonceError::Rpc)?;

        let instructions = system_instruction::create_nonce_account(
            &self.operator.pubkey(),
            &nonce_keypair.pubkey(),
            &self.operator.pubkey(),
            rent,
        );

        let recent_blockhash = self.rpc.get_latest_blockhash().map_err(NonceError::Rpc)?;

        let transaction = Transaction::new_signed_with_payer(
            &instructions,
            Some(&self.operator.pubkey()),
            &[self.operator.as_ref(), &nonce_keypair],
            recent_blockhash,
        );

        self.rpc
            .send_and_confirm_transaction(&transaction)
            .map_err(NonceError::Rpc)?;

        Ok(nonce_keypair.pubkey())
    }

    fn fetch_nonce_blockhash_json(&self, nonce: &Pubkey) -> Result<Hash, NonceError> {
        let params = json!([
            nonce.to_string(),
            {
                "commitment": "processed",
                "encoding": "jsonParsed"
            }
        ]);
        let response: Value = self
            .rpc
            .send(RpcRequest::GetAccountInfo, params)
            .map_err(NonceError::Rpc)?;
        info!(
            "Nonce RPC response | account={} | response={}",
            nonce, response
        );
        let value = response
            .get("value")
            .ok_or(NonceError::InvalidState(*nonce))?;
        if value.is_null() {
            return Err(NonceError::InvalidState(*nonce));
        }
        let info = value
            .get("data")
            .and_then(|data| data.get("parsed"))
            .and_then(|parsed| parsed.get("info"))
            .ok_or_else(|| NonceError::MissingField {
                account: *nonce,
                field: "parsed.info".to_string(),
            })?;
        let blockhash_str = info
            .get("blockhash")
            .and_then(Value::as_str)
            .ok_or_else(|| NonceError::MissingField {
                account: *nonce,
                field: "blockhash".to_string(),
            })?;
        Hash::from_str(blockhash_str).map_err(|e| NonceError::ParseBlockhash(e.to_string()))
    }

    pub fn log_nonce_states(&self) {
        for entry in &self.nonce_accounts {
            match self.fetch_nonce_blockhash_json(&entry.pubkey) {
                Ok(hash) => info!(
                    "Nonce slot {} | Account {} | Blockhash {}",
                    entry.index, entry.pubkey, hash
                ),
                Err(err) => warn!(
                    "Failed to fetch nonce state for slot {} ({:?}): {}",
                    entry.index, entry.pubkey, err
                ),
            }
        }
    }

    pub fn log_nonce_state(&self, pubkey: &Pubkey) {
        match self.fetch_nonce_blockhash_json(pubkey) {
            Ok(hash) => info!(
                "Nonce refreshed | Account: {} | New blockhash: {}",
                pubkey, hash
            ),
            Err(err) => warn!("Failed to fetch nonce state for {}: {}", pubkey, err),
        }
    }

    pub fn advance_nonce(&self, nonce: &Pubkey) -> Result<Signature, NonceError> {
        let ix = system_instruction::advance_nonce_account(nonce, &self.operator.pubkey());
        let bh = self.rpc.get_latest_blockhash().map_err(NonceError::Rpc)?;
        let tx = Transaction::new_signed_with_payer(
            &[ix],
            Some(&self.operator.pubkey()),
            &[self.operator.as_ref()],
            bh,
        );
        self.rpc
            .send_and_confirm_transaction(&tx)
            .map_err(NonceError::Rpc)
    }

    pub fn nonce_accounts(&self) -> &[PubkeySlot] {
        &self.nonce_accounts
    }

    pub fn prepare_nonce(&self, slot: usize) -> Result<PreparedNonce, NonceError> {
        let entry = self
            .nonce_accounts
            .iter()
            .find(|entry| entry.index == slot)
            .ok_or(NonceError::MissingSlot(slot))?;
        let blockhash = self.fetch_nonce_blockhash_json(&entry.pubkey)?;
        Ok(PreparedNonce {
            account: entry.pubkey,
            blockhash,
        })
    }

    pub fn plan_for_slot(
        &self,
        slot: usize,
        _compute_units: u32,
        compute_unit_price_micro_lamports: u64,
        tip_lamports: u64,
    ) -> Result<TxExecutionPlan, NonceError> {
        let nonce = self.prepare_nonce(slot)?;
        Ok(TxExecutionPlan {
            nonce,
            compute_unit_price_micro_lamports,
            tip_lamports,
        })
    }

    fn persist_nonce_accounts(&self) -> Result<(), NonceError> {
        let mut updates = Vec::new();

        for entry in &self.nonce_accounts {
            let key = format!("NONCE_ACCOUNT_{}", entry.index + 1);
            updates.push((key, Some(entry.pubkey.to_string())));
        }

        write_env_updates(self.config.env_path.as_path(), &updates)?;
        Ok(())
    }
}

fn write_env_updates(path: &Path, updates: &[(String, Option<String>)]) -> Result<(), NonceError> {
    let mut existing_lines = if path.exists() {
        fs::read_to_string(path)
            .map_err(|e| NonceError::Io(path.into(), e))?
            .lines()
            .map(|line| line.to_string())
            .collect::<Vec<_>>()
    } else {
        Vec::new()
    };

    let mut processed: HashSet<String> = HashSet::new();
    for line in existing_lines.iter_mut() {
        if let Some((key, _)) = split_key_value(line) {
            if let Some((_, value)) = updates.iter().find(|(k, _)| k == key) {
                processed.insert(key.to_string());
                *line = format!("{key}={}", value.clone().unwrap_or_default());
            }
        }
    }

    for (key, value) in updates {
        if processed.contains(key) {
            continue;
        }
        existing_lines.push(format!("{key}={}", value.clone().unwrap_or_default()));
    }

    let tmp_path = path.with_extension("env.tmp");
    fs::write(&tmp_path, existing_lines.join("\n") + "\n")
        .map_err(|e| NonceError::Io(tmp_path.clone(), e))?;
    fs::rename(&tmp_path, path).map_err(|e| NonceError::Io(path.into(), e))?;
    Ok(())
}

fn split_key_value(line: &str) -> Option<(&str, &str)> {
    if line.trim_start().starts_with('#') || line.trim().is_empty() {
        return None;
    }
    let mut parts = line.splitn(2, '=');
    let key = parts.next()?.trim();
    let value = parts.next().unwrap_or("").trim();
    if key.is_empty() {
        None
    } else {
        Some((key, value))
    }
}

#[derive(thiserror::Error, Debug)]
pub enum NonceError {
    #[error("rpc error: {0}")]
    Rpc(#[from] RpcClientError),
    #[error("invalid nonce account state for {0}")]
    InvalidState(Pubkey),
    #[error("nonce slot {0} is not configured")]
    MissingSlot(usize),
    #[error("io error for {0:?}")]
    Io(PathBuf, #[source] std::io::Error),
    #[error("nonce account {0} data is not json-parsed nonce")]
    InvalidEncoding(Pubkey),
    #[error("nonce account {account} missing field {field}")]
    MissingField { account: Pubkey, field: String },
    #[error("failed to parse nonce blockhash: {0}")]
    ParseBlockhash(String),
}
</file>

<file path="program_registry.rs">
use crate::parsers::{
    pump_amm::PumpAmmParser,
    pump_fun::{PumpFunParser, PUMP_FUN_PROGRAM_ID},
    ProgramParser,
};
use solana_sdk::pubkey::Pubkey;
use std::collections::HashMap;
use std::sync::Arc;

/// Registry that holds all program parsers
#[derive(Debug)]
pub struct ProgramRegistry {
    parsers: HashMap<Pubkey, Arc<dyn ProgramParser>>,
}

impl ProgramRegistry {
    /// Create a new empty registry
    pub fn new() -> Self {
        Self {
            parsers: HashMap::new(),
        }
    }

    /// Create a registry with default parsers
    pub fn with_defaults() -> Self {
        let mut registry = Self::new();

        // Register default parsers
        registry.register_parser(Arc::new(PumpFunParser::new()));
        registry.register_parser(Arc::new(PumpAmmParser::new()));

        // Add more default parsers here as they're implemented
        // registry.register_parser(Arc::new(RaydiumParser::new()));
        // registry.register_parser(Arc::new(JupiterParser::new()));

        registry
    }

    /// Register a parser for a program
    pub fn register_parser(&mut self, parser: Arc<dyn ProgramParser>) {
        let program_id = parser.program_id();
        self.parsers.insert(program_id, parser);
    }

    /// Get a parser for a specific program
    pub fn get_parser(&self, program_id: &Pubkey) -> Option<&Arc<dyn ProgramParser>> {
        self.parsers.get(program_id)
    }

    /// Check if a parser exists for a program
    pub fn has_parser(&self, program_id: &Pubkey) -> bool {
        self.parsers.contains_key(program_id)
    }

    /// Get the number of registered parsers
    pub fn len(&self) -> usize {
        self.parsers.len()
    }

    /// Check if the registry is empty
    pub fn is_empty(&self) -> bool {
        self.parsers.is_empty()
    }

    /// Get an iterator over all registered parsers
    pub fn iter(&self) -> impl Iterator<Item = (&Pubkey, &Arc<dyn ProgramParser>)> {
        self.parsers.iter()
    }

    /// Get all registered program IDs
    pub fn program_ids(&self) -> Vec<Pubkey> {
        self.parsers.keys().copied().collect()
    }

    /// Remove a parser from the registry
    pub fn remove_parser(&mut self, program_id: &Pubkey) -> Option<Arc<dyn ProgramParser>> {
        self.parsers.remove(program_id)
    }

    /// Clear all parsers from the registry
    pub fn clear(&mut self) {
        self.parsers.clear();
    }
}

impl Default for ProgramRegistry {
    fn default() -> Self {
        Self::with_defaults()
    }
}

/// Builder pattern for creating a registry with specific parsers
pub struct ProgramRegistryBuilder {
    parsers: Vec<Arc<dyn ProgramParser>>,
}

impl ProgramRegistryBuilder {
    /// Create a new builder
    pub fn new() -> Self {
        Self {
            parsers: Vec::new(),
        }
    }

    /// Add a parser to the builder
    pub fn with_parser(mut self, parser: Arc<dyn ProgramParser>) -> Self {
        self.parsers.push(parser);
        self
    }

    /// Add the default parsers
    pub fn with_defaults(mut self) -> Self {
        self.parsers.push(Arc::new(PumpFunParser::new()));
        self.parsers.push(Arc::new(PumpAmmParser::new()));
        // Add more default parsers here
        self
    }

    /// Build the registry
    pub fn build(self) -> ProgramRegistry {
        let mut registry = ProgramRegistry::new();
        for parser in self.parsers {
            registry.register_parser(parser);
        }
        registry
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_registry_creation() {
        let registry = ProgramRegistry::new();
        assert!(registry.is_empty());
        assert_eq!(registry.len(), 0);
    }

    #[test]
    fn test_registry_with_defaults() {
        let registry = ProgramRegistry::with_defaults();
        assert!(!registry.is_empty());
        assert!(registry.has_parser(&PUMP_FUN_PROGRAM_ID));
    }

    #[test]
    fn test_register_parser() {
        let mut registry = ProgramRegistry::new();
        let parser = Arc::new(PumpFunParser::new());
        registry.register_parser(parser);

        assert_eq!(registry.len(), 1);
        assert!(registry.has_parser(&PUMP_FUN_PROGRAM_ID));
        assert!(registry.get_parser(&PUMP_FUN_PROGRAM_ID).is_some());
    }

    #[test]
    fn test_remove_parser() {
        let mut registry = ProgramRegistry::with_defaults();
        let initial_len = registry.len();

        let removed = registry.remove_parser(&PUMP_FUN_PROGRAM_ID);
        assert!(removed.is_some());
        assert_eq!(registry.len(), initial_len - 1);
        assert!(!registry.has_parser(&PUMP_FUN_PROGRAM_ID));
    }

    #[test]
    fn test_registry_builder() {
        let registry = ProgramRegistryBuilder::new()
            .with_parser(Arc::new(PumpFunParser::new()))
            .build();

        assert_eq!(registry.len(), 1);
        assert!(registry.has_parser(&PUMP_FUN_PROGRAM_ID));
    }

    #[test]
    fn test_registry_builder_with_defaults() {
        let registry = ProgramRegistryBuilder::new().with_defaults().build();

        assert!(!registry.is_empty());
        assert!(registry.has_parser(&PUMP_FUN_PROGRAM_ID));
    }
}
</file>

<file path="serialization.rs">
use solana_sdk::pubkey::Pubkey;

pub fn serialize_pubkey<S>(value: &Pubkey, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    serializer.serialize_str(&value.to_string())
}

pub fn serialize_option_pubkey<S>(value: &Option<Pubkey>, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    match value {
        Some(pubkey) => serializer.serialize_str(&pubkey.to_string()),
        None => serializer.serialize_none(),
    }
}
</file>

<file path="transaction_processor.rs">
use crate::lazy_signature::LazySignature;
use crate::parsers::{
    EventParsingContext, InstructionWithContext, ParsedEvent, ParsedInstruction, ParserResult,
};
use crate::program_registry::ProgramRegistry;
use smallvec::SmallVec;
use solana_sdk::pubkey::Pubkey;
use std::{collections::HashMap, str::FromStr, sync::Arc, time::Instant};
use yellowstone_grpc_proto::prelude::{
    InnerInstructions, SubscribeUpdateTransactionInfo, TokenBalance,
};

/// Represents a fully parsed transaction with all instructions and events
#[derive(Debug, Clone)]
pub struct ParsedTransaction {
    pub signature: LazySignature,
    pub instructions: SmallVec<[ParsedInstructionWithContext; 4]>,
    pub events: SmallVec<[ParsedEvent; 4]>,
    pub token_balances: Vec<TokenBalanceChange>,
    pub compute_units_consumed: Option<u64>,
    pub total_parsing_time_us: u64,
}

/// Parsed instruction with context about where it came from
#[derive(Debug, Clone)]
pub struct ParsedInstructionWithContext {
    pub instruction: ParsedInstruction,
    pub program_id: Pubkey,
    pub instruction_index: usize,
    pub stack_depth: usize,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct TokenBalanceKey {
    pub owner: Pubkey,
    pub mint: Pubkey,
}

#[derive(Debug, Clone)]
pub struct TokenBalanceChange {
    pub key: TokenBalanceKey,
    pub token_account: Option<Pubkey>,
    pub decimals: u8,
    pub pre_amount: Option<u64>,
    pub post_amount: Option<u64>,
}

pub struct TransactionProcessor {
    registry: Arc<ProgramRegistry>,
}

impl TransactionProcessor {
    pub fn new(registry: Arc<ProgramRegistry>) -> Self {
        Self { registry }
    }

    /// Process a transaction from the Yellowstone gRPC stream
    pub fn process_yellowstone_transaction(
        &self,
        signature: &[u8],
        transaction: &SubscribeUpdateTransactionInfo,
    ) -> ParserResult<ParsedTransaction> {
        let start = Instant::now();

        // Extract account keys
        let account_keys = self.extract_yellowstone_account_keys(transaction)?;

        // Process all instructions in a single pass
        let (instructions, all_instructions_for_events) =
            self.process_all_instructions(transaction, &account_keys)?;

        // Parse events using the collected instructions
        let events = self.parse_events_with_instructions(
            transaction,
            &account_keys,
            &all_instructions_for_events,
        )?;

        // Capture token balance changes for downstream consumers
        let token_balances = self.extract_token_balance_changes(transaction, &account_keys);

        let compute_units_consumed = transaction.meta.as_ref().and_then(|meta| {
            if meta.err.is_none() {
                meta.compute_units_consumed
            } else {
                None
            }
        });

        let total_parsing_time_us = start.elapsed().as_micros() as u64;

        Ok(ParsedTransaction {
            signature: LazySignature::new(signature.to_vec()),
            instructions,
            events,
            token_balances,
            compute_units_consumed,
            total_parsing_time_us,
        })
    }

    /// Extract all account keys from the Yellowstone transaction
    fn extract_yellowstone_account_keys(
        &self,
        transaction: &SubscribeUpdateTransactionInfo,
    ) -> ParserResult<Vec<Pubkey>> {
        // Pre-calculate capacity for better performance
        let capacity = transaction
            .transaction
            .as_ref()
            .and_then(|tx| tx.message.as_ref())
            .map(|msg| msg.account_keys.len())
            .unwrap_or(0)
            + transaction
                .meta
                .as_ref()
                .map(|meta| {
                    meta.loaded_writable_addresses.len() + meta.loaded_readonly_addresses.len()
                })
                .unwrap_or(0);

        let mut account_keys = Vec::with_capacity(capacity);

        // Get account keys from the transaction
        if let Some(tx) = &transaction.transaction {
            if let Some(message) = &tx.message {
                // Add static account keys - zero-copy optimization
                for key_bytes in &message.account_keys {
                    if key_bytes.len() == 32 {
                        // Direct conversion without intermediate array
                        if let Ok(bytes) = <[u8; 32]>::try_from(key_bytes.as_slice()) {
                            account_keys.push(Pubkey::from(bytes));
                        }
                    }
                }
            }
        }

        // For v0 transactions, also add loaded addresses from meta
        if let Some(meta) = &transaction.meta {
            // Add loaded writable addresses
            for key_bytes in &meta.loaded_writable_addresses {
                if key_bytes.len() == 32 {
                    if let Ok(bytes) = <[u8; 32]>::try_from(key_bytes.as_slice()) {
                        account_keys.push(Pubkey::from(bytes));
                    }
                }
            }
            // Add loaded readonly addresses
            for key_bytes in &meta.loaded_readonly_addresses {
                if key_bytes.len() == 32 {
                    if let Ok(bytes) = <[u8; 32]>::try_from(key_bytes.as_slice()) {
                        account_keys.push(Pubkey::from(bytes));
                    }
                }
            }
        }

        Ok(account_keys)
    }

    /// Process all instructions in a single pass, extracting parsed instructions, transfers,
    /// and collecting raw instructions for event parsing
    fn process_all_instructions(
        &self,
        transaction: &SubscribeUpdateTransactionInfo,
        account_keys: &[Pubkey],
    ) -> ParserResult<(
        SmallVec<[ParsedInstructionWithContext; 4]>,
        Vec<InstructionWithContext>,
    )> {
        // Pre-calculate capacities
        let instruction_capacity = transaction
            .transaction
            .as_ref()
            .and_then(|tx| tx.message.as_ref())
            .map(|msg| msg.instructions.len())
            .unwrap_or(0)
            + transaction
                .meta
                .as_ref()
                .map(|meta| {
                    meta.inner_instructions
                        .iter()
                        .map(|g| g.instructions.len())
                        .sum()
                })
                .unwrap_or(0);

        let mut parsed_instructions = SmallVec::with_capacity(instruction_capacity);
        let mut all_instructions = Vec::with_capacity(instruction_capacity);
        let mut next_instruction_index = 0usize;

        let mut ordered_inner_groups = transaction.meta.as_ref().map(|meta| {
            let mut groups: Vec<&InnerInstructions> = meta.inner_instructions.iter().collect();
            groups.sort_by_key(|group| group.index);
            groups.into_iter().peekable()
        });

        // Process top-level instructions interleaved with their inner instructions
        if let Some(tx) = &transaction.transaction {
            if let Some(message) = &tx.message {
                for (idx, instruction) in message.instructions.iter().enumerate() {
                    if (instruction.program_id_index as usize) >= account_keys.len() {
                        continue;
                    }

                    let program_id = account_keys[instruction.program_id_index as usize];
                    let compiled_ix = solana_sdk::instruction::CompiledInstruction {
                        program_id_index: instruction.program_id_index as u8,
                        accounts: instruction.accounts.clone(),
                        data: instruction.data.clone(),
                    };

                    self.record_instruction_with_context(
                        &compiled_ix,
                        program_id,
                        0,
                        account_keys,
                        &mut parsed_instructions,
                        &mut all_instructions,
                        &mut next_instruction_index,
                    );

                    if let Some(inner_iter) = ordered_inner_groups.as_mut() {
                        while let Some(group) = inner_iter.peek() {
                            if group.index as usize != idx {
                                break;
                            }

                            let group = inner_iter.next().expect("peeked inner group");
                            self.process_inner_instruction_group(
                                group,
                                account_keys,
                                &mut parsed_instructions,
                                &mut all_instructions,
                                &mut next_instruction_index,
                            );
                        }
                    }
                }
            }
        }

        // Process any remaining inner instruction groups that referenced non-existent parents
        if let Some(inner_iter) = ordered_inner_groups.as_mut() {
            while let Some(group) = inner_iter.next() {
                self.process_inner_instruction_group(
                    group,
                    account_keys,
                    &mut parsed_instructions,
                    &mut all_instructions,
                    &mut next_instruction_index,
                );
            }
        }

        log::debug!(
            "Processed {} instructions, parsed {}",
            all_instructions.len(),
            parsed_instructions.len()
        );

        Ok((parsed_instructions, all_instructions))
    }

    fn record_instruction_with_context(
        &self,
        compiled_ix: &solana_sdk::instruction::CompiledInstruction,
        program_id: Pubkey,
        stack_depth: usize,
        account_keys: &[Pubkey],
        parsed_instructions: &mut SmallVec<[ParsedInstructionWithContext; 4]>,
        all_instructions: &mut Vec<InstructionWithContext>,
        next_instruction_index: &mut usize,
    ) {
        let instruction_index = *next_instruction_index;
        *next_instruction_index = next_instruction_index.saturating_add(1);

        all_instructions.push(InstructionWithContext {
            instruction: compiled_ix.clone(),
            program_id,
            instruction_index,
            stack_depth,
        });

        if let Some(parser) = self.registry.get_parser(&program_id) {
            if let Ok(parsed) = parser.parse_instruction(compiled_ix, account_keys) {
                parsed_instructions.push(ParsedInstructionWithContext {
                    instruction: parsed,
                    program_id,
                    instruction_index,
                    stack_depth,
                });
            }
        }
    }

    fn process_inner_instruction_group(
        &self,
        group: &InnerInstructions,
        account_keys: &[Pubkey],
        parsed_instructions: &mut SmallVec<[ParsedInstructionWithContext; 4]>,
        all_instructions: &mut Vec<InstructionWithContext>,
        next_instruction_index: &mut usize,
    ) {
        for inner_ix in &group.instructions {
            if (inner_ix.program_id_index as usize) >= account_keys.len() {
                continue;
            }

            let program_id = account_keys[inner_ix.program_id_index as usize];
            let stack_depth = inner_ix
                .stack_height
                .map(|height| height.saturating_sub(1) as usize)
                .unwrap_or(1);

            let compiled_ix = solana_sdk::instruction::CompiledInstruction {
                program_id_index: inner_ix.program_id_index as u8,
                accounts: inner_ix.accounts.clone(),
                data: inner_ix.data.clone(),
            };

            self.record_instruction_with_context(
                &compiled_ix,
                program_id,
                stack_depth,
                account_keys,
                parsed_instructions,
                all_instructions,
                next_instruction_index,
            );
        }
    }

    /// Parse events using pre-collected instructions
    fn parse_events_with_instructions(
        &self,
        transaction: &SubscribeUpdateTransactionInfo,
        account_keys: &[Pubkey],
        all_instructions: &[InstructionWithContext],
    ) -> ParserResult<SmallVec<[ParsedEvent; 4]>> {
        let mut all_events = SmallVec::new();

        if let Some(meta) = &transaction.meta {
            log::debug!("Transaction has {} log messages", meta.log_messages.len());
            log::debug!(
                "Transaction has {} total instructions for event parsing",
                all_instructions.len()
            );

            // Log first few messages for debugging
            for (i, log) in meta.log_messages.iter().enumerate().take(10) {
                log::debug!("  Log[{}]: {}", i, log);
            }

            // Log instruction details
            for (i, inst) in all_instructions.iter().enumerate().take(10) {
                log::debug!(
                    "  Instruction[{}]: program_id={}, data_len={}",
                    i,
                    inst.program_id,
                    inst.instruction.data.len()
                );
            }

            // Create event parsing context
            let context = EventParsingContext {
                logs: &meta.log_messages,
                instructions: all_instructions,
            };

            // Pass context to each parser
            log::debug!(
                "Calling event parsers for {} registered programs",
                self.registry.len()
            );
            for (program_id, parser) in self.registry.iter() {
                log::debug!(
                    "Calling parse_events_with_context for program {}",
                    program_id
                );

                let mut needs_log_fallback = true;

                // Try parse_events_with_context first
                match parser.parse_events_with_context(&context, account_keys) {
                    Ok(events) => {
                        if !events.is_empty() {
                            log::debug!(
                                "Parsed {} events from program {} (with context)",
                                events.len(),
                                program_id
                            );
                            all_events.extend(events);
                            needs_log_fallback = false;
                        }
                    }
                    Err(e) => {
                        log::debug!(
                            "Failed to parse events with context for program {}: {}",
                            program_id,
                            e
                        );
                    }
                }

                if needs_log_fallback {
                    log::debug!("Falling back to parse_events for program {}", program_id);
                    match parser.parse_events(&meta.log_messages) {
                        Ok(events) => {
                            if !events.is_empty() {
                                log::debug!(
                                    "Parsed {} events from program {} (from logs)",
                                    events.len(),
                                    program_id
                                );
                                all_events.extend(events);
                            }
                        }
                        Err(e) => {
                            log::debug!(
                                "Failed to parse events from logs for program {}: {}",
                                program_id,
                                e
                            );
                        }
                    }
                }
            }
        } else {
            log::debug!("No transaction metadata available");
        }

        log::debug!("Total events parsed: {}", all_events.len());
        Ok(all_events)
    }

    fn extract_token_balance_changes(
        &self,
        transaction: &SubscribeUpdateTransactionInfo,
        account_keys: &[Pubkey],
    ) -> Vec<TokenBalanceChange> {
        let meta = match transaction.meta.as_ref() {
            Some(meta) => meta,
            None => return Vec::new(),
        };

        let mut balances: HashMap<TokenBalanceKey, TokenBalanceChange> =
            HashMap::with_capacity(meta.post_token_balances.len());

        for pre in &meta.pre_token_balances {
            if let Some(partial) = Self::parse_token_balance(pre, account_keys) {
                let entry = balances
                    .entry(partial.key)
                    .or_insert_with(|| TokenBalanceChange {
                        key: partial.key,
                        token_account: partial.token_account,
                        decimals: partial.decimals.unwrap_or(0),
                        pre_amount: None,
                        post_amount: None,
                    });

                entry.pre_amount = partial.amount;
                if entry.token_account.is_none() {
                    entry.token_account = partial.token_account;
                }
                if let Some(decimals) = partial.decimals {
                    entry.decimals = decimals;
                }
            }
        }

        for post in &meta.post_token_balances {
            if let Some(partial) = Self::parse_token_balance(post, account_keys) {
                let entry = balances
                    .entry(partial.key)
                    .or_insert_with(|| TokenBalanceChange {
                        key: partial.key,
                        token_account: partial.token_account,
                        decimals: partial.decimals.unwrap_or(0),
                        pre_amount: None,
                        post_amount: None,
                    });

                entry.post_amount = partial.amount;
                if entry.token_account.is_none() {
                    entry.token_account = partial.token_account;
                }
                if let Some(decimals) = partial.decimals {
                    entry.decimals = decimals;
                }
            }
        }

        balances.into_values().collect()
    }

    fn parse_token_balance(
        token_balance: &TokenBalance,
        account_keys: &[Pubkey],
    ) -> Option<PartialTokenBalance> {
        let owner = match Pubkey::from_str(token_balance.owner.as_str()) {
            Ok(owner) => owner,
            Err(e) => {
                log::debug!(
                    "Failed to parse token owner {}: {:?}",
                    token_balance.owner,
                    e
                );
                return None;
            }
        };
        let mint = match Pubkey::from_str(token_balance.mint.as_str()) {
            Ok(mint) => mint,
            Err(e) => {
                log::debug!("Failed to parse token mint {}: {:?}", token_balance.mint, e);
                return None;
            }
        };

        let token_account = account_keys
            .get(token_balance.account_index as usize)
            .copied();

        let (amount, decimals) = match token_balance.ui_token_amount.as_ref() {
            Some(ui) => {
                let decimals = ui.decimals.min(u32::from(u8::MAX)) as u8;
                match ui.amount.parse::<u64>() {
                    Ok(value) => (Some(value), Some(decimals)),
                    Err(e) => {
                        log::debug!("Failed to parse token amount {}: {:?}", ui.amount, e);
                        (None, Some(decimals))
                    }
                }
            }
            None => (None, None),
        };

        Some(PartialTokenBalance {
            key: TokenBalanceKey { owner, mint },
            token_account,
            decimals,
            amount,
        })
    }
}

struct PartialTokenBalance {
    key: TokenBalanceKey,
    token_account: Option<Pubkey>,
    decimals: Option<u8>,
    amount: Option<u64>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_transaction_processor_creation() {
        let registry = Arc::new(ProgramRegistry::new());
        let _ = TransactionProcessor::new(registry);

        // Basic smoke test
        assert!(true);
    }
}
</file>

</files>
